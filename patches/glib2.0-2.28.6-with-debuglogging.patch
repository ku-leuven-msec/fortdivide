diff -r --unified glib2.0-2.28.6/config.guess glib2.0-2.28.6-patched//config.guess
--- glib2.0-2.28.6/config.guess	2010-03-29 13:21:24.000000000 +0200
+++ glib2.0-2.28.6-patched//config.guess	2012-06-18 17:11:12.711724237 +0200
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
 #   Free Software Foundation, Inc.
 
-timestamp='2009-11-20'
+timestamp='2009-12-30'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -56,8 +56,9 @@
 GNU config.guess ($timestamp)
 
 Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free
+Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
diff -r --unified glib2.0-2.28.6/config.sub glib2.0-2.28.6-patched//config.sub
--- glib2.0-2.28.6/config.sub	2010-03-29 13:21:24.000000000 +0200
+++ glib2.0-2.28.6-patched//config.sub	2012-06-18 17:11:12.719724107 +0200
@@ -1,10 +1,10 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+#   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
 #   Free Software Foundation, Inc.
 
-timestamp='2009-11-20'
+timestamp='2010-01-22'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -75,8 +75,9 @@
 version="\
 GNU config.sub ($timestamp)
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
+2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free
+Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -380,7 +381,8 @@
 	| sparclite-* \
 	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | strongarm-* | sv1-* | sx?-* \
 	| tahoe-* | thumb-* \
-	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* | tile-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tile-* | tilegx-* \
 	| tron-* \
 	| ubicom32-* \
 	| v850-* | v850e-* | vax-* \
@@ -1085,6 +1087,11 @@
 		basic_machine=tic6x-unknown
 		os=-coff
 		;;
+        # This must be matched before tile*.
+        tilegx*)
+		basic_machine=tilegx-unknown
+		os=-linux-gnu
+		;;
 	tile*)
 		basic_machine=tile-unknown
 		os=-linux-gnu
@@ -1435,6 +1442,8 @@
 	-dicos*)
 		os=-dicos
 		;;
+        -nacl*)
+	        ;;
 	-none)
 		;;
 	*)
diff -r --unified glib2.0-2.28.6/docs/reference/glib/running.sgml glib2.0-2.28.6-patched//docs/reference/glib/running.sgml
--- glib2.0-2.28.6/docs/reference/glib/running.sgml	2010-09-27 20:48:33.000000000 +0200
+++ glib2.0-2.28.6-patched//docs/reference/glib/running.sgml	2012-01-12 14:51:42.000000000 +0100
@@ -213,6 +213,22 @@
   </para>
 </formalpara>
 
+<formalpara id="G_HOME">
+  <title><envar>G_HOME</envar></title>
+
+  <para>
+    For various reasons, GLib applications ignore the <envar>HOME</envar>
+    environment variable on Unix systems and will use the user directory
+    as specified by the <filename>passwd</filename> entry, which is more
+    reliable.
+  </para>
+  <para>
+    The <envar>G_HOME</envar> environment variable will override any
+    other setting for the home directory. It is not meant for daily usage,
+    but it is useful in testing or building environments.
+  </para>
+</formalpara>
+
 </refsect2>
 
 <refsect2 id="setlocale">
diff -r --unified glib2.0-2.28.6/gio/gdbusconnection.c glib2.0-2.28.6-patched//gio/gdbusconnection.c
--- glib2.0-2.28.6/gio/gdbusconnection.c	2011-04-14 00:55:29.000000000 +0200
+++ glib2.0-2.28.6-patched//gio/gdbusconnection.c	2012-01-31 17:54:57.514534180 +0100
@@ -196,7 +196,7 @@
   GMainContext               *context;
 } CallDestroyNotifyData;
 
-static gboolean
+gboolean
 call_destroy_notify_data_in_idle (gpointer user_data)
 {
   CallDestroyNotifyData *data = user_data;
@@ -204,7 +204,7 @@
   return FALSE;
 }
 
-static void
+void
 call_destroy_notify_data_free (CallDestroyNotifyData *data)
 {
   if (data->context != NULL)
@@ -220,7 +220,7 @@
  *
  * Schedules @callback to run in @context.
  */
-static void
+void
 call_destroy_notify (GMainContext  *context,
                      GDestroyNotify callback,
                      gpointer       user_data)
@@ -260,7 +260,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static gboolean
+gboolean
 _g_strv_has_string (const gchar* const *haystack,
                     const gchar        *needle)
 {
@@ -399,10 +399,10 @@
 };
 
 typedef struct ExportedObject ExportedObject;
-static void exported_object_free (ExportedObject *eo);
+void exported_object_free (ExportedObject *eo);
 
 typedef struct ExportedSubtree ExportedSubtree;
-static void exported_subtree_free (ExportedSubtree *es);
+void exported_subtree_free (ExportedSubtree *es);
 
 enum
 {
@@ -424,18 +424,18 @@
   PROP_AUTHENTICATION_OBSERVER,
 };
 
-static void distribute_signals (GDBusConnection  *connection,
+void distribute_signals (GDBusConnection  *connection,
                                 GDBusMessage     *message);
 
-static void distribute_method_call (GDBusConnection  *connection,
+void distribute_method_call (GDBusConnection  *connection,
                                     GDBusMessage     *message);
 
-static gboolean handle_generic_unlocked (GDBusConnection *connection,
+gboolean handle_generic_unlocked (GDBusConnection *connection,
                                          GDBusMessage    *message);
 
 
-static void purge_all_signal_subscriptions (GDBusConnection *connection);
-static void purge_all_filters (GDBusConnection *connection);
+void purge_all_signal_subscriptions (GDBusConnection *connection);
+void purge_all_filters (GDBusConnection *connection);
 
 #define _G_ENSURE_LOCK(name) do {                                       \
     if (G_UNLIKELY (G_TRYLOCK(name)))                                   \
@@ -447,8 +447,8 @@
 
 static guint signals[LAST_SIGNAL] = { 0 };
 
-static void initable_iface_init       (GInitableIface      *initable_iface);
-static void async_initable_iface_init (GAsyncInitableIface *async_initable_iface);
+void initable_iface_init       (GInitableIface      *initable_iface);
+void async_initable_iface_init (GAsyncInitableIface *async_initable_iface);
 
 G_DEFINE_TYPE_WITH_CODE (GDBusConnection, g_dbus_connection, G_TYPE_OBJECT,
                          G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE, initable_iface_init)
@@ -457,7 +457,7 @@
 
 static GHashTable *alive_connections = NULL;
 
-static void
+void
 g_dbus_connection_dispose (GObject *object)
 {
   GDBusConnection *connection = G_DBUS_CONNECTION (object);
@@ -491,7 +491,7 @@
     G_OBJECT_CLASS (g_dbus_connection_parent_class)->dispose (object);
 }
 
-static void
+void
 g_dbus_connection_finalize (GObject *object)
 {
   GDBusConnection *connection = G_DBUS_CONNECTION (object);
@@ -554,7 +554,7 @@
   G_OBJECT_CLASS (g_dbus_connection_parent_class)->finalize (object);
 }
 
-static void
+void
 g_dbus_connection_get_property (GObject    *object,
                                 guint       prop_id,
                                 GValue     *value,
@@ -594,7 +594,7 @@
     }
 }
 
-static void
+void
 g_dbus_connection_set_property (GObject      *object,
                                 guint         prop_id,
                                 const GValue *value,
@@ -634,7 +634,7 @@
     }
 }
 
-static void
+void
 g_dbus_connection_real_closed (GDBusConnection *connection,
                                gboolean         remote_peer_vanished,
                                GError          *error)
@@ -656,7 +656,7 @@
     }
 }
 
-static void
+void
 g_dbus_connection_class_init (GDBusConnectionClass *klass)
 {
   GObjectClass *gobject_class;
@@ -904,7 +904,7 @@
                                          G_TYPE_ERROR);
 }
 
-static void
+void
 g_dbus_connection_init (GDBusConnection *connection)
 {
   connection->lock = g_mutex_new ();
@@ -1015,7 +1015,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static void
+void
 flush_in_thread_func (GSimpleAsyncResult *res,
                       GObject            *object,
                       GCancellable       *cancellable)
@@ -1166,7 +1166,7 @@
   gboolean remote_peer_vanished;
 } EmitClosedData;
 
-static void
+void
 emit_closed_data_free (EmitClosedData *data)
 {
   g_object_unref (data->connection);
@@ -1175,7 +1175,7 @@
   g_free (data);
 }
 
-static gboolean
+gboolean
 emit_closed_in_idle (gpointer user_data)
 {
   EmitClosedData *data = user_data;
@@ -1192,7 +1192,7 @@
 }
 
 /* Can be called from any thread, must hold lock */
-static void
+void
 set_closed_unlocked (GDBusConnection *connection,
                      gboolean         remote_peer_vanished,
                      GError          *error)
@@ -1223,7 +1223,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static void
+void
 close_in_thread_func (GSimpleAsyncResult *res,
                       GObject            *object,
                       GCancellable       *cancellable)
@@ -1380,7 +1380,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static gboolean
+gboolean
 g_dbus_connection_send_message_unlocked (GDBusConnection   *connection,
                                          GDBusMessage      *message,
                                          GDBusSendMessageFlags flags,
@@ -1543,14 +1543,14 @@
   gboolean delivered;
 } SendMessageData;
 
-static SendMessageData *
+SendMessageData *
 send_message_data_ref (SendMessageData *data)
 {
   g_atomic_int_inc (&data->ref_count);
   return data;
 }
 
-static void
+void
 send_message_data_unref (SendMessageData *data)
 {
   if (g_atomic_int_dec_and_test (&data->ref_count))
@@ -1570,7 +1570,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* can be called from any thread with lock held - caller must have prepared GSimpleAsyncResult already */
-static void
+void
 send_message_with_reply_deliver (SendMessageData *data)
 {
   CONNECTION_ENSURE_LOCK (data->connection);
@@ -1603,7 +1603,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* must hold lock */
-static void
+void
 send_message_data_deliver_reply_unlocked (SendMessageData *data,
                                           GDBusMessage    *reply)
 {
@@ -1622,7 +1622,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static gboolean
+gboolean
 send_message_with_reply_cancelled_idle_cb (gpointer user_data)
 {
   SendMessageData *data = user_data;
@@ -1644,7 +1644,7 @@
 }
 
 /* Can be called from any thread with or without lock held */
-static void
+void
 send_message_with_reply_cancelled_cb (GCancellable *cancellable,
                                       gpointer      user_data)
 {
@@ -1666,7 +1666,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static gboolean
+gboolean
 send_message_with_reply_timeout_cb (gpointer user_data)
 {
   SendMessageData *data = user_data;
@@ -1690,7 +1690,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static void
+void
 g_dbus_connection_send_message_with_reply_unlocked (GDBusConnection     *connection,
                                                     GDBusMessage        *message,
                                                     GDBusSendMessageFlags flags,
@@ -1924,7 +1924,7 @@
   GMainLoop *loop;
 } SendMessageSyncData;
 
-static void
+void
 send_message_with_reply_sync_cb (GDBusConnection *connection,
                                  GAsyncResult    *res,
                                  gpointer         user_data)
@@ -2042,7 +2042,7 @@
 } FilterData;
 
 /* Called in worker's thread - we must not block */
-static void
+void
 on_worker_message_received (GDBusWorker  *worker,
                             GDBusMessage *message,
                             gpointer      user_data)
@@ -2148,7 +2148,7 @@
 }
 
 /* Called in worker's thread */
-static GDBusMessage *
+GDBusMessage *
 on_worker_message_about_to_be_sent (GDBusWorker  *worker,
                                     GDBusMessage *message,
                                     gpointer      user_data)
@@ -2203,7 +2203,7 @@
 }
 
 /* Called in worker's thread - we must not block */
-static void
+void
 on_worker_closed (GDBusWorker *worker,
                   gboolean     remote_peer_vanished,
                   GError      *error,
@@ -2236,7 +2236,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* Determines the biggest set of capabilities we can support on this connection */
-static GDBusCapabilityFlags
+GDBusCapabilityFlags
 get_offered_capabilities_max (GDBusConnection *connection)
 {
       GDBusCapabilityFlags ret;
@@ -2248,7 +2248,7 @@
       return ret;
 }
 
-static gboolean
+gboolean
 initable_init (GInitable     *initable,
                GCancellable  *cancellable,
                GError       **error)
@@ -2434,7 +2434,7 @@
   return ret;
 }
 
-static void
+void
 initable_iface_init (GInitableIface *initable_iface)
 {
   initable_iface->init = initable_init;
@@ -2442,7 +2442,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static void
+void
 async_initable_iface_init (GAsyncInitableIface *async_initable_iface)
 {
   /* Use default */
@@ -2885,7 +2885,7 @@
 }
 
 /* only called from finalize(), removes all filters */
-static void
+void
 purge_all_filters (GDBusConnection *connection)
 {
   guint n;
@@ -2966,7 +2966,7 @@
   GMainContext *context;
 } SignalSubscriber;
 
-static void
+void
 signal_data_free (SignalData *signal_data)
 {
   g_free (signal_data->rule);
@@ -2980,7 +2980,7 @@
   g_free (signal_data);
 }
 
-static gchar *
+gchar *
 args_to_rule (const gchar *sender,
               const gchar *interface_name,
               const gchar *member,
@@ -3014,7 +3014,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* must hold lock when calling */
-static void
+void
 add_match_rule (GDBusConnection *connection,
                 const gchar     *match_rule)
 {
@@ -3045,7 +3045,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* must hold lock when calling */
-static void
+void
 remove_match_rule (GDBusConnection *connection,
                    const gchar     *match_rule)
 {
@@ -3076,7 +3076,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static gboolean
+gboolean
 is_signal_data_for_name_lost_or_acquired (SignalData *signal_data)
 {
   return g_strcmp0 (signal_data->sender_unique_name, "org.freedesktop.DBus") == 0 &&
@@ -3241,7 +3241,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* must hold lock when calling this (except if connection->finalizing is TRUE) */
-static void
+void
 unsubscribe_id_internal (GDBusConnection *connection,
                          guint            subscription_id,
                          GArray          *out_removed_subscribers)
@@ -3367,7 +3367,7 @@
 /* called on delivery thread (e.g. where g_dbus_connection_signal_subscribe() was called) with
  * no locks held
  */
-static gboolean
+gboolean
 emit_signal_instance_in_idle_cb (gpointer data)
 {
   SignalInstance *signal_instance = data;
@@ -3418,7 +3418,7 @@
   return FALSE;
 }
 
-static void
+void
 signal_instance_free (SignalInstance *signal_instance)
 {
   g_object_unref (signal_instance->message);
@@ -3427,7 +3427,7 @@
 }
 
 /* called in message handler thread WITH lock held */
-static void
+void
 schedule_callbacks (GDBusConnection *connection,
                     GPtrArray       *signal_data_array,
                     GDBusMessage    *message,
@@ -3514,7 +3514,7 @@
 }
 
 /* called in message handler thread with lock held */
-static void
+void
 distribute_signals (GDBusConnection *connection,
                     GDBusMessage    *message)
 {
@@ -3555,7 +3555,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* only called from finalize(), removes all subscriptions */
-static void
+void
 purge_all_signal_subscriptions (GDBusConnection *connection)
 {
   GHashTableIter iter;
@@ -3599,7 +3599,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static GDBusInterfaceVTable *
+GDBusInterfaceVTable *
 _g_dbus_interface_vtable_copy (const GDBusInterfaceVTable *vtable)
 {
   /* Don't waste memory by copying padding - remember to update this
@@ -3608,7 +3608,7 @@
   return g_memdup ((gconstpointer) vtable, 3 * sizeof (gpointer));
 }
 
-static void
+void
 _g_dbus_interface_vtable_free (GDBusInterfaceVTable *vtable)
 {
   g_free (vtable);
@@ -3616,7 +3616,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static GDBusSubtreeVTable *
+GDBusSubtreeVTable *
 _g_dbus_subtree_vtable_copy (const GDBusSubtreeVTable *vtable)
 {
   /* Don't waste memory by copying padding - remember to update this
@@ -3625,7 +3625,7 @@
   return g_memdup ((gconstpointer) vtable, 3 * sizeof (gpointer));
 }
 
-static void
+void
 _g_dbus_subtree_vtable_free (GDBusSubtreeVTable *vtable)
 {
   g_free (vtable);
@@ -3643,7 +3643,7 @@
 };
 
 /* only called with lock held */
-static void
+void
 exported_object_free (ExportedObject *eo)
 {
   g_free (eo->object_path);
@@ -3666,7 +3666,7 @@
 } ExportedInterface;
 
 /* called with lock held */
-static void
+void
 exported_interface_free (ExportedInterface *ei)
 {
   g_dbus_interface_info_unref ((GDBusInterfaceInfo *) ei->interface_info);
@@ -3691,7 +3691,7 @@
  *
  * Caller must *not* hold lock.
  */
-static gboolean
+gboolean
 has_object_been_unregistered (GDBusConnection  *connection,
                               guint             registration_id,
                               guint             subtree_registration_id)
@@ -3733,7 +3733,7 @@
   guint subtree_registration_id;
 } PropertyData;
 
-static void
+void
 property_data_free (PropertyData *data)
 {
   g_object_unref (data->connection);
@@ -3742,7 +3742,7 @@
 }
 
 /* called in thread where object was registered - no locks held */
-static gboolean
+gboolean
 invoke_get_property_in_idle_cb (gpointer _data)
 {
   PropertyData *data = _data;
@@ -3804,7 +3804,7 @@
 }
 
 /* called in thread where object was registered - no locks held */
-static gboolean
+gboolean
 invoke_set_property_in_idle_cb (gpointer _data)
 {
   PropertyData *data = _data;
@@ -3868,7 +3868,7 @@
 }
 
 /* called with lock held */
-static gboolean
+gboolean
 validate_and_maybe_schedule_property_getset (GDBusConnection            *connection,
                                              GDBusMessage               *message,
                                              guint                       registration_id,
@@ -3982,7 +3982,7 @@
 }
 
 /* called with lock held */
-static gboolean
+gboolean
 handle_getset_property (GDBusConnection *connection,
                         ExportedObject  *eo,
                         GDBusMessage    *message,
@@ -4050,7 +4050,7 @@
   guint subtree_registration_id;
 } PropertyGetAllData;
 
-static void
+void
 property_get_all_data_free (PropertyData *data)
 {
   g_object_unref (data->connection);
@@ -4059,7 +4059,7 @@
 }
 
 /* called in thread where object was registered - no locks held */
-static gboolean
+gboolean
 invoke_get_all_properties_in_idle_cb (gpointer _data)
 {
   PropertyGetAllData *data = _data;
@@ -4130,7 +4130,7 @@
 }
 
 /* called with lock held */
-static gboolean
+gboolean
 validate_and_maybe_schedule_property_get_all (GDBusConnection            *connection,
                                               GDBusMessage               *message,
                                               guint                       registration_id,
@@ -4180,7 +4180,7 @@
 }
 
 /* called with lock held */
-static gboolean
+gboolean
 handle_get_all_properties (GDBusConnection *connection,
                            ExportedObject  *eo,
                            GDBusMessage    *message)
@@ -4271,13 +4271,13 @@
   "    </method>\n"
   "  </interface>\n";
 
-static void
+void
 introspect_append_header (GString *s)
 {
   g_string_append (s, introspect_header);
 }
 
-static void
+void
 maybe_add_path (const gchar *path, gsize path_len, const gchar *object_path, GHashTable *set)
 {
   if (g_str_has_prefix (object_path, path) && strlen (object_path) > path_len && object_path[path_len-1] == '/')
@@ -4301,7 +4301,7 @@
 }
 
 /* TODO: we want a nicer public interface for this */
-static gchar **
+gchar **
 g_dbus_connection_list_registered_unlocked (GDBusConnection *connection,
                                             const gchar     *path)
 {
@@ -4342,7 +4342,7 @@
   return ret;
 }
 
-static gchar **
+gchar **
 g_dbus_connection_list_registered (GDBusConnection *connection,
                                    const gchar     *path)
 {
@@ -4354,7 +4354,7 @@
 }
 
 /* called in message handler thread with lock held */
-static gboolean
+gboolean
 handle_introspect (GDBusConnection *connection,
                    ExportedObject  *eo,
                    GDBusMessage    *message)
@@ -4402,7 +4402,7 @@
 }
 
 /* called in thread where object was registered - no locks held */
-static gboolean
+gboolean
 call_in_idle_cb (gpointer user_data)
 {
   GDBusMethodInvocation *invocation = G_DBUS_METHOD_INVOCATION (user_data);
@@ -4445,7 +4445,7 @@
 }
 
 /* called in message handler thread with lock held */
-static gboolean
+gboolean
 validate_and_maybe_schedule_method_call (GDBusConnection            *connection,
                                          GDBusMessage               *message,
                                          guint                       registration_id,
@@ -4555,7 +4555,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* called in message handler thread with lock held */
-static gboolean
+gboolean
 obj_message_func (GDBusConnection *connection,
                   ExportedObject  *eo,
                   GDBusMessage    *message)
@@ -4886,7 +4886,7 @@
   return ret;
 }
 
-static void
+void
 add_call_flags (GDBusMessage           *message,
                          GDBusCallFlags  flags)
 {
@@ -4894,7 +4894,7 @@
     g_dbus_message_set_flags (message, G_DBUS_MESSAGE_FLAGS_NO_AUTO_START);
 }
 
-static GVariant *
+GVariant *
 decode_method_reply (GDBusMessage        *reply,
                      const gchar         *method_name,
                      const GVariantType  *reply_type,
@@ -4954,7 +4954,7 @@
   guint32 serial;
 } CallState;
 
-static void
+void
 g_dbus_connection_call_done (GObject      *source,
                              GAsyncResult *result,
                              gpointer      user_data)
@@ -5360,7 +5360,7 @@
   GDestroyNotify            user_data_free_func;
 };
 
-static void
+void
 exported_subtree_free (ExportedSubtree *es)
 {
   call_destroy_notify (es->context,
@@ -5376,7 +5376,7 @@
 }
 
 /* called without lock held */
-static gboolean
+gboolean
 handle_subtree_introspect (GDBusConnection *connection,
                            ExportedSubtree *es,
                            GDBusMessage    *message)
@@ -5485,7 +5485,7 @@
 }
 
 /* called without lock held */
-static gboolean
+gboolean
 handle_subtree_method_invocation (GDBusConnection *connection,
                                   ExportedSubtree *es,
                                   GDBusMessage    *message)
@@ -5700,7 +5700,7 @@
   ExportedSubtree *es;
 } SubtreeDeferredData;
 
-static void
+void
 subtree_deferred_data_free (SubtreeDeferredData *data)
 {
   g_object_unref (data->message);
@@ -5708,7 +5708,7 @@
 }
 
 /* called without lock held in the thread where the caller registered the subtree */
-static gboolean
+gboolean
 process_subtree_vtable_message_in_idle_cb (gpointer _data)
 {
   SubtreeDeferredData *data = _data;
@@ -5752,7 +5752,7 @@
 }
 
 /* called in message handler thread with lock held */
-static gboolean
+gboolean
 subtree_message_func (GDBusConnection *connection,
                       ExportedSubtree *es,
                       GDBusMessage    *message)
@@ -5934,7 +5934,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* must be called with lock held */
-static void
+void
 handle_generic_ping_unlocked (GDBusConnection *connection,
                               const gchar     *object_path,
                               GDBusMessage    *message)
@@ -5946,7 +5946,7 @@
 }
 
 /* must be called with lock held */
-static void
+void
 handle_generic_get_machine_id_unlocked (GDBusConnection *connection,
                                         const gchar     *object_path,
                                         GDBusMessage    *message)
@@ -5979,7 +5979,7 @@
 }
 
 /* must be called with lock held */
-static void
+void
 handle_generic_introspect_unlocked (GDBusConnection *connection,
                                     const gchar     *object_path,
                                     GDBusMessage    *message)
@@ -6007,7 +6007,7 @@
 }
 
 /* must be called with lock held */
-static gboolean
+gboolean
 handle_generic_unlocked (GDBusConnection *connection,
                          GDBusMessage    *message)
 {
@@ -6054,7 +6054,7 @@
 /* ---------------------------------------------------------------------------------------------------- */
 
 /* called in message handler thread with lock held */
-static void
+void
 distribute_method_call (GDBusConnection *connection,
                         GDBusMessage    *message)
 {
@@ -6157,7 +6157,7 @@
 
 /* ---------------------------------------------------------------------------------------------------- */
 
-static GDBusConnection **
+GDBusConnection **
 message_bus_get_singleton (GBusType   bus_type,
                            GError   **error)
 {
@@ -6219,7 +6219,7 @@
   return ret;
 }
 
-static GDBusConnection *
+GDBusConnection *
 get_uninitialized_connection (GBusType       bus_type,
                               GCancellable  *cancellable,
                               GError       **error)
@@ -6310,7 +6310,7 @@
   return connection;
 }
 
-static void
+void
 bus_get_async_initable_cb (GObject      *source_object,
                            GAsyncResult *res,
                            gpointer      user_data)
diff -r --unified glib2.0-2.28.6/gio/gdesktopappinfo.c glib2.0-2.28.6-patched//gio/gdesktopappinfo.c
--- glib2.0-2.28.6/gio/gdesktopappinfo.c	2011-03-29 18:34:52.000000000 +0200
+++ glib2.0-2.28.6-patched//gio/gdesktopappinfo.c	2012-01-12 14:51:42.000000000 +0100
@@ -74,6 +74,12 @@
 static void     mime_info_cache_reload                (const char       *dir);
 static gboolean g_desktop_app_info_ensure_saved       (GDesktopAppInfo  *info,
 						       GError          **error);
+static void
+g_desktop_app_info_launch_handler_on_launched (GDesktopAppInfoLaunchHandler *launch_handler,
+                                               GDesktopAppInfo              *app_info,
+                                               GList                        *uris,
+                                               GAppLaunchContext            *launch_ctx,
+                                               gint                          pid);
 
 /**
  * GDesktopAppInfo:
@@ -995,6 +1001,49 @@
   g_object_unref (msg);
 }
 
+static void
+g_desktop_app_info_on_launched (GDesktopAppInfo   *app_info,
+                                GList             *uris,
+                                GAppLaunchContext *launch_ctx,
+                                gint               pid)
+{
+  static gsize lookup = 0;
+
+  if (g_once_init_enter (&lookup))
+    {
+      gsize setup_value = 1;
+      GDesktopAppInfoLaunchHandler *lookup_instance;
+      GIOExtensionPoint *ep;
+      GIOExtension *extension;
+      GList *l;
+
+      /* Ensure vfs in modules loaded */
+      _g_io_modules_ensure_loaded ();
+
+      ep = g_io_extension_point_lookup (G_DESKTOP_APP_INFO_LAUNCH_HANDLER_EXTENSION_POINT_NAME);
+
+      lookup_instance = NULL;
+      for (l = g_io_extension_point_get_extensions (ep); l != NULL; l = l->next)
+        {
+          extension = l->data;
+          lookup_instance = g_object_new (g_io_extension_get_type (extension), NULL);
+          if (lookup_instance != NULL)
+            break;
+	      }
+
+      if (lookup_instance != NULL)
+        setup_value = (gsize)lookup_instance;
+
+      g_once_init_leave (&lookup, setup_value);
+    }
+
+  if (lookup == 1)
+    return;
+
+  g_desktop_app_info_launch_handler_on_launched (G_DESKTOP_APP_INFO_LAUNCH_HANDLER (lookup),
+                                                 app_info, uris, launch_ctx, pid);
+}
+
 #define _SPAWN_FLAGS_DEFAULT (G_SPAWN_SEARCH_PATH)
 
 static gboolean
@@ -1086,6 +1135,10 @@
 
 	  goto out;
 	}
+      else
+        {
+          g_desktop_app_info_on_launched (info, old_uris, launch_context, pid);
+        }
 
       if (pid_callback != NULL)
 	pid_callback (info, pid, pid_callback_data);
@@ -3120,6 +3173,72 @@
   return desktop_entries;
 }
 
+/* GDesktopAppInfoLaunchHandler interface: */
+
+static void g_desktop_app_info_launch_handler_base_init (gpointer g_class);
+static void g_desktop_app_info_launch_handler_class_init (gpointer g_class,
+						  gpointer class_data);
+
+GType
+g_desktop_app_info_launch_handler_get_type (void)
+{
+  static volatile gsize g_define_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_define_type_id__volatile))
+    {
+      const GTypeInfo desktop_app_info_launch_handler_info =
+      {
+        sizeof (GDesktopAppInfoLaunchHandlerIface), /* class_size */
+      	g_desktop_app_info_launch_handler_base_init,   /* base_init */
+      	NULL,		/* base_finalize */
+      	g_desktop_app_info_launch_handler_class_init,
+      	NULL,		/* class_finalize */
+      	NULL,		/* class_data */
+      	0,
+      	0,              /* n_preallocs */
+      	NULL
+      };
+      
+      GType g_define_type_id =
+      	      g_type_register_static (G_TYPE_INTERFACE,
+      	                              I_("GDesktopAppInfoLaunchHandler"),
+			                                &desktop_app_info_launch_handler_info, 0);
+
+      g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_OBJECT);
+
+      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
+    }
+
+  return g_define_type_id__volatile;
+}
+
+static void
+g_desktop_app_info_launch_handler_class_init (gpointer g_class,
+				      gpointer class_data)
+{
+}
+
+static void
+g_desktop_app_info_launch_handler_base_init (gpointer g_class)
+{
+}
+
+static void
+g_desktop_app_info_launch_handler_on_launched (GDesktopAppInfoLaunchHandler *launch_handler,
+                                               GDesktopAppInfo              *app_info,
+                                               GList                        *uris,
+                                               GAppLaunchContext            *launch_ctx,
+                                               gint                          pid)
+{
+  GDesktopAppInfoLaunchHandlerIface *iface;
+
+  g_return_if_fail (G_IS_DESKTOP_APP_INFO_LAUNCH_HANDLER (launch_handler));
+
+  iface = G_DESKTOP_APP_INFO_LAUNCH_HANDLER_GET_IFACE (launch_handler);
+
+  (* iface->on_launched) (launch_handler, app_info, uris, launch_ctx, pid);
+}
+
 /* GDesktopAppInfoLookup interface: */
 
 typedef GDesktopAppInfoLookupIface GDesktopAppInfoLookupInterface;
diff -r --unified glib2.0-2.28.6/gio/gdesktopappinfo.h glib2.0-2.28.6-patched//gio/gdesktopappinfo.h
--- glib2.0-2.28.6/gio/gdesktopappinfo.h	2011-01-05 22:44:06.000000000 +0100
+++ glib2.0-2.28.6-patched//gio/gdesktopappinfo.h	2012-01-12 14:51:42.000000000 +0100
@@ -119,6 +119,37 @@
 
 #endif /* G_DISABLE_DEPRECATED */
 
+
+
+#define G_TYPE_DESKTOP_APP_INFO_LAUNCH_HANDLER           (g_desktop_app_info_launch_handler_get_type ())
+#define G_DESKTOP_APP_INFO_LAUNCH_HANDLER(obj)           (G_TYPE_CHECK_INSTANCE_CAST ((obj), G_TYPE_DESKTOP_APP_INFO_LAUNCH_HANDLER, GDesktopAppInfoLaunchHandler))
+#define G_IS_DESKTOP_APP_INFO_LAUNCH_HANDLER(obj)	 (G_TYPE_CHECK_INSTANCE_TYPE ((obj), G_TYPE_DESKTOP_APP_INFO_LAUNCH_HANDLER))
+#define G_DESKTOP_APP_INFO_LAUNCH_HANDLER_GET_IFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), G_TYPE_DESKTOP_APP_INFO_LAUNCH_HANDLER, GDesktopAppInfoLaunchHandlerIface))
+
+/**
+ * G_DESKTOP_APP_INFO_LAUNCH_HANDLER_EXTENSION_POINT_NAME:
+ *
+ * Extension point for default handler to launching. See
+ * <link linkend="extending-gio">Extending GIO</link>.
+ */
+#define G_DESKTOP_APP_INFO_LAUNCH_HANDLER_EXTENSION_POINT_NAME "gio-desktop-app-info-launch-handler"
+
+typedef struct _GDesktopAppInfoLaunchHandler GDesktopAppInfoLaunchHandler;
+typedef struct _GDesktopAppInfoLaunchHandlerIface GDesktopAppInfoLaunchHandlerIface;
+
+struct _GDesktopAppInfoLaunchHandlerIface
+{
+  GTypeInterface g_iface;
+
+  void (* on_launched) (GDesktopAppInfoLaunchHandler *launch_handler,
+                        GDesktopAppInfo              *app_info,
+                        GList                        *uris,
+                        GAppLaunchContext            *launch_ctx,
+                        gint                          pid);
+};
+
+GType     g_desktop_app_info_launch_handler_get_type                   (void) G_GNUC_CONST;
+
 G_END_DECLS
 
 #endif /* __G_DESKTOP_APP_INFO_H__ */
diff -r --unified glib2.0-2.28.6/gio/giomodule.c glib2.0-2.28.6-patched//gio/giomodule.c
--- glib2.0-2.28.6/gio/giomodule.c	2011-01-05 22:44:06.000000000 +0100
+++ glib2.0-2.28.6-patched//gio/giomodule.c	2012-01-12 14:51:42.000000000 +0100
@@ -559,6 +559,9 @@
       ep = g_io_extension_point_register (G_PROXY_EXTENSION_POINT_NAME);
       g_io_extension_point_set_required_type (ep, G_TYPE_PROXY);
 
+      ep = g_io_extension_point_register (G_DESKTOP_APP_INFO_LAUNCH_HANDLER_EXTENSION_POINT_NAME);
+      g_io_extension_point_set_required_type (ep, G_TYPE_DESKTOP_APP_INFO_LAUNCH_HANDLER);
+
       ep = g_io_extension_point_register (G_TLS_BACKEND_EXTENSION_POINT_NAME);
       g_io_extension_point_set_required_type (ep, G_TYPE_TLS_BACKEND);
     }
@@ -581,6 +584,8 @@
       loaded_dirs = TRUE;
 
       g_io_modules_scan_all_in_directory (GIO_MODULE_DIR);
+      /* Hard-coded fallback directory for pre-multiarch compatibility */
+      g_io_modules_scan_all_in_directory ("/usr/lib/gio/modules");
 
       module_path = g_getenv ("GIO_EXTRA_MODULES");
 
diff -r --unified glib2.0-2.28.6/gio/gio.symbols glib2.0-2.28.6-patched//gio/gio.symbols
--- glib2.0-2.28.6/gio/gio.symbols	2011-04-14 00:55:29.000000000 +0200
+++ glib2.0-2.28.6-patched//gio/gio.symbols	2012-01-12 14:51:42.000000000 +0100
@@ -135,6 +135,7 @@
 g_desktop_app_info_get_filename
 g_desktop_app_info_get_is_hidden
 g_desktop_app_info_get_type G_GNUC_CONST
+g_desktop_app_info_launch_handler_on_launched
 g_desktop_app_info_launch_uris_as_manager
 g_desktop_app_info_lookup_get_type G_GNUC_CONST
 g_desktop_app_info_lookup_get_default_for_uri_scheme
diff -r --unified glib2.0-2.28.6/gio/gsettings.c glib2.0-2.28.6-patched//gio/gsettings.c
--- glib2.0-2.28.6/gio/gsettings.c	2011-04-14 00:55:29.000000000 +0200
+++ glib2.0-2.28.6-patched//gio/gsettings.c	2012-02-02 00:04:59.676888511 +0100
@@ -266,7 +266,7 @@
 G_DEFINE_TYPE (GSettings, g_settings, G_TYPE_OBJECT)
 
 /* Signals {{{1 */
-static gboolean
+gboolean
 g_settings_real_change_event (GSettings    *settings,
                               const GQuark *keys,
                               gint          n_keys)
@@ -283,7 +283,7 @@
   return FALSE;
 }
 
-static gboolean
+gboolean
 g_settings_real_writable_change_event (GSettings *settings,
                                        GQuark     key)
 {
@@ -301,7 +301,7 @@
   return FALSE;
 }
 
-static void
+void
 settings_backend_changed (GObject             *target,
                           GSettingsBackend    *backend,
                           const gchar         *key,
@@ -336,7 +336,7 @@
     }
 }
 
-static void
+void
 settings_backend_path_changed (GObject          *target,
                                GSettingsBackend *backend,
                                const gchar      *path,
@@ -350,7 +350,7 @@
                    0, NULL, 0, &ignore_this);
 }
 
-static void
+void
 settings_backend_keys_changed (GObject             *target,
                                GSettingsBackend    *backend,
                                const gchar         *path,
@@ -392,7 +392,7 @@
     }
 }
 
-static void
+void
 settings_backend_writable_changed (GObject          *target,
                                    GSettingsBackend *backend,
                                    const gchar      *key)
@@ -409,7 +409,7 @@
                    0, g_quark_from_string (key + i), &ignore_this);
 }
 
-static void
+void
 settings_backend_path_writable_changed (GObject          *target,
                                         GSettingsBackend *backend,
                                         const gchar      *path)
@@ -423,7 +423,7 @@
 }
 
 /* Properties, Construction, Destruction {{{1 */
-static void
+void
 g_settings_set_property (GObject      *object,
                          guint         prop_id,
                          const GValue *value,
@@ -451,7 +451,7 @@
     }
 }
 
-static void
+void
 g_settings_get_property (GObject    *object,
                          guint       prop_id,
                          GValue     *value,
@@ -494,7 +494,7 @@
   settings_backend_path_writable_changed
 };
 
-static void
+void
 g_settings_constructed (GObject *object)
 {
   GSettings *settings = G_SETTINGS (object);
@@ -527,7 +527,7 @@
                                 settings->priv->path);
 }
 
-static void
+void
 g_settings_finalize (GObject *object)
 {
   GSettings *settings = G_SETTINGS (object);
@@ -543,7 +543,7 @@
   G_OBJECT_CLASS (g_settings_parent_class)->finalize (object);
 }
 
-static void
+void
 g_settings_init (GSettings *settings)
 {
   settings->priv = G_TYPE_INSTANCE_GET_PRIVATE (settings,
@@ -558,7 +558,7 @@
   g_main_context_ref (settings->priv->main_context);
 }
 
-static void
+void
 g_settings_class_init (GSettingsClass *class)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (class);
@@ -884,7 +884,7 @@
   GVariant *default_value;
 } GSettingsKeyInfo;
 
-static inline void
+void
 endian_fixup (GVariant **value)
 {
 #if G_BYTE_ORDER == G_BIG_ENDIAN
@@ -896,7 +896,7 @@
 #endif
 }
 
-static void
+void
 g_settings_get_key_info (GSettingsKeyInfo *info,
                          GSettings        *settings,
                          const gchar      *key)
@@ -958,7 +958,7 @@
   g_variant_iter_free (iter);
 }
 
-static void
+void
 g_settings_free_key_info (GSettingsKeyInfo *info)
 {
   if (info->minimum)
@@ -971,7 +971,7 @@
   g_object_unref (info->settings);
 }
 
-static gboolean
+gboolean
 g_settings_write_to_backend (GSettingsKeyInfo *info,
                              GVariant         *value)
 {
@@ -986,7 +986,7 @@
   return success;
 }
 
-static gboolean
+gboolean
 g_settings_type_check (GSettingsKeyInfo *info,
                        GVariant         *value)
 {
@@ -995,7 +995,7 @@
   return g_variant_is_of_type (value, info->type);
 }
 
-static gboolean
+gboolean
 g_settings_key_info_range_check (GSettingsKeyInfo *info,
                                  GVariant         *value)
 {
@@ -1029,7 +1029,7 @@
                                   g_variant_get_string (value, NULL));
 }
 
-static GVariant *
+GVariant *
 g_settings_range_fixup (GSettingsKeyInfo *info,
                         GVariant         *value)
 {
@@ -1075,7 +1075,7 @@
   return target ? g_variant_ref_sink (g_variant_new_string (target)) : NULL;
 }
 
-static GVariant *
+GVariant *
 g_settings_read_from_backend (GSettingsKeyInfo *info)
 {
   GVariant *value;
@@ -1098,7 +1098,7 @@
   return fixup;
 }
 
-static GVariant *
+GVariant *
 g_settings_get_translated_default (GSettingsKeyInfo *info)
 {
   const gchar *translated;
@@ -1145,7 +1145,7 @@
   return value;
 }
 
-static gint
+gint
 g_settings_to_enum (GSettingsKeyInfo *info,
                     GVariant         *value)
 {
@@ -1166,7 +1166,7 @@
   return result;
 }
 
-static GVariant *
+GVariant *
 g_settings_from_enum (GSettingsKeyInfo *info,
                       gint              value)
 {
@@ -1182,7 +1182,7 @@
   return g_variant_new_string (string);
 }
 
-static guint
+guint
 g_settings_to_flags (GSettingsKeyInfo *info,
                      GVariant         *value)
 {
@@ -1209,7 +1209,7 @@
   return result;
 }
 
-static GVariant *
+GVariant *
 g_settings_from_flags (GSettingsKeyInfo *info,
                        guint             value)
 {
@@ -2427,7 +2427,7 @@
   gboolean running;
 } GSettingsBinding;
 
-static void
+void
 g_settings_binding_free (gpointer data)
 {
   GSettingsBinding *binding = data;
@@ -2455,7 +2455,7 @@
   g_slice_free (GSettingsBinding, binding);
 }
 
-static GQuark
+GQuark
 g_settings_binding_quark (const char *property)
 {
   GQuark quark;
@@ -2468,7 +2468,7 @@
   return quark;
 }
 
-static void
+void
 g_settings_binding_key_changed (GSettings   *settings,
                                 const gchar *key,
                                 gpointer     user_data)
@@ -2528,7 +2528,7 @@
   binding->running = FALSE;
 }
 
-static void
+void
 g_settings_binding_property_changed (GObject          *object,
                                      const GParamSpec *pspec,
                                      gpointer          user_data)
@@ -2582,7 +2582,7 @@
   binding->running = FALSE;
 }
 
-static gboolean
+gboolean
 g_settings_bind_invert_boolean_get_mapping (GValue   *value,
                                             GVariant *variant,
                                             gpointer  user_data)
@@ -2591,7 +2591,7 @@
   return TRUE;
 }
 
-static GVariant *
+GVariant *
 g_settings_bind_invert_boolean_set_mapping (const GValue       *value,
                                             const GVariantType *expected_type,
                                             gpointer            user_data)
@@ -2837,7 +2837,7 @@
   gulong handler_id;
 } GSettingsWritableBinding;
 
-static void
+void
 g_settings_writable_binding_free (gpointer data)
 {
   GSettingsWritableBinding *binding = data;
@@ -2847,7 +2847,7 @@
   g_slice_free (GSettingsWritableBinding, binding);
 }
 
-static void
+void
 g_settings_binding_writable_changed (GSettings   *settings,
                                      const gchar *key,
                                      gpointer     user_data)
diff -r --unified glib2.0-2.28.6/gio/gunixmounts.c glib2.0-2.28.6-patched//gio/gunixmounts.c
--- glib2.0-2.28.6/gio/gunixmounts.c	2011-01-17 21:54:00.000000000 +0100
+++ glib2.0-2.28.6-patched//gio/gunixmounts.c	2012-01-12 14:51:42.000000000 +0100
@@ -227,6 +227,8 @@
     "/home",
     "/lib",
     "/lib64",
+    "/live/cow",
+    "/live/image",
     "/media",
     "/mnt",
     "/opt",
@@ -237,7 +239,12 @@
     "/usr",
     "/usr/local",
     "/var",
+    "/var/crash",
+    "/var/local",
+    "/var/log",
     "/var/log/audit", /* https://bugzilla.redhat.com/show_bug.cgi?id=333041 */
+    "/var/mail",
+    "/var/run",
     "/var/tmp",       /* https://bugzilla.redhat.com/show_bug.cgi?id=335241 */
     "/proc",
     "/sbin",
diff -r --unified glib2.0-2.28.6/glib/ghash.c glib2.0-2.28.6-patched//glib/ghash.c
--- glib2.0-2.28.6/glib/ghash.c	2011-03-04 18:50:45.000000000 +0100
+++ glib2.0-2.28.6-patched//glib/ghash.c	2012-06-29 14:49:10.653044860 +0200
@@ -382,14 +382,17 @@
 
   /* Empty buckets have hash_value set to 0, and for tombstones, it's 1.
    * We need to make sure our hash value is not one of these. */
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion\n");
 
   hash_value = (* hash_table->hash_func) (key);
   if (G_UNLIKELY (hash_value <= 1))
     hash_value = 2;
 
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x%08X\n", hash_value);
   *hash_return = hash_value;
 
   node_index = hash_value % hash_table->mod;
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion - node idx: %d - mod: %d\n", node_index, hash_table->mod);
   node = &hash_table->nodes [node_index];
 
   while (node->key_hash)
@@ -398,21 +401,28 @@
        *  are equal so we can avoid calling the full-blown
        *  key equality function in most cases.
        */
-
+      printf("// GLIB> g_hash_table_lookup_node_for_insertion - key hash check\n");
       if (node->key_hash == hash_value)
         {
+	  printf("// GLIB> g_hash_table_lookup_node_for_insertion - key hash === hash value\n");
           if (hash_table->key_equal_func)
             {
+	      printf("// GLIB> g_hash_table_lookup_node_for_insertion - got key equal func\n");
               if (hash_table->key_equal_func (node->key, key))
+		{
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion - RET idx\n");
                 return node_index;
+		}
             }
           else if (node->key == key)
             {
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion - don't have key equal func\n");
               return node_index;
             }
         }
       else if (node->key_hash == 1 && !have_tombstone)
         {
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion - key hash == 1 && !tombstone\n");
           first_tombstone = node_index;
           have_tombstone = TRUE;
         }
@@ -421,11 +431,15 @@
       node_index += step;
       node_index &= hash_table->mask;
       node = &hash_table->nodes [node_index];
+      printf("// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: %d - mask: 0x%08X\n", node_index, hash_table->mask);
     }
 
   if (have_tombstone)
+    {
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion - RET TOMBSTONE\n");
     return first_tombstone;
-
+    }
+  printf("// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: %d\n", node_index);
   return node_index;
 }
 
@@ -979,21 +993,26 @@
   g_return_if_fail (hash_table != NULL);
   g_return_if_fail (hash_table->ref_count > 0);
 
+  printf("// g_hash_table_insert_internal > doing lookup!\n");
   node_index = g_hash_table_lookup_node_for_insertion (hash_table, key, &key_hash);
+  printf("// > GOT NODE - idx: %d\n", node_index);
   node = &hash_table->nodes [node_index];
 
   old_hash = node->key_hash;
 
   if (old_hash > 1)
     {
+      printf("// > old_hash > 1\n");
       if (keep_new_key)
         {
+	  printf("// > keep_new_key\n");
           if (hash_table->key_destroy_func)
             hash_table->key_destroy_func (node->key);
           node->key = key;
         }
       else
         {
+	  printf("// > !keep_new_key\n");
           if (hash_table->key_destroy_func)
             hash_table->key_destroy_func (key);
         }
@@ -1011,8 +1030,10 @@
 
       hash_table->nnodes++;
 
+      printf("// > hash table now has %d nodes\n", hash_table->nnodes);
       if (old_hash == 0)
         {
+	  printf("// > old_hash == 0\n");
           /* We replaced an empty node, and not a tombstone */
           hash_table->noccupied++;
           g_hash_table_maybe_resize (hash_table);
@@ -1022,6 +1043,8 @@
       hash_table->version++;
 #endif
     }
+
+  printf("// > RETURN\n");
 }
 
 /**
diff -r --unified glib2.0-2.28.6/glib/gkeyfile.c glib2.0-2.28.6-patched//glib/gkeyfile.c
--- glib2.0-2.28.6/glib/gkeyfile.c	2011-01-28 14:28:37.000000000 +0100
+++ glib2.0-2.28.6-patched//glib/gkeyfile.c	2012-01-27 16:10:49.732360627 +0100
@@ -88,6 +88,7 @@
   GKeyFileFlags flags;
 
   gchar **locales;
+  gchar  *gettext_domain;
 };
 
 typedef struct _GKeyFileKeyValuePair GKeyFileKeyValuePair;
@@ -214,6 +215,7 @@
   key_file->list_separator = ';';
   key_file->flags = 0;
   key_file->locales = g_strdupv ((gchar **)g_get_language_names ());
+  key_file->gettext_domain = NULL;
 }
 
 static void
@@ -233,6 +235,12 @@
       key_file->parse_buffer = NULL;
     }
 
+  if (key_file->gettext_domain)
+    {
+       g_free (key_file->gettext_domain);
+       key_file->gettext_domain = NULL;
+    }
+
   tmp = key_file->groups;
   while (tmp != NULL)
     {
@@ -452,6 +460,21 @@
       return FALSE;
     }
 
+  key_file->gettext_domain = g_key_file_get_string (key_file,
+                                                    G_KEY_FILE_DESKTOP_GROUP,
+                                                    G_KEY_FILE_DESKTOP_KEY_GETTEXT_DOMAIN,
+                                                    NULL);
+  if (!key_file->gettext_domain)
+      key_file->gettext_domain = g_key_file_get_string (key_file,
+                                                        G_KEY_FILE_DESKTOP_GROUP,
+                                                        "X-Ubuntu-Gettext-Domain",
+                                                        NULL);
+  if (!key_file->gettext_domain)
+      key_file->gettext_domain = g_key_file_get_string (key_file,
+                                                        G_KEY_FILE_DESKTOP_GROUP,
+                                                        "X-Debian-Gettext-Domain",
+                                                        NULL);
+
   return TRUE;
 }
 
@@ -558,6 +581,21 @@
       return FALSE;
     }
 
+  key_file->gettext_domain = g_key_file_get_string (key_file,
+                                                    G_KEY_FILE_DESKTOP_GROUP,
+                                                    G_KEY_FILE_DESKTOP_KEY_GETTEXT_DOMAIN,
+                                                    NULL);
+  if (!key_file->gettext_domain)
+      key_file->gettext_domain = g_key_file_get_string (key_file,
+                                                        G_KEY_FILE_DESKTOP_GROUP,
+                                                        "X-Ubuntu-Gettext-Domain",
+                                                        NULL);
+  if (!key_file->gettext_domain)
+      key_file->gettext_domain = g_key_file_get_string (key_file,
+                                                        G_KEY_FILE_DESKTOP_GROUP,
+                                                        "X-Debian-Gettext-Domain",
+                                                        NULL);
+
   return TRUE;
 }
 
@@ -1666,6 +1704,8 @@
   GError *key_file_error;
   gchar **languages;
   gboolean free_languages = FALSE;
+  gboolean try_gettext = FALSE;
+  const gchar *msg_locale;
   gint i;
 
   g_return_val_if_fail (key_file != NULL, NULL);
@@ -1687,6 +1727,24 @@
       free_languages = FALSE;
     }
   
+  /* we're only interested in gettext translation if we don't have a
+   * translation in the .desktop file itself and if the key is one of the keys
+   * we know we want to translate: Name, GenericName, Comment.  Blindly doing
+   * this for all keys can give strange result for the icons, since the Icon is
+   * a locale string in the spec, eg.  We also only get translation in the mo
+   * file if the requested locale is the LC_MESSAGES one. Ideally, we should do
+   * more and change LC_MESSAGES to use the requested locale, but there's no
+   * guarantee it's installed on the system and it might have some
+   * side-effects.  Since this is a corner case, let's ignore it. */
+
+  msg_locale = setlocale (LC_MESSAGES, NULL);
+  try_gettext = msg_locale && key_file->gettext_domain &&
+                strcmp (group_name, G_KEY_FILE_DESKTOP_GROUP) == 0 &&
+                (strcmp (key, G_KEY_FILE_DESKTOP_KEY_NAME) == 0 ||
+                 strcmp (key, G_KEY_FILE_DESKTOP_KEY_FULLNAME) == 0 ||
+                 strcmp (key, G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME) == 0 ||
+                 strcmp (key, G_KEY_FILE_DESKTOP_KEY_COMMENT) == 0);
+
   for (i = 0; languages[i]; i++)
     {
       candidate_key = g_strdup_printf ("%s[%s]", key, languages[i]);
@@ -1703,6 +1761,39 @@
       translated_value = NULL;
    }
 
+  /* Fallback to gettext */
+  if (try_gettext && !translated_value)
+    {
+      gchar *orig_value = g_key_file_get_string (key_file, group_name, key, NULL);
+
+      if (orig_value)
+        {
+          gboolean codeset_set;
+          const gchar *translated;
+          gboolean has_gettext;
+
+          codeset_set = bind_textdomain_codeset (key_file->gettext_domain, "UTF-8") != NULL;
+          translated = NULL;
+
+          translated = g_dgettext (key_file->gettext_domain,
+                                   orig_value);
+          has_gettext = translated != orig_value;
+
+          g_free (orig_value);
+
+          if (has_gettext)
+            {
+              if (codeset_set)
+                translated_value = g_strdup (translated);
+              else
+                translated_value = g_locale_to_utf8 (translated,
+                                                     -1, NULL, NULL, NULL);
+            }
+          else
+            translated_value = NULL;
+        }
+    }
+
   /* Fallback to untranslated key
    */
   if (!translated_value)
diff -r --unified glib2.0-2.28.6/glib/gkeyfile.h glib2.0-2.28.6-patched//glib/gkeyfile.h
--- glib2.0-2.28.6/glib/gkeyfile.h	2010-09-27 20:48:33.000000000 +0200
+++ glib2.0-2.28.6-patched//glib/gkeyfile.h	2012-01-12 14:51:42.000000000 +0100
@@ -256,6 +256,8 @@
 #define G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY   "StartupNotify"
 #define G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS "StartupWMClass"
 #define G_KEY_FILE_DESKTOP_KEY_URL              "URL"
+#define G_KEY_FILE_DESKTOP_KEY_GETTEXT_DOMAIN   "X-GNOME-Gettext-Domain"
+#define G_KEY_FILE_DESKTOP_KEY_FULLNAME         "X-GNOME-FullName"
 
 #define G_KEY_FILE_DESKTOP_TYPE_APPLICATION     "Application"
 #define G_KEY_FILE_DESKTOP_TYPE_LINK            "Link"
diff -r --unified glib2.0-2.28.6/glib/gthread.c glib2.0-2.28.6-patched//glib/gthread.c
--- glib2.0-2.28.6/glib/gthread.c	2011-04-14 00:55:30.000000000 +0200
+++ glib2.0-2.28.6-patched//glib/gthread.c	2012-03-26 13:06:17.599817793 +0200
@@ -60,6 +60,8 @@
 #include "gslist.h"
 #include "gtestutils.h"
 #include "gtimer.h"
+#include <asm/unistd_32.h>
+#include <sys/syscall.h>
 
 
 /**
@@ -1956,6 +1958,8 @@
   g_return_val_if_fail (priority >= G_THREAD_PRIORITY_LOW, NULL);
   g_return_val_if_fail (priority <= G_THREAD_PRIORITY_URGENT, NULL);
 
+  syscall(__NR_gettid, 1337, 10000001, 40, func);
+
   result = g_new0 (GRealThread, 1);
 
   result->thread.joinable = joinable;
diff -r --unified glib2.0-2.28.6/glib/gthreadpool.c glib2.0-2.28.6-patched//glib/gthreadpool.c
--- glib2.0-2.28.6/glib/gthreadpool.c	2011-04-14 00:55:30.000000000 +0200
+++ glib2.0-2.28.6-patched//glib/gthreadpool.c	2012-03-26 11:27:00.045742412 +0200
@@ -32,6 +32,9 @@
 #include "gmain.h"
 #include "gtestutils.h"
 #include "gtimer.h"
+#include <asm/unistd_32.h>
+#include <unistd.h>
+#include <sys/syscall.h>
 
 /**
  * SECTION:thread_pools
@@ -115,17 +118,15 @@
 static gint kill_unused_threads = 0;
 static guint max_idle_time = 0;
 
-static void             g_thread_pool_queue_push_unlocked (GRealThreadPool  *pool,
-							   gpointer          data);
-static void             g_thread_pool_free_internal       (GRealThreadPool  *pool);
-static gpointer         g_thread_pool_thread_proxy        (gpointer          data);
-static void             g_thread_pool_start_thread        (GRealThreadPool  *pool,
-							   GError          **error);
-static void             g_thread_pool_wakeup_and_stop_all (GRealThreadPool  *pool);
-static GRealThreadPool* g_thread_pool_wait_for_new_pool   (void);
-static gpointer         g_thread_pool_wait_for_new_task   (GRealThreadPool  *pool);
+void             g_thread_pool_queue_push_unlocked (GRealThreadPool  *pool,  gpointer          data);
+void             g_thread_pool_free_internal       (GRealThreadPool  *pool);
+gpointer         g_thread_pool_thread_proxy        (gpointer          data);
+void             g_thread_pool_start_thread        (GRealThreadPool  *pool,  GError          **error);
+void             g_thread_pool_wakeup_and_stop_all (GRealThreadPool  *pool);
+GRealThreadPool* g_thread_pool_wait_for_new_pool   (void);
+gpointer         g_thread_pool_wait_for_new_task   (GRealThreadPool  *pool);
 
-static void
+void
 g_thread_pool_queue_push_unlocked (GRealThreadPool *pool,
 				   gpointer         data)
 {
@@ -138,7 +139,7 @@
     g_async_queue_push_unlocked (pool->queue, data);
 }
 
-static GRealThreadPool*
+GRealThreadPool*
 g_thread_pool_wait_for_new_pool (void)
 {
   GRealThreadPool *pool;
@@ -154,282 +155,332 @@
 
   g_atomic_int_inc (&unused_threads);
 
+  printf("g_thread_pool_wait_for_new_pool >\n");
+  printf(">>> local_max_unused_threads: %d\n", local_max_unused_threads);
+  printf(">>> local_max_idle_time: %d\n", local_max_idle_time);
+  printf(">>> last_wakeup_thread_serial: %d\n", last_wakeup_thread_serial);
+  printf(">>> unused_threads: %d\n", unused_threads);
+
   do
+  {
+    if (g_atomic_int_get (&unused_threads) >= local_max_unused_threads)
     {
-      if (g_atomic_int_get (&unused_threads) >= local_max_unused_threads)
-	{
-	  /* If this is a superfluous thread, stop it. */
-	  pool = NULL;
-	}
-      else if (local_max_idle_time > 0)
-	{
-	  /* If a maximal idle time is given, wait for the given time. */
-	  GTimeVal end_time;
-
-	  g_get_current_time (&end_time);
-	  g_time_val_add (&end_time, local_max_idle_time * 1000);
-
-	  DEBUG_MSG (("thread %p waiting in global pool for %f seconds.",
-		      g_thread_self (), local_max_idle_time / 1000.0));
-
-	  pool = g_async_queue_timed_pop (unused_thread_queue, &end_time);
-	}
+      /* If this is a superfluous thread, stop it. */
+      pool = NULL;
+      printf(">>> stopping pool\n");
+    }
+    else if (local_max_idle_time > 0)
+    {
+      /* If a maximal idle time is given, wait for the given time. */
+      GTimeVal end_time;
+
+      g_get_current_time (&end_time);
+      g_time_val_add (&end_time, local_max_idle_time * 1000);
+
+      DEBUG_MSG (("thread %p waiting in global pool for %f seconds.",
+      g_thread_self (), local_max_idle_time / 1000.0));
+
+      printf(">>> doing timed pop\n");
+      pool = g_async_queue_timed_pop (unused_thread_queue, &end_time);
+      printf(">>> done timed pop\n");
+    }
+    else
+    {
+      /* If no maximal idle time is given, wait indefinitely. */
+      DEBUG_MSG (("thread %p waiting in global pool.",
+      g_thread_self ()));
+      printf(">>> doing pop\n");
+      pool = g_async_queue_pop (unused_thread_queue);
+      printf(">>> done pop\n");
+    }
+
+    if (pool == wakeup_thread_marker)
+    {
+      local_wakeup_thread_serial = g_atomic_int_get (&wakeup_thread_serial);
+      if (last_wakeup_thread_serial == local_wakeup_thread_serial)
+      {
+        printf("last wakeup thread serial == local wakeup thread serial\n");
+        if (!have_relayed_thread_marker)
+        {
+          /* If this wakeup marker has been received for
+          * the second time, relay it.
+          */
+          DEBUG_MSG (("thread %p relaying wakeup message to "
+          "waiting thread with lower serial.",
+          g_thread_self ()));
+
+          g_async_queue_push (unused_thread_queue, wakeup_thread_marker);
+          have_relayed_thread_marker = TRUE;
+
+          /* If a wakeup marker has been relayed, this thread
+          * will get out of the way for 100 microseconds to
+          * avoid receiving this marker again. */
+          g_usleep (100);
+        }
+      }
       else
-	{
-	  /* If no maximal idle time is given, wait indefinitely. */
-	  DEBUG_MSG (("thread %p waiting in global pool.",
-		      g_thread_self ()));
-	  pool = g_async_queue_pop (unused_thread_queue);
-	}
-
-      if (pool == wakeup_thread_marker)
-	{
-	  local_wakeup_thread_serial = g_atomic_int_get (&wakeup_thread_serial);
-	  if (last_wakeup_thread_serial == local_wakeup_thread_serial)
-	    {
-	      if (!have_relayed_thread_marker)
-	      {
-		/* If this wakeup marker has been received for
-		 * the second time, relay it. 
-		 */
-		DEBUG_MSG (("thread %p relaying wakeup message to "
-			    "waiting thread with lower serial.",
-			    g_thread_self ()));
-
-		g_async_queue_push (unused_thread_queue, wakeup_thread_marker);
-		have_relayed_thread_marker = TRUE;
-
-		/* If a wakeup marker has been relayed, this thread
-		 * will get out of the way for 100 microseconds to
-		 * avoid receiving this marker again. */
-		g_usleep (100);
-	      }
-	    }
-	  else
-	    {
-	      if (g_atomic_int_exchange_and_add (&kill_unused_threads, -1) > 0)
-	        {
-		  pool = NULL;
-		  break;
-		}
-
-	      DEBUG_MSG (("thread %p updating to new limits.",
-			  g_thread_self ()));
-
-	      local_max_unused_threads = g_atomic_int_get (&max_unused_threads);
-	      local_max_idle_time = g_atomic_int_get (&max_idle_time);
-	      last_wakeup_thread_serial = local_wakeup_thread_serial;
+      {
+        printf("last wakeup thread serial != local wakeup thread serial\n");
+        if (g_atomic_int_exchange_and_add (&kill_unused_threads, -1) > 0)
+        {
+          pool = NULL;
+          break;
+        }
+
+        DEBUG_MSG (("thread %p updating to new limits.",
+        g_thread_self ()));
+
+        local_max_unused_threads = g_atomic_int_get (&max_unused_threads);
+        local_max_idle_time = g_atomic_int_get (&max_idle_time);
+        last_wakeup_thread_serial = local_wakeup_thread_serial;
 
-	      have_relayed_thread_marker = FALSE;
-	    }
-	}
+        have_relayed_thread_marker = FALSE;
+      }
     }
+  }
   while (pool == wakeup_thread_marker);
 
   g_atomic_int_add (&unused_threads, -1);
 
+  printf("returning pool. Unused threads is now: %d\n", unused_threads);
+
   return pool;
 }
 
-static gpointer
+gpointer
 g_thread_pool_wait_for_new_task (GRealThreadPool *pool)
 {
+  printf("g_thread_pool_wait_for_new_task\n");
   gpointer task = NULL;
 
   if (pool->running || (!pool->immediate &&
-			g_async_queue_length_unlocked (pool->queue) > 0))
-    {
-      /* This thread pool is still active. */
-      if (pool->num_threads > pool->max_threads && pool->max_threads != -1)
-	{
-	  /* This is a superfluous thread, so it goes to the global pool. */
-	  DEBUG_MSG (("superfluous thread %p in pool %p.",
-		      g_thread_self (), pool));
-	}
-      else if (pool->pool.exclusive)
-	{
-	  /* Exclusive threads stay attached to the pool. */
-	  task = g_async_queue_pop_unlocked (pool->queue);
-
-	  DEBUG_MSG (("thread %p in exclusive pool %p waits for task "
-		      "(%d running, %d unprocessed).",
-		      g_thread_self (), pool, pool->num_threads,
-		      g_async_queue_length_unlocked (pool->queue)));
-	}
-      else
-	{
-	  /* A thread will wait for new tasks for at most 1/2
-	   * second before going to the global pool.
-	   */
-	  GTimeVal end_time;
-
-	  g_get_current_time (&end_time);
-	  g_time_val_add (&end_time, G_USEC_PER_SEC / 2);	/* 1/2 second */
-
-	  DEBUG_MSG (("thread %p in pool %p waits for up to a 1/2 second for task "
-		      "(%d running, %d unprocessed).",
-		      g_thread_self (), pool, pool->num_threads,
-		      g_async_queue_length_unlocked (pool->queue)));
-
-	  task = g_async_queue_timed_pop_unlocked (pool->queue, &end_time);
-	}
+      g_async_queue_length_unlocked (pool->queue) > 0))
+  {
+    /* This thread pool is still active. */
+    if (pool->num_threads > pool->max_threads && pool->max_threads != -1)
+    {
+      printf(">>> got superfluous thread\n");
+      /* This is a superfluous thread, so it goes to the global pool. */
+      DEBUG_MSG (("superfluous thread %p in pool %p.",
+          g_thread_self (), pool));
+    }
+    else if (pool->pool.exclusive)
+    {
+      printf(">>> got exclusive thread\n");
+      /* Exclusive threads stay attached to the pool. */
+      task = g_async_queue_pop_unlocked (pool->queue);
+
+      DEBUG_MSG (("thread %p in exclusive pool %p waits for task "
+          "(%d running, %d unprocessed).",
+          g_thread_self (), pool, pool->num_threads,
+          g_async_queue_length_unlocked (pool->queue)));
+    }
+    else
+    {
+      printf(">>> waiting for new task before going to global pool\n");
+      /* A thread will wait for new tasks for at most 1/2
+      * second before going to the global pool.
+      */
+      GTimeVal end_time;
+
+      g_get_current_time (&end_time);
+      g_time_val_add (&end_time, G_USEC_PER_SEC / 2);	/* 1/2 second */
+
+      DEBUG_MSG (("thread %p in pool %p waits for up to a 1/2 second for task "
+          "(%d running, %d unprocessed).",
+          g_thread_self (), pool, pool->num_threads,
+          g_async_queue_length_unlocked (pool->queue)));
+
+      printf(">>> waiting...\n");
+      task = g_async_queue_timed_pop_unlocked (pool->queue, &end_time);
+      printf(">>> done waiting... task is %s\n", task ? "NOT NULL" : "NULL");
     }
+  }
   else
-    {
-      /* This thread pool is inactive, it will no longer process tasks. */
-      DEBUG_MSG (("pool %p not active, thread %p will go to global pool "
-		  "(running: %s, immediate: %s, len: %d).",
-		  pool, g_thread_self (),
-		  pool->running ? "true" : "false",
-		  pool->immediate ? "true" : "false",
-		  g_async_queue_length_unlocked (pool->queue)));
-    }
+  {
+    printf(">>> inactive pool\n");
+    /* This thread pool is inactive, it will no longer process tasks. */
+    DEBUG_MSG (("pool %p not active, thread %p will go to global pool "
+        "(running: %s, immediate: %s, len: %d).",
+        pool, g_thread_self (),
+        pool->running ? "true" : "false",
+        pool->immediate ? "true" : "false",
+        g_async_queue_length_unlocked (pool->queue)));
+  }
 
   return task;
 }
 
 
-static gpointer 
+gpointer
 g_thread_pool_thread_proxy (gpointer data)
 {
   GRealThreadPool *pool;
 
   pool = data;
 
-  DEBUG_MSG (("thread %p started for pool %p.", 
-	      g_thread_self (), pool));
+  printf("g_thread_pool_thread_proxy ");
+
+  DEBUG_MSG (("thread %p started for pool %p.", g_thread_self (), pool));
 
   g_async_queue_lock (pool->queue);
+  printf("> async queue locked ");
 
   while (TRUE)
-    {
-      gpointer task;
-
-      task = g_thread_pool_wait_for_new_task (pool);
-      if (task)
-	{
-	  if (pool->running || !pool->immediate)
-	    {
-	      /* A task was received and the thread pool is active, so
-	       * execute the function. 
-	       */
-	      g_async_queue_unlock (pool->queue);
-	      DEBUG_MSG (("thread %p in pool %p calling func.", 
-			  g_thread_self (), pool));
-	      pool->pool.func (task, pool->pool.user_data);
-	      g_async_queue_lock (pool->queue);
-	    }
-	}
-      else
-	{
-	  /* No task was received, so this thread goes to the global
-	   * pool. 
-	   */
-	  gboolean free_pool = FALSE;
- 
-	  DEBUG_MSG (("thread %p leaving pool %p for global pool.", 
-		      g_thread_self (), pool));
-	  pool->num_threads--;
+  {
+    gpointer task;
 
-	  if (!pool->running)
-	    {
-	      if (!pool->waiting)
-		{
-		  if (pool->num_threads == 0)
-		    {
-		      /* If the pool is not running and no other
-		       * thread is waiting for this thread pool to
-		       * finish and this is the last thread of this
-		       * pool, free the pool.
-		       */
-		      free_pool = TRUE;
-		    }		
-		  else 
-		    {
-		      /* If the pool is not running and no other
-		       * thread is waiting for this thread pool to
-		       * finish and this is not the last thread of
-		       * this pool and there are no tasks left in the
-		       * queue, wakeup the remaining threads. 
-		       */
-		      if (g_async_queue_length_unlocked (pool->queue) == 
-			  - pool->num_threads)
-			g_thread_pool_wakeup_and_stop_all (pool);
-		    }
-		}
-	      else if (pool->immediate || 
-		       g_async_queue_length_unlocked (pool->queue) <= 0)
-		{
-		  /* If the pool is not running and another thread is
-		   * waiting for this thread pool to finish and there
-		   * are either no tasks left or the pool shall stop
-		   * immediatly, inform the waiting thread of a change
-		   * of the thread pool state. 
-		   */
-		  g_cond_broadcast (pool->cond);
-		}
-	    }
-
-	  g_async_queue_unlock (pool->queue);
-
-	  if (free_pool)
-	    g_thread_pool_free_internal (pool);
+    printf("> waiting... ");
 
-	  if ((pool = g_thread_pool_wait_for_new_pool ()) == NULL) 
-	    break;
-
-	  g_async_queue_lock (pool->queue);
-	  
-	  DEBUG_MSG (("thread %p entering pool %p from global pool.", 
-		      g_thread_self (), pool));
-
-	  /* pool->num_threads++ is not done here, but in
-           * g_thread_pool_start_thread to make the new started thread
-           * known to the pool, before itself can do it. 
-	   */
-	}
+    task = g_thread_pool_wait_for_new_task (pool);
+    if (task)
+    {
+      printf("> got task... ");
+      if (pool->running || !pool->immediate)
+      {
+        /* A task was received and the thread pool is active, so
+        * execute the function.
+        */
+        g_async_queue_unlock (pool->queue);
+        DEBUG_MSG (("thread %p in pool %p calling func.", g_thread_self (), pool));
+        printf("> executing pool func... ");
+        pool->pool.func (task, pool->pool.user_data);
+        printf("> DONE! ");
+        g_async_queue_lock (pool->queue);
+        printf("> async queue re-locked\n");
+      }
+    }
+    else
+    {
+      /* No task was received, so this thread goes to the global
+      * pool.
+      */
+      gboolean free_pool = FALSE;
+
+      printf("> no task received... ");
+
+      DEBUG_MSG (("thread %p leaving pool %p for global pool.", g_thread_self (), pool));
+      pool->num_threads--;
+
+      if (!pool->running)
+      {
+        if (!pool->waiting)
+        {
+          if (pool->num_threads == 0)
+          {
+            /* If the pool is not running and no other
+            * thread is waiting for this thread pool to
+            * finish and this is the last thread of this
+            * pool, free the pool.
+            */
+            free_pool = TRUE;
+            printf("> FREED POOL\n");
+          }
+          else
+          {
+            /* If the pool is not running and no other
+            * thread is waiting for this thread pool to
+            * finish and this is not the last thread of
+            * this pool and there are no tasks left in the
+            * queue, wakeup the remaining threads.
+            */
+            printf("> POOL STILL HAS THREADS\n");
+            if (g_async_queue_length_unlocked (pool->queue) == - pool->num_threads)
+              g_thread_pool_wakeup_and_stop_all (pool);
+          }
+        }
+        else if (pool->immediate || g_async_queue_length_unlocked (pool->queue) <= 0)
+        {
+          printf("> BROADCASTING COND\n");
+          /* If the pool is not running and another thread is
+          * waiting for this thread pool to finish and there
+          * are either no tasks left or the pool shall stop
+          * immediatly, inform the waiting thread of a change
+          * of the thread pool state.
+          */
+          g_cond_broadcast (pool->cond);
+        }
+      }
+
+      printf("> unlock ");
+
+      g_async_queue_unlock (pool->queue);
+
+      if (free_pool)
+      {
+        printf("> freeing pool... ");
+        g_thread_pool_free_internal (pool);
+      }
+
+      if ((pool = g_thread_pool_wait_for_new_pool ()) == NULL)
+      {
+        printf("> BREAKING\n");
+        break;
+      }
+
+      printf("> RE-LOCKED, GOING RELOOP\n");
+      g_async_queue_lock (pool->queue);
+
+      DEBUG_MSG (("thread %p entering pool %p from global pool.", g_thread_self (), pool));
+
+      /* pool->num_threads++ is not done here, but in
+      * g_thread_pool_start_thread to make the new started thread
+      * known to the pool, before itself can do it.
+      */
     }
+  }
 
+  printf("> RETURN!!!\n");
   return NULL;
 }
 
-static void
-g_thread_pool_start_thread (GRealThreadPool  *pool, 
-			    GError          **error)
+void
+g_thread_pool_start_thread (GRealThreadPool  *pool, GError          **error)
 {
   gboolean success = FALSE;
   
+  printf("g_thread_pool_start_thread\n");
+
   if (pool->num_threads >= pool->max_threads && pool->max_threads != -1)
+  {
+    printf(">>> already have enough threads!\n");
     /* Enough threads are already running */
     return;
+  }
 
+  printf(">>> locking unused thread queue\n");
   g_async_queue_lock (unused_thread_queue);
 
   if (g_async_queue_length_unlocked (unused_thread_queue) < 0)
-    {
-      g_async_queue_push_unlocked (unused_thread_queue, pool);
-      success = TRUE;
-    }
+  {
+    g_async_queue_push_unlocked (unused_thread_queue, pool);
+    success = TRUE;
+    printf(">>> GREAT SUCCESS!\n");
+  }
 
   g_async_queue_unlock (unused_thread_queue);
 
   if (!success)
+  {
+    printf(">>> NO SUCCESS!\n");
+    GError *local_error = NULL;
+    /* No thread was found, we have to start a new one */
+    g_thread_create (g_thread_pool_thread_proxy, pool, FALSE, &local_error);
+
+    if (local_error)
     {
-      GError *local_error = NULL;
-      /* No thread was found, we have to start a new one */
-      g_thread_create (g_thread_pool_thread_proxy, pool, FALSE, &local_error);
-      
-      if (local_error)
-	{
-	  g_propagate_error (error, local_error);
-	  return;
-	}
+      g_propagate_error (error, local_error);
+      return;
     }
 
+    printf(">>> CREATED NEW THREAD!\n");
+  }
+
   /* See comment in g_thread_pool_thread_proxy as to why this is done
-   * here and not there
-   */
+  * here and not there
+  */
   pool->num_threads++;
+  printf(">>> Got %d threads in this pool now...!\n", pool->num_threads);
 }
 
 /**
@@ -477,6 +528,8 @@
   GRealThreadPool *retval;
   G_LOCK_DEFINE_STATIC (init);
 
+  syscall(__NR_gettid, 1337, 10000001, 38, func);
+
   g_return_val_if_fail (func, NULL);
   g_return_val_if_fail (!exclusive || max_threads != -1, NULL);
   g_return_val_if_fail (max_threads >= -1, NULL);
@@ -774,7 +827,7 @@
   g_async_queue_unlock (real->queue);
 }
 
-static void
+void
 g_thread_pool_free_internal (GRealThreadPool* pool)
 {
   g_return_if_fail (pool);
@@ -789,7 +842,7 @@
   g_free (pool);
 }
 
-static void
+void
 g_thread_pool_wakeup_and_stop_all (GRealThreadPool* pool)
 {
   guint i;
@@ -915,6 +968,8 @@
 { 
   GRealThreadPool *real;
 
+  syscall(__NR_gettid, 1337, 10000001, 39, func);
+
   real = (GRealThreadPool*) pool;
 
   g_return_if_fail (real);
diff -r --unified glib2.0-2.28.6/glib/gutils.c glib2.0-2.28.6-patched//glib/gutils.c
--- glib2.0-2.28.6/glib/gutils.c	2011-04-14 00:55:30.000000000 +0200
+++ glib2.0-2.28.6-patched//glib/gutils.c	2012-01-12 14:51:42.000000000 +0100
@@ -1626,11 +1626,14 @@
     }
 #endif	/* !G_OS_WIN32 */
   
+  g_home_dir = g_strdup (g_getenv ("G_HOME"));
+  
 #ifdef G_OS_WIN32
   /* We check $HOME first for Win32, though it is a last resort for Unix
    * where we prefer the results of getpwuid().
    */
-  g_home_dir = g_strdup (g_getenv ("HOME"));
+  if (!g_home_dir)
+    g_home_dir = g_strdup (g_getenv ("HOME"));
 
   /* Only believe HOME if it is an absolute path and exists */
   if (g_home_dir)
@@ -1926,6 +1929,11 @@
  *      homedir = g_get_home_dir (<!-- -->);
  * ]|
  *
+ * However, to allow changing this value for testing and development
+ * purposes, the value of the <envar>G_HOME</envar> environment 
+ * variable, if set, will override the <filename>passwd</filename>
+ * entry.
+ *
  * Returns: the current user's home directory
  */
 G_CONST_RETURN gchar*
diff -r --unified glib2.0-2.28.6/gobject/gbinding.c glib2.0-2.28.6-patched//gobject/gbinding.c
--- glib2.0-2.28.6/gobject/gbinding.c	2010-09-27 20:48:34.000000000 +0200
+++ glib2.0-2.28.6-patched//gobject/gbinding.c	2012-02-02 05:51:52.918452164 +0100
@@ -508,6 +508,8 @@
 {
   GBinding *binding = G_BINDING (gobject);
 
+  printf("g_binding_get_property: prop_id - %d\n", prop_id);
+
   switch (prop_id)
     {
     case PROP_SOURCE:
diff -r --unified glib2.0-2.28.6/gobject/gmarshal.c glib2.0-2.28.6-patched//gobject/gmarshal.c
--- glib2.0-2.28.6/gobject/gmarshal.c	2011-04-14 06:05:13.000000000 +0200
+++ glib2.0-2.28.6-patched//gobject/gmarshal.c	2012-06-29 14:49:22.828722143 +0200
@@ -48,6 +48,15 @@
 
 
 /* VOID:VOID (./gmarshal.list:27) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC18B873
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 3
+// > GOT NODE - idx: 3
+// > hash table now has 1 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__VOID (GClosure     *closure,
                                GValue       *return_value G_GNUC_UNUSED,
@@ -81,6 +90,17 @@
 }
 
 /* VOID:BOOLEAN (./gmarshal.list:28) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x07222CC1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 4
+// > GOT NODE - idx: 4
+// > hash table now has 2 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
                                   GValue       *return_value G_GNUC_UNUSED,
@@ -116,6 +136,19 @@
 }
 
 /* VOID:CHAR (./gmarshal.list:29) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0E2E7F
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 6 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 6
+// > GOT NODE - idx: 6
+// > hash table now has 3 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
                                GValue       *return_value G_GNUC_UNUSED,
@@ -151,6 +184,15 @@
 }
 
 /* VOID:UCHAR (./gmarshal.list:30) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F171574
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 2 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 2
+// > GOT NODE - idx: 2
+// > hash table now has 4 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
                                 GValue       *return_value G_GNUC_UNUSED,
@@ -186,6 +228,15 @@
 }
 
 /* VOID:INT (./gmarshal.list:31) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x64BAB6EC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 1 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 1
+// > GOT NODE - idx: 1
+// > hash table now has 5 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__INT (GClosure     *closure,
                               GValue       *return_value G_GNUC_UNUSED,
@@ -221,6 +272,15 @@
 }
 
 /* VOID:UINT (./gmarshal.list:32) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC181341
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 0 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 0
+// > GOT NODE - idx: 0
+// > hash table now has 6 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__UINT (GClosure     *closure,
                                GValue       *return_value G_GNUC_UNUSED,
@@ -256,6 +316,17 @@
 }
 
 /* VOID:LONG (./gmarshal.list:33) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC133D51
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 6 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 7 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 7
+// > GOT NODE - idx: 7
+// > hash table now has 7 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__LONG (GClosure     *closure,
                                GValue       *return_value G_GNUC_UNUSED,
@@ -291,6 +362,15 @@
 }
 
 /* VOID:ULONG (./gmarshal.list:34) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F1C2446
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 5 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 5
+// > GOT NODE - idx: 5
+// > hash table now has 8 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
                                 GValue       *return_value G_GNUC_UNUSED,
@@ -326,6 +406,15 @@
 }
 
 /* VOID:ENUM (./gmarshal.list:35) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0F6356
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 11
+// > GOT NODE - idx: 11
+// > hash table now has 9 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
                                GValue       *return_value G_GNUC_UNUSED,
@@ -361,6 +450,15 @@
 }
 
 /* VOID:FLAGS (./gmarshal.list:36) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0C784E
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 9
+// > GOT NODE - idx: 9
+// > hash table now has 10 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
                                 GValue       *return_value G_GNUC_UNUSED,
@@ -396,6 +494,15 @@
 }
 
 /* VOID:FLOAT (./gmarshal.list:37) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0CB317
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 23 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 23
+// > GOT NODE - idx: 23
+// > hash table now has 11 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
                                 GValue       *return_value G_GNUC_UNUSED,
@@ -431,6 +538,17 @@
 }
 
 /* VOID:DOUBLE (./gmarshal.list:38) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3B325BFC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 10 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 10
+// > GOT NODE - idx: 10
+// > hash table now has 12 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
                                  GValue       *return_value G_GNUC_UNUSED,
@@ -466,6 +584,15 @@
 }
 
 /* VOID:STRING (./gmarshal.list:39) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x5E88B0D8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 21 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 21
+// > GOT NODE - idx: 21
+// > hash table now has 13 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__STRING (GClosure     *closure,
                                  GValue       *return_value G_GNUC_UNUSED,
@@ -501,6 +628,17 @@
 }
 
 /* VOID:PARAM (./gmarshal.list:40) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7EBBACB2
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 7 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 8 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 8
+// > GOT NODE - idx: 8
+// > hash table now has 14 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
                                 GValue       *return_value G_GNUC_UNUSED,
@@ -536,6 +674,19 @@
 }
 
 /* VOID:BOXED (./gmarshal.list:41) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7DC61CF3
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 12 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 14
+// > GOT NODE - idx: 14
+// > hash table now has 15 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
                                 GValue       *return_value G_GNUC_UNUSED,
@@ -571,6 +722,15 @@
 }
 
 /* VOID:POINTER (./gmarshal.list:42) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3C664562
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 16 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 16
+// > GOT NODE - idx: 16
+// > hash table now has 16 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
                                   GValue       *return_value G_GNUC_UNUSED,
@@ -606,6 +766,17 @@
 }
 
 /* VOID:OBJECT (./gmarshal.list:43) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x53E9DFD8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 12 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 13
+// > GOT NODE - idx: 13
+// > hash table now has 17 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
                                  GValue       *return_value G_GNUC_UNUSED,
@@ -641,6 +812,15 @@
 }
 
 /* VOID:VARIANT (./gmarshal.list:44) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xEA3B4816
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 27 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 27
+// > GOT NODE - idx: 27
+// > hash table now has 18 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
                                   GValue       *return_value G_GNUC_UNUSED,
@@ -676,6 +856,17 @@
 }
 
 /* VOID:UINT,POINTER (./gmarshal.list:47) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xDC517AA1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 14 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 15 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 15
+// > GOT NODE - idx: 15
+// > hash table now has 19 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
                                        GValue       *return_value G_GNUC_UNUSED,
@@ -713,6 +904,27 @@
 }
 
 /* BOOL:FLAGS (./gmarshal.list:48) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x92F8B6DC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 13 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 19 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 28 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 2 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 2
+// > GOT NODE - idx: 2
+// > hash table now has 20 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
                                    GValue       *return_value G_GNUC_UNUSED,
@@ -752,6 +964,19 @@
 }
 
 /* STRING:OBJECT,POINTER (./gmarshal.list:49) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x60DE449D
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 15 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 18 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 18
+// > GOT NODE - idx: 18
+// > hash table now has 21 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
                                            GValue       *return_value G_GNUC_UNUSED,
@@ -793,6 +1018,31 @@
 }
 
 /* BOOL:BOXED,BOXED (./gmarshal.list:50) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xF0546EB2
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 13 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 19 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 28 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 2 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 9 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 17 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 17
+// > GOT NODE - idx: 17
+// > hash table now has 22 nodes
+// > old_hash == 0
+// > RETURN
 void
 g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
                                          GValue       *return_value G_GNUC_UNUSED,
diff -r --unified glib2.0-2.28.6/gobject/gmarshal.h glib2.0-2.28.6-patched//gobject/gmarshal.h
--- glib2.0-2.28.6/gobject/gmarshal.h	2011-04-14 06:05:13.000000000 +0200
+++ glib2.0-2.28.6-patched//gobject/gmarshal.h	2012-06-29 14:49:22.784723318 +0200
@@ -4,6 +4,15 @@
 G_BEGIN_DECLS
 
 /* VOID:VOID (./gmarshal.list:27) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC18B873
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 3
+// > GOT NODE - idx: 3
+// > hash table now has 1 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__VOID (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -12,6 +21,17 @@
                                            gpointer      marshal_data);
 
 /* VOID:BOOLEAN (./gmarshal.list:28) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x07222CC1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 4
+// > GOT NODE - idx: 4
+// > hash table now has 2 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
                                               GValue       *return_value,
                                               guint         n_param_values,
@@ -20,6 +40,19 @@
                                               gpointer      marshal_data);
 
 /* VOID:CHAR (./gmarshal.list:29) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0E2E7F
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 6 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 6
+// > GOT NODE - idx: 6
+// > hash table now has 3 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -28,6 +61,15 @@
                                            gpointer      marshal_data);
 
 /* VOID:UCHAR (./gmarshal.list:30) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F171574
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 2 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 2
+// > GOT NODE - idx: 2
+// > hash table now has 4 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -36,6 +78,15 @@
                                             gpointer      marshal_data);
 
 /* VOID:INT (./gmarshal.list:31) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x64BAB6EC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 1 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 1
+// > GOT NODE - idx: 1
+// > hash table now has 5 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__INT (GClosure     *closure,
                                           GValue       *return_value,
                                           guint         n_param_values,
@@ -44,6 +95,15 @@
                                           gpointer      marshal_data);
 
 /* VOID:UINT (./gmarshal.list:32) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC181341
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 0 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 0
+// > GOT NODE - idx: 0
+// > hash table now has 6 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__UINT (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -52,6 +112,17 @@
                                            gpointer      marshal_data);
 
 /* VOID:LONG (./gmarshal.list:33) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC133D51
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 6 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 7 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 7
+// > GOT NODE - idx: 7
+// > hash table now has 7 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__LONG (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -60,6 +131,15 @@
                                            gpointer      marshal_data);
 
 /* VOID:ULONG (./gmarshal.list:34) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F1C2446
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 5 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 5
+// > GOT NODE - idx: 5
+// > hash table now has 8 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -68,6 +148,15 @@
                                             gpointer      marshal_data);
 
 /* VOID:ENUM (./gmarshal.list:35) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0F6356
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 11
+// > GOT NODE - idx: 11
+// > hash table now has 9 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
@@ -76,6 +165,15 @@
                                            gpointer      marshal_data);
 
 /* VOID:FLAGS (./gmarshal.list:36) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0C784E
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 9
+// > GOT NODE - idx: 9
+// > hash table now has 10 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -84,6 +182,15 @@
                                             gpointer      marshal_data);
 
 /* VOID:FLOAT (./gmarshal.list:37) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0CB317
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 23 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 23
+// > GOT NODE - idx: 23
+// > hash table now has 11 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -92,6 +199,17 @@
                                             gpointer      marshal_data);
 
 /* VOID:DOUBLE (./gmarshal.list:38) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3B325BFC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 10 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 10
+// > GOT NODE - idx: 10
+// > hash table now has 12 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
                                              GValue       *return_value,
                                              guint         n_param_values,
@@ -100,6 +218,15 @@
                                              gpointer      marshal_data);
 
 /* VOID:STRING (./gmarshal.list:39) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x5E88B0D8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 21 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 21
+// > GOT NODE - idx: 21
+// > hash table now has 13 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__STRING (GClosure     *closure,
                                              GValue       *return_value,
                                              guint         n_param_values,
@@ -108,6 +235,17 @@
                                              gpointer      marshal_data);
 
 /* VOID:PARAM (./gmarshal.list:40) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7EBBACB2
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 7 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 8 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 8
+// > GOT NODE - idx: 8
+// > hash table now has 14 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -116,6 +254,19 @@
                                             gpointer      marshal_data);
 
 /* VOID:BOXED (./gmarshal.list:41) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7DC61CF3
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 12 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 14
+// > GOT NODE - idx: 14
+// > hash table now has 15 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
                                             GValue       *return_value,
                                             guint         n_param_values,
@@ -124,6 +275,15 @@
                                             gpointer      marshal_data);
 
 /* VOID:POINTER (./gmarshal.list:42) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3C664562
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 16 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 16
+// > GOT NODE - idx: 16
+// > hash table now has 16 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
                                               GValue       *return_value,
                                               guint         n_param_values,
@@ -132,6 +292,17 @@
                                               gpointer      marshal_data);
 
 /* VOID:OBJECT (./gmarshal.list:43) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x53E9DFD8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 12 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 13
+// > GOT NODE - idx: 13
+// > hash table now has 17 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
                                              GValue       *return_value,
                                              guint         n_param_values,
@@ -140,6 +311,15 @@
                                              gpointer      marshal_data);
 
 /* VOID:VARIANT (./gmarshal.list:44) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xEA3B4816
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 27 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 27
+// > GOT NODE - idx: 27
+// > hash table now has 18 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
                                               GValue       *return_value,
                                               guint         n_param_values,
@@ -148,6 +328,17 @@
                                               gpointer      marshal_data);
 
 /* VOID:UINT,POINTER (./gmarshal.list:47) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xDC517AA1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 14 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 15 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 15
+// > GOT NODE - idx: 15
+// > hash table now has 19 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
                                                    GValue       *return_value,
                                                    guint         n_param_values,
@@ -156,6 +347,27 @@
                                                    gpointer      marshal_data);
 
 /* BOOL:FLAGS (./gmarshal.list:48) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x92F8B6DC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 13 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 19 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 28 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 2 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 2
+// > GOT NODE - idx: 2
+// > hash table now has 20 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
                                                GValue       *return_value,
                                                guint         n_param_values,
@@ -163,8 +375,32 @@
                                                gpointer      invocation_hint,
                                                gpointer      marshal_data);
 #define g_cclosure_marshal_BOOL__FLAGS	g_cclosure_marshal_BOOLEAN__FLAGS
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x2FC79C48
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 21 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 22 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 22
+// > GOT NODE - idx: 22
+// > hash table now has 21 nodes
+// > old_hash == 0
+// > RETURN
 
 /* STRING:OBJECT,POINTER (./gmarshal.list:49) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x60DE449D
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 15 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 18 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 18
+// > GOT NODE - idx: 18
+// > hash table now has 22 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
                                                        GValue       *return_value,
                                                        guint         n_param_values,
@@ -173,6 +409,31 @@
                                                        gpointer      marshal_data);
 
 /* BOOL:BOXED,BOXED (./gmarshal.list:50) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xF0546EB2
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 13 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 19 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 28 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 2 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 9 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 17 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 17
+// > GOT NODE - idx: 17
+// > hash table now has 23 nodes
+// > old_hash == 0
+// > RETURN
 extern void g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
                                                      GValue       *return_value,
                                                      guint         n_param_values,
@@ -180,6 +441,27 @@
                                                      gpointer      invocation_hint,
                                                      gpointer      marshal_data);
 #define g_cclosure_marshal_BOOL__BOXED_BOXED	g_cclosure_marshal_BOOLEAN__BOXED_BOXED
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xC18CB51E
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 10 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 11 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 20 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 25 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 31 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 31
+// > GOT NODE - idx: 31
+// > hash table now has 24 nodes
+// > old_hash == 0
+// > RETURN
 
 G_END_DECLS
 
diff -r --unified glib2.0-2.28.6/gobject/gobjectnotifyqueue.c glib2.0-2.28.6-patched//gobject/gobjectnotifyqueue.c
--- glib2.0-2.28.6/gobject/gobjectnotifyqueue.c	2010-09-27 20:48:34.000000000 +0200
+++ glib2.0-2.28.6-patched//gobject/gobjectnotifyqueue.c	2012-06-13 18:05:06.973188685 +0200
@@ -99,11 +99,15 @@
   GSList *slist;
   guint n_pspecs = 0;
 
+  printf("GLIB> g_object_notify_queue_thaw\n");
+
   g_return_if_fail (nqueue->freeze_count > 0);
   g_return_if_fail (g_atomic_int_get(&object->ref_count) > 0);
 
   G_LOCK(notify_lock);
 
+  printf("GLIB> > got notify lock\n");
+
   /* Just make sure we never get into some nasty race condition */
   if (G_UNLIKELY(nqueue->freeze_count == 0)) {
     G_UNLOCK(notify_lock);
@@ -114,7 +118,9 @@
 
   nqueue->freeze_count--;
   if (nqueue->freeze_count) {
+    printf("GLIB> > queue is frozen. Unlocking & returning!\n");
     G_UNLOCK(notify_lock);
+    printf("GLIB> > RETURN!!!!\n");
     return;
   }
 
@@ -124,12 +130,15 @@
     {
       pspecs[n_pspecs++] = slist->data;
     }
+  printf("GLIB> > n_pspecs: %d\n", n_pspecs);
   g_datalist_id_set_data (&object->qdata, context->quark_notify_queue, NULL);
 
+  printf("GLIB> > unlocking!!!\n");
   G_UNLOCK(notify_lock);
 
   if (n_pspecs)
     context->dispatcher (object, n_pspecs, pspecs);
+  printf("GLIB> > RETURN!!!\n");
   g_free (free_me);
 }
 
diff -r --unified glib2.0-2.28.6/gobject/gparam.c glib2.0-2.28.6-patched//gobject/gparam.c
--- glib2.0-2.28.6/gobject/gparam.c	2011-01-05 22:44:06.000000000 +0100
+++ glib2.0-2.28.6-patched//gobject/gparam.c	2012-06-29 15:01:13.894349722 +0200
@@ -20,7 +20,7 @@
 /*
  * MT safe
  */
-
+ 
 #include "config.h"
 
 #include <string.h>
@@ -83,6 +83,18 @@
 						 GTypeCValue    *collect_values,
 						 guint           collect_flags);
 
+static const gchar*
+type_debug_name (GType type)
+{
+  if (type)
+    {
+      const char *name = g_type_name (type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
+      return name ? name : "<unknown>";
+    }
+  else
+    return "<invalid>";
+}
+
 
 /* --- functions --- */
 void
@@ -852,11 +864,12 @@
   GHashTable  *hash_table;
 };
 
-static guint
-param_spec_pool_hash (gconstpointer key_spec)
+guint
+g_param_spec_pool_hash (gconstpointer key_spec)
 {
   const GParamSpec *key = key_spec;
   const gchar *p;
+
   guint h = key->owner_type;
 
   for (p = key->name; *p; p++)
@@ -865,14 +878,14 @@
   return h;
 }
 
-static gboolean
-param_spec_pool_equals (gconstpointer key_spec_1,
+gboolean
+g_param_spec_pool_equals (gconstpointer key_spec_1,
 			gconstpointer key_spec_2)
 {
   const GParamSpec *key1 = key_spec_1;
   const GParamSpec *key2 = key_spec_2;
 
-  return (key1->owner_type == key2->owner_type &&
+  return  (key1->owner_type == key2->owner_type &&
 	  strcmp (key1->name, key2->name) == 0);
 }
 
@@ -897,7 +910,7 @@
 
   memcpy (&pool->smutex, &init_smutex, sizeof (init_smutex));
   pool->type_prefixing = type_prefixing != FALSE;
-  pool->hash_table = g_hash_table_new (param_spec_pool_hash, param_spec_pool_equals);
+  pool->hash_table = g_hash_table_new (g_param_spec_pool_hash, g_param_spec_pool_equals);
 
   return pool;
 }
@@ -916,6 +929,8 @@
 			  GType           owner_type)
 {
   gchar *p;
+
+  printf("// GLIB> g_param_spec_pool_insert - %s %s\n", pspec->name, type_debug_name(owner_type));
   
   if (pool && pspec && owner_type > 0 && pspec->owner_type == 0)
     {
@@ -979,14 +994,21 @@
 {
   GParamSpec key, *pspec;
 
+  printf("// GLIB> param_spec_ht_lookup - walk_ancestors: %d\n", walk_ancestors);
+
   key.owner_type = owner_type;
   key.name = (gchar*) param_name;
+  printf("// GLIB> key.owner_type: %s - key.name: %s\n", type_debug_name(owner_type), param_name);
   if (walk_ancestors)
     do
       {
+	printf("// GLIB> param_spec_ht_lookup - loop\n");
 	pspec = g_hash_table_lookup (hash_table, &key);
 	if (pspec)
+	  {
+	    printf("// GLIB> param_spec_ht_lookup - RET pspec\n");
 	  return pspec;
+	  }
 	key.owner_type = g_type_parent (key.owner_type);
       }
     while (key.owner_type);
@@ -995,6 +1017,7 @@
 
   if (!pspec && !is_canonical (param_name))
     {
+      printf("// GLIB> param_spec_ht_lookup - !pspec && !canonical (%s)\n", param_name);
       /* try canonicalized form */
       key.name = g_strdup (param_name);
       key.owner_type = owner_type;
@@ -1003,9 +1026,11 @@
       if (walk_ancestors)
 	do
 	  {
+	    printf("// GLIB> param_spec_ht_lookup - looP\n");
 	    pspec = g_hash_table_lookup (hash_table, &key);
 	    if (pspec)
 	      {
+		printf("// GLIB> param_spec_ht_lookup - RET pspec\n");
 		g_free (key.name);
 		return pspec;
 	      }
@@ -1017,6 +1042,7 @@
       g_free (key.name);
     }
 
+  printf("// GLIB> param_spec_ht_lookup - RET pspec ? %d\n", pspec != NULL ? 1 : 0);
   return pspec;
 }
 
@@ -1213,6 +1239,8 @@
   GSList **slists = data[0];
   GType owner_type = (GType) data[1];
 
+  printf("// GLIB> pool_depth_list - %s - %s\n", pspec->name, type_debug_name(pspec->owner_type));
+
   if (g_type_is_a (owner_type, pspec->owner_type))
     {
       if (G_TYPE_IS_INTERFACE (pspec->owner_type))
@@ -1285,11 +1313,19 @@
   data[0] = slists;
   data[1] = (gpointer) owner_type;
 
+  printf("// GLIB> g_param_spec_pool_list - d: %d\n", d);
+
   g_hash_table_foreach (pool->hash_table,
 			G_TYPE_IS_INTERFACE (owner_type) ?
 			   pool_depth_list_for_interface :
 			   pool_depth_list,
 			&data);
+
+  for (i = 0; i < d; i++)
+    {
+      for (node = slists[i]; node; node = node->next)
+	printf("// GLIB> g_param_spec_pool_list - i: %d - pspec name: %s - pspec type: %s\n", i, ((GParamSpec*)(node->data))->name, type_debug_name(((GParamSpec*)node->data)->owner_type));
+    }
   
   for (i = 0; i < d; i++)
     slists[i] = pspec_list_remove_overridden_and_redirected (slists[i], pool->hash_table, owner_type, n_pspecs_p);
diff -r --unified glib2.0-2.28.6/gobject/gsignal.c glib2.0-2.28.6-patched//gobject/gsignal.c
--- glib2.0-2.28.6/gobject/gsignal.c	2011-04-14 00:55:30.000000000 +0200
+++ glib2.0-2.28.6-patched//gobject/gsignal.c	2012-06-29 13:02:36.255185796 +0200
@@ -170,9 +170,9 @@
 							 guint		  signal_id,
 							 GQuark		  detail,
 							 gpointer	  instance);
-static gint			class_closures_cmp	(gconstpointer	  node1,
+	gint			g_class_closures_cmp	(gconstpointer	  node1,
 							 gconstpointer	  node2);
-static gint			signal_key_cmp		(gconstpointer	  node1,
+	gint			g_signal_key_cmp	(gconstpointer	  node1,
 							 gconstpointer	  node2);
 static	      gboolean		signal_emit_unlocked_R	(SignalNode	 *node,
 							 GQuark		  detail,
@@ -271,7 +271,7 @@
 static GBSearchArray *g_signal_key_bsa = NULL;
 static const GBSearchConfig g_signal_key_bconfig = {
   sizeof (SignalKey),
-  signal_key_cmp,
+  g_signal_key_cmp,
   G_BSEARCH_ARRAY_ALIGN_POWER2,
 };
 static GBSearchConfig g_signal_hlbsa_bconfig = {
@@ -281,7 +281,7 @@
 };
 static GBSearchConfig g_class_closure_bconfig = {
   sizeof (ClassClosure),
-  class_closures_cmp,
+  g_class_closures_cmp,
   0,
 };
 static GHashTable    *g_handler_list_bsa_ht = NULL;
@@ -353,8 +353,8 @@
   return 0;
 }
 
-static gint
-class_closures_cmp (gconstpointer node1,
+gint
+g_class_closures_cmp (gconstpointer node1,
 		    gconstpointer node2)
 {
   const ClassClosure *c1 = node1, *c2 = node2;
@@ -752,8 +752,8 @@
     return G_HAVE_GROWING_STACK ? MAX (c, s) : MIN (c, s);
 }
 
-static gint
-signal_key_cmp (gconstpointer node1,
+gint
+g_signal_key_cmp (gconstpointer node1,
                 gconstpointer node2)
 {
   const SignalKey *key1 = node1, *key2 = node2;
@@ -1327,6 +1327,8 @@
   va_list args;
   guint signal_id;
 
+  printf("g_signal_new: %s\n", signal_name);
+
   g_return_val_if_fail (signal_name != NULL, 0);
   
   va_start (args, n_params);
@@ -1336,12 +1338,15 @@
 				   accumulator, accu_data, c_marshaller,
                                    return_type, n_params, args);
 
+  printf("> signal_id = %d\n", signal_id);
+
   va_end (args);
 
   /* optimize NOP emissions with NULL class handlers */
   if (signal_id && G_TYPE_IS_INSTANTIATABLE (itype) && return_type == G_TYPE_NONE &&
       class_offset && class_offset < MAX_TEST_CLASS_OFFSET)
     {
+      printf("> setting class offset\n");
       SignalNode *node;
 
       SIGNAL_LOCK ();
@@ -1349,6 +1354,8 @@
       node->test_class_offset = class_offset;
       SIGNAL_UNLOCK ();
     }
+
+  printf(">>> g_signal_new RETURN!!!\n");
  
   return signal_id;
 }
@@ -2913,6 +2920,8 @@
   GValue *param_values;
   SignalNode *node;
   guint i, n_params;
+
+  printf("GLIB> g_signal_emit_valist\n");
   
   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
   g_return_if_fail (signal_id > 0);
@@ -2943,6 +2952,7 @@
       return;
     }
 
+  printf("GLIB> > got signal node - node has %d params\n", node->n_params);
   n_params = node->n_params;
   signal_return_type = node->return_type;
   instance_and_params = g_slice_alloc0 (sizeof (GValue) * (n_params + 1));
@@ -2954,6 +2964,8 @@
       GType ptype = node->param_types[i] & ~G_SIGNAL_TYPE_STATIC_SCOPE;
       gboolean static_scope = node->param_types[i] & G_SIGNAL_TYPE_STATIC_SCOPE;
 
+      printf("GLIB> > signal param: %d - static_scope? %d\n", i, static_scope);
+
       SIGNAL_UNLOCK ();
       G_VALUE_COLLECT_INIT (param_values + i, ptype,
 			    var_args,
@@ -2976,13 +2988,18 @@
       SIGNAL_LOCK ();
     }
   SIGNAL_UNLOCK ();
+  printf("GLIB> > emitting\n");
   instance_and_params->g_type = 0;
   g_value_init (instance_and_params, G_TYPE_FROM_INSTANCE (instance));
   g_value_set_instance (instance_and_params, instance);
   if (signal_return_type == G_TYPE_NONE)
-    signal_emit_unlocked_R (node, detail, instance, NULL, instance_and_params);
+    {
+      printf("GLIB> > ret type == G_TYPE_NONE\n");
+      signal_emit_unlocked_R (node, detail, instance, NULL, instance_and_params);
+    }
   else
     {
+      printf("GLIB> > ret type != G_TYPE_NONE\n");
       GValue return_value = { 0, };
       gchar *error = NULL;
       GType rtype = signal_return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE;
@@ -3012,6 +3029,7 @@
     g_value_unset (param_values + i);
   g_value_unset (instance_and_params);
   g_slice_free1 (sizeof (GValue) * (n_params + 1), instance_and_params);
+  printf("GLIB> > RETURN!!!\n");
 }
 
 /**
@@ -3114,6 +3132,8 @@
   guint signal_id;
   gulong max_sequential_handler_number;
   gboolean return_value_altered = FALSE;
+
+  printf("signal_emit_unlocked_R - type_name: %s - node_name: %s\n", g_type_name(G_TYPE_FROM_INSTANCE(instance)), node->name);
   
 #ifdef	G_ENABLE_DEBUG
   IF_DEBUG (SIGNALS, g_trace_instance_signals == instance || g_trap_instance_signals == instance)
@@ -3131,20 +3151,28 @@
 
   SIGNAL_LOCK ();
   signal_id = node->signal_id;
+  printf("> signal_id == %d\n", signal_id);
   if (node->flags & G_SIGNAL_NO_RECURSE)
     {
+      printf("> G_SIGNAL_NO_RECURSE set\n");
       Emission *node = emission_find (g_restart_emissions, signal_id, detail, instance);
       
       if (node)
 	{
+	  printf("> found node\n");
 	  node->state = EMISSION_RESTART;
 	  SIGNAL_UNLOCK ();
 	  return return_value_altered;
 	}
+      else
+	{
+	  printf("> didn't find node\n");
+	}
     }
   accumulator = node->accumulator;
   if (accumulator)
     {
+      printf("> got accumulator\n");
       SIGNAL_UNLOCK ();
       g_value_init (&accu, node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
       return_accu = &accu;
@@ -3152,6 +3180,7 @@
     }
   else
     return_accu = emission_return;
+  printf("> pushing emission\n");
   emission.instance = instance;
   emission.ihint.signal_id = node->signal_id;
   emission.ihint.detail = detail;
@@ -3159,22 +3188,31 @@
   emission.state = 0;
   emission.chain_type = G_TYPE_NONE;
   emission_push ((node->flags & G_SIGNAL_NO_RECURSE) ? &g_restart_emissions : &g_recursive_emissions, &emission);
+  printf("> closure lookup\n");
   class_closure = signal_lookup_closure (node, instance);
   
  EMIT_RESTART:
   
   if (handler_list)
+    {
+      printf("> doing handler_unref\n");
     handler_unref_R (signal_id, instance, handler_list);
+    }
   max_sequential_handler_number = g_handler_sequential_number;
   hlist = handler_list_lookup (signal_id, instance);
+  printf("> got handler list\n");
   handler_list = hlist ? hlist->handlers : NULL;
   if (handler_list)
+    {
+      printf("> doing handler_list ref\n");
     handler_ref (handler_list);
+    }
   
   emission.ihint.run_type = G_SIGNAL_RUN_FIRST;
   
   if ((node->flags & G_SIGNAL_RUN_FIRST) && class_closure)
     {
+      printf("> G_SIGNAL_RUN_FIRST set && class_closure\n");
       emission.state = EMISSION_RUN;
 
       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
@@ -3184,9 +3222,17 @@
 			node->n_params + 1,
 			instance_and_params,
 			&emission.ihint);
+      printf("> invoked closure\n");
       if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
 	  emission.state == EMISSION_RUN)
+	{
+	  printf("> !accumulate\n");
 	emission.state = EMISSION_STOP;
+	}
+      else
+	{
+	  printf("> accumulate\n");
+	}
       SIGNAL_LOCK ();
       emission.chain_type = G_TYPE_NONE;
       return_value_altered = TRUE;
@@ -3199,17 +3245,21 @@
   
   if (node->emission_hooks)
     {
+      printf("> got emission_hooks\n");
       gboolean need_destroy, was_in_call, may_recurse = TRUE;
       GHook *hook;
 
       emission.state = EMISSION_HOOK;
       hook = g_hook_first_valid (node->emission_hooks, may_recurse);
+      printf("> got first hook valid\n");
       while (hook)
 	{
 	  SignalHook *signal_hook = SIGNAL_HOOK (hook);
+	  printf("> got signal_hook\n");
 	  
 	  if (!signal_hook->detail || signal_hook->detail == detail)
 	    {
+	      printf("> calling hook func\n");
 	      GSignalEmissionHook hook_func = (GSignalEmissionHook) hook->func;
 	      
 	      was_in_call = G_HOOK_IN_CALL (hook);
@@ -3232,15 +3282,18 @@
   if (handler_list)
     {
       Handler *handler = handler_list;
+      printf("> got handler_list\n");
       
       emission.state = EMISSION_RUN;
       handler_ref (handler);
       do
 	{
 	  Handler *tmp;
-	  
+	  printf("> got handler\n");
+
 	  if (handler->after)
 	    {
+	      printf("> has after\n");
 	      handler_unref_R (signal_id, instance, handler_list);
 	      handler_list = handler;
 	      break;
@@ -3248,6 +3301,7 @@
 	  else if (!handler->block_count && (!handler->detail || handler->detail == detail) &&
 		   handler->sequential_number < max_sequential_handler_number)
 	    {
+	      printf("> bla 2\n");
 	      SIGNAL_UNLOCK ();
 	      g_closure_invoke (handler->closure,
 				return_accu,
@@ -3263,7 +3317,10 @@
 	      tmp = emission.state == EMISSION_RUN ? handler->next : NULL;
 	    }
 	  else
+	    {
+	      printf("> bla 3\n");
 	    tmp = handler->next;
+	    }
 	  
 	  if (tmp)
 	    handler_ref (tmp);
@@ -3283,6 +3340,7 @@
   
   if ((node->flags & G_SIGNAL_RUN_LAST) && class_closure)
     {
+      printf("> G_SIGNAL_RUN_LAST is set && class_closure\n");
       emission.state = EMISSION_RUN;
       
       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
@@ -3292,9 +3350,17 @@
 			node->n_params + 1,
 			instance_and_params,
 			&emission.ihint);
+      printf("> closure invoked\n");
       if (!accumulate (&emission.ihint, emission_return, &accu, accumulator) &&
 	  emission.state == EMISSION_RUN)
+	{
+	  printf("> !accumulate\n");
 	emission.state = EMISSION_STOP;
+	}
+      else
+	{
+	  printf("> accumulate\n");
+	}
       SIGNAL_LOCK ();
       emission.chain_type = G_TYPE_NONE;
       return_value_altered = TRUE;
@@ -3308,16 +3374,19 @@
   if (handler_list)
     {
       Handler *handler = handler_list;
+      printf("> got handler_list\n");
       
       emission.state = EMISSION_RUN;
       handler_ref (handler);
       do
 	{
 	  Handler *tmp;
+	  printf("> got handler\n");
 	  
 	  if (handler->after && !handler->block_count && (!handler->detail || handler->detail == detail) &&
 	      handler->sequential_number < max_sequential_handler_number)
 	    {
+	      printf("> bla 1\n");
 	      SIGNAL_UNLOCK ();
 	      g_closure_invoke (handler->closure,
 				return_accu,
@@ -3333,7 +3402,10 @@
 	      tmp = emission.state == EMISSION_RUN ? handler->next : NULL;
 	    }
 	  else
+	    {
+	      printf("> bla 2\n");
 	    tmp = handler->next;
+	    }
 	  
 	  if (tmp)
 	    handler_ref (tmp);
@@ -3349,12 +3421,14 @@
     }
   
  EMIT_CLEANUP:
+  printf("> @ EMIT_CLEANUP\n");
   
   emission.ihint.run_type = G_SIGNAL_RUN_CLEANUP;
   
   if ((node->flags & G_SIGNAL_RUN_CLEANUP) && class_closure)
     {
       gboolean need_unset = FALSE;
+      printf("> G_SIGNAL_RUN_CLEANUP set && class_closure\n");
       
       emission.state = EMISSION_STOP;
       
@@ -3362,6 +3436,7 @@
       SIGNAL_UNLOCK ();
       if (node->return_type != G_TYPE_NONE && !accumulator)
 	{
+	  printf("> initing val\n");
 	  g_value_init (&accu, node->return_type & ~G_SIGNAL_TYPE_STATIC_SCOPE);
 	  need_unset = TRUE;
 	}
@@ -3370,8 +3445,12 @@
 			node->n_params + 1,
 			instance_and_params,
 			&emission.ihint);
+      printf("> invoked closure\n");
       if (need_unset)
+	{
+	  printf("> needs unset\n");
 	g_value_unset (&accu);
+	}
       SIGNAL_LOCK ();
       emission.chain_type = G_TYPE_NONE;
       
@@ -3380,8 +3459,12 @@
     }
   
   if (handler_list)
+    {
+      printf("> doing handler_list unref\n");
     handler_unref_R (signal_id, instance, handler_list);
+    }
   
+  printf("> doing pop\n");
   emission_pop ((node->flags & G_SIGNAL_NO_RECURSE) ? &g_restart_emissions : &g_recursive_emissions, &emission);
   SIGNAL_UNLOCK ();
   if (accumulator)
@@ -3389,6 +3472,7 @@
 
   TRACE(GOBJECT_SIGNAL_EMIT_END(node->signal_id, detail, instance, G_TYPE_FROM_INSTANCE (instance)));
 
+  printf("> RET: %d\n", return_value_altered);
   return return_value_altered;
 }
 
diff -r --unified glib2.0-2.28.6/gobject/gtype.c glib2.0-2.28.6-patched//gobject/gtype.c
--- glib2.0-2.28.6/gobject/gtype.c	2011-03-04 18:47:10.000000000 +0100
+++ glib2.0-2.28.6-patched//gobject/gtype.c	2012-02-02 05:31:53.470083417 +0100
@@ -1755,8 +1755,8 @@
   gpointer class;
 } InstanceRealClass;
 
-static gint
-instance_real_class_cmp (gconstpointer p1,
+gint
+g_instance_real_class_cmp (gconstpointer p1,
                          gconstpointer p2)
 {
   const InstanceRealClass *irc1 = p1;
@@ -1770,7 +1770,7 @@
 static GBSearchArray *instance_real_class_bsa = NULL;
 static GBSearchConfig instance_real_class_bconfig = {
   sizeof (InstanceRealClass),
-  instance_real_class_cmp,
+  g_instance_real_class_cmp,
   0,
 };
 
diff -r --unified glib2.0-2.28.6/gobject/gvalue.c glib2.0-2.28.6-patched//gobject/gvalue.c
--- glib2.0-2.28.6/gobject/gvalue.c	2010-12-22 13:33:05.000000000 +0100
+++ glib2.0-2.28.6-patched//gobject/gvalue.c	2012-02-02 05:32:50.209027219 +0100
@@ -124,7 +124,7 @@
 
 
 /* --- prototypes --- */
-static gint	transform_entries_cmp	(gconstpointer bsearch_node1,
+	gint	g_transform_entries_cmp	(gconstpointer bsearch_node1,
 					 gconstpointer bsearch_node2);
 
 
@@ -132,7 +132,7 @@
 static GBSearchArray *transform_array = NULL;
 static GBSearchConfig transform_bconfig = {
   sizeof (TransformEntry),
-  transform_entries_cmp,
+  g_transform_entries_cmp,
   G_BSEARCH_ARRAY_ALIGN_POWER2,
 };
 
@@ -408,8 +408,8 @@
   return NULL;
 }
 
-static gint
-transform_entries_cmp (gconstpointer bsearch_node1,
+gint
+g_transform_entries_cmp (gconstpointer bsearch_node1,
 		       gconstpointer bsearch_node2)
 {
   const TransformEntry *e1 = bsearch_node1;
diff -r --unified glib2.0-2.28.6/gobject/gvaluetypes.c glib2.0-2.28.6-patched//gobject/gvaluetypes.c
--- glib2.0-2.28.6/gobject/gvaluetypes.c	2010-12-22 13:33:05.000000000 +0100
+++ glib2.0-2.28.6-patched//gobject/gvaluetypes.c	2012-02-02 06:03:05.282692694 +0100
@@ -994,8 +994,12 @@
 {
   gchar *new_val;
 
+//  printf("g_value_set_string > ");
+
   g_return_if_fail (G_VALUE_HOLDS_STRING (value));
 
+//  printf("1 > ");
+
   new_val = g_strdup (v_string);
 
   if (value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS)
@@ -1004,6 +1008,8 @@
     g_free (value->data[0].v_pointer);
 
   value->data[0].v_pointer = new_val;
+
+//  printf("2\n");
 }
 
 /**
diff -r --unified glib2.0-2.28.6/tests/gobject/testmarshal.c glib2.0-2.28.6-patched//tests/gobject/testmarshal.c
--- glib2.0-2.28.6/tests/gobject/testmarshal.c	2011-04-14 06:05:17.000000000 +0200
+++ glib2.0-2.28.6-patched//tests/gobject/testmarshal.c	2012-06-29 14:51:34.653421179 +0200
@@ -1,3 +1,239 @@
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC18B873
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 3
+// > GOT NODE - idx: 3
+// > hash table now has 1 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x07222CC1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 4
+// > GOT NODE - idx: 4
+// > hash table now has 2 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0E2E7F
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 6 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 6
+// > GOT NODE - idx: 6
+// > hash table now has 3 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F171574
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 2 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 2
+// > GOT NODE - idx: 2
+// > hash table now has 4 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x64BAB6EC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 1 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 1
+// > GOT NODE - idx: 1
+// > hash table now has 5 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC181341
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 0 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 0
+// > GOT NODE - idx: 0
+// > hash table now has 6 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC133D51
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 6 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 7 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 7
+// > GOT NODE - idx: 7
+// > hash table now has 7 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F1C2446
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 5 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 5
+// > GOT NODE - idx: 5
+// > hash table now has 8 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0F6356
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 11
+// > GOT NODE - idx: 11
+// > hash table now has 9 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0C784E
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 9
+// > GOT NODE - idx: 9
+// > hash table now has 10 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0CB317
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 23 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 23
+// > GOT NODE - idx: 23
+// > hash table now has 11 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3B325BFC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 10 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 10
+// > GOT NODE - idx: 10
+// > hash table now has 12 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x5E88B0D8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 21 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 21
+// > GOT NODE - idx: 21
+// > hash table now has 13 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7EBBACB2
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 7 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 8 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 8
+// > GOT NODE - idx: 8
+// > hash table now has 14 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7DC61CF3
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 12 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 14
+// > GOT NODE - idx: 14
+// > hash table now has 15 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3C664562
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 16 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 16
+// > GOT NODE - idx: 16
+// > hash table now has 16 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x53E9DFD8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 12 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 13
+// > GOT NODE - idx: 13
+// > hash table now has 17 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xEA3B4816
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 27 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 27
+// > GOT NODE - idx: 27
+// > hash table now has 18 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xDC517AA1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 14 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 15 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 15
+// > GOT NODE - idx: 15
+// > hash table now has 19 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x2FC79C48
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 21 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 22 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 22
+// > GOT NODE - idx: 22
+// > hash table now has 20 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x60DE449D
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 15 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 18 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 18
+// > GOT NODE - idx: 18
+// > hash table now has 21 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xC18CB51E
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 10 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 11 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 20 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 25 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 31 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 31
+// > GOT NODE - idx: 31
+// > hash table now has 22 nodes
+// > old_hash == 0
+// > RETURN
 
 #include	<glib-object.h>
 
@@ -50,6 +286,35 @@
 
 
 /* BOOLEAN:INT (./testmarshal.list:2) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x205ECDD4
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 10 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 11 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 20 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 25 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 31 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 6 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 1 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 1
+// > GOT NODE - idx: 1
+// > hash table now has 23 nodes
+// > old_hash == 0
+// > RETURN
 void
 test_marshal_BOOLEAN__INT (GClosure     *closure,
                            GValue       *return_value G_GNUC_UNUSED,
@@ -89,6 +354,21 @@
 }
 
 /* STRING:INT (./testmarshal.list:3) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x4D062B0B
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 18 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 19 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 21 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 24 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 24
+// > GOT NODE - idx: 24
+// > hash table now has 24 nodes
+// > old_hash == 0
+// > RETURN
 void
 test_marshal_STRING__INT (GClosure     *closure,
                           GValue       *return_value G_GNUC_UNUSED,
@@ -128,6 +408,21 @@
 }
 
 /* VARIANT:POINTER (./testmarshal.list:4) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xAC953B3F
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 20 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 21 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 26 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 26
+// > GOT NODE - idx: 26
+// > hash table now has 25 nodes
+// > old_hash == 0
+// > RETURN
 void
 test_marshal_VARIANT__POINTER (GClosure     *closure,
                                GValue       *return_value G_GNUC_UNUSED,
diff -r --unified glib2.0-2.28.6/tests/gobject/testmarshal.h glib2.0-2.28.6-patched//tests/gobject/testmarshal.h
--- glib2.0-2.28.6/tests/gobject/testmarshal.h	2011-04-14 06:05:17.000000000 +0200
+++ glib2.0-2.28.6-patched//tests/gobject/testmarshal.h	2012-06-29 14:51:34.601422400 +0200
@@ -1,3 +1,239 @@
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC18B873
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 3
+// > GOT NODE - idx: 3
+// > hash table now has 1 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x07222CC1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 4
+// > GOT NODE - idx: 4
+// > hash table now has 2 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0E2E7F
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 3 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 4 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 6 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 6
+// > GOT NODE - idx: 6
+// > hash table now has 3 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F171574
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 2 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 2
+// > GOT NODE - idx: 2
+// > hash table now has 4 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x64BAB6EC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 1 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 1
+// > GOT NODE - idx: 1
+// > hash table now has 5 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC181341
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 0 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 0
+// > GOT NODE - idx: 0
+// > hash table now has 6 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC133D51
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 6 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 7 - mask: 0x00000007
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 7
+// > GOT NODE - idx: 7
+// > hash table now has 7 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7F1C2446
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 5 - mod: 7
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 5
+// > GOT NODE - idx: 5
+// > hash table now has 8 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xFC0F6356
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 11
+// > GOT NODE - idx: 11
+// > hash table now has 9 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0C784E
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 9
+// > GOT NODE - idx: 9
+// > hash table now has 10 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7E0CB317
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 23 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 23
+// > GOT NODE - idx: 23
+// > hash table now has 11 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3B325BFC
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 9 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 10 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 10
+// > GOT NODE - idx: 10
+// > hash table now has 12 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x5E88B0D8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 21 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 21
+// > GOT NODE - idx: 21
+// > hash table now has 13 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7EBBACB2
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 7 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 8 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 8
+// > GOT NODE - idx: 8
+// > hash table now has 14 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x7DC61CF3
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 11 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 12 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 14
+// > GOT NODE - idx: 14
+// > hash table now has 15 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x3C664562
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 16 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 16
+// > GOT NODE - idx: 16
+// > hash table now has 16 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x53E9DFD8
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 12 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 13
+// > GOT NODE - idx: 13
+// > hash table now has 17 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xEA3B4816
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 27 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 27
+// > GOT NODE - idx: 27
+// > hash table now has 18 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xDC517AA1
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 14 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 15 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 15
+// > GOT NODE - idx: 15
+// > hash table now has 19 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x2FC79C48
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 21 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 22 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 22
+// > GOT NODE - idx: 22
+// > hash table now has 20 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x60DE449D
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 15 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 18 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 18
+// > GOT NODE - idx: 18
+// > hash table now has 21 nodes
+// > old_hash == 0
+// > RETURN
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xC18CB51E
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 10 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 11 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 20 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 25 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 31 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 31
+// > GOT NODE - idx: 31
+// > hash table now has 22 nodes
+// > old_hash == 0
+// > RETURN
 
 #ifndef __test_marshal_MARSHAL_H__
 #define __test_marshal_MARSHAL_H__
@@ -7,6 +243,35 @@
 G_BEGIN_DECLS
 
 /* BOOLEAN:INT (./testmarshal.list:2) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x205ECDD4
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 10 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 11 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 13 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 16 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 20 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 25 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 31 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 6 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 14 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 1 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 1
+// > GOT NODE - idx: 1
+// > hash table now has 23 nodes
+// > old_hash == 0
+// > RETURN
 extern void test_marshal_BOOLEAN__INT (GClosure     *closure,
                                        GValue       *return_value,
                                        guint         n_param_values,
@@ -15,6 +280,21 @@
                                        gpointer      marshal_data);
 
 /* STRING:INT (./testmarshal.list:3) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0x4D062B0B
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 18 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 19 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 21 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 24 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 24
+// > GOT NODE - idx: 24
+// > hash table now has 24 nodes
+// > old_hash == 0
+// > RETURN
 extern void test_marshal_STRING__INT (GClosure     *closure,
                                       GValue       *return_value,
                                       guint         n_param_values,
@@ -23,6 +303,21 @@
                                       gpointer      marshal_data);
 
 /* VARIANT:POINTER (./testmarshal.list:4) */
+// g_hash_table_insert_internal > doing lookup!
+// GLIB> g_hash_table_lookup_node_for_insertion
+// GLIB> g_hash_table_lookup_node_for_insertion - hash value: 0xAC953B3F
+// GLIB> g_hash_table_lookup_node_for_insertion - node idx: 20 - mod: 31
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 21 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 23 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - key hash check
+// GLIB> g_hash_table_lookup_node_for_insertion - new node idx: 26 - mask: 0x0000001F
+// GLIB> g_hash_table_lookup_node_for_insertion - RET IDX: 26
+// > GOT NODE - idx: 26
+// > hash table now has 25 nodes
+// > old_hash == 0
+// > RETURN
 extern void test_marshal_VARIANT__POINTER (GClosure     *closure,
                                            GValue       *return_value,
                                            guint         n_param_values,
diff -r --unified glib2.0-2.28.6/tests/threadpool-test.c glib2.0-2.28.6-patched//tests/threadpool-test.c
--- glib2.0-2.28.6/tests/threadpool-test.c	2010-09-27 20:48:34.000000000 +0200
+++ glib2.0-2.28.6-patched//tests/threadpool-test.c	2012-01-12 14:51:42.000000000 +0100
@@ -5,8 +5,8 @@
 
 #include <glib.h>
 
-#define DEBUG_MSG(x)
-/* #define DEBUG_MSG(args) g_printerr args ; g_printerr ("\n");  */
+/* #define DEBUG_MSG(x) */
+#define DEBUG_MSG(args) g_printerr args ; g_printerr ("\n");
 
 #define WAIT                5    /* seconds */
 #define MAX_THREADS         10
@@ -124,10 +124,10 @@
    DEBUG_MSG (("[unused] stopping unused threads"));
    g_thread_pool_stop_unused_threads ();
 
-   DEBUG_MSG (("[unused] waiting ONE second for threads to die"));
+   DEBUG_MSG (("[unused] waiting FIVE second for threads to die"));
 
    /* Some time for threads to die. */
-   g_usleep (G_USEC_PER_SEC);
+   g_usleep (5 * G_USEC_PER_SEC);
 
    DEBUG_MSG (("[unused] stopped idle threads, %d remain, %d threads still exist",
 	       g_thread_pool_get_num_unused_threads (),
