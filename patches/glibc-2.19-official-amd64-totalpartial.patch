diff -N -r --unified glibc-2.19/crypt/crypt_util.c glibc-2.19-totalpartial/crypt/crypt_util.c
--- glibc-2.19/crypt/crypt_util.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/crypt/crypt_util.c	2017-03-04 01:35:20.342744067 -0800
@@ -360,10 +360,10 @@
   sb[2] = (long64*)__data->sb2; sb[3] = (long64*)__data->sb3;
 #endif
 
-  if(small_tables_initialized == 0) {
+  if(atomic_load(small_tables_initialized) == 0) {
 #ifdef __GNU_LIBRARY__
     __libc_lock_lock (_ufc_tables_lock);
-    if(small_tables_initialized)
+    if(atomic_load(small_tables_initialized))
       goto small_tables_done;
 #endif
 
@@ -467,7 +467,7 @@
       }
     }
     atomic_write_barrier ();
-    small_tables_initialized = 1;
+    atomic_store(small_tables_initialized, 1);
 #ifdef __GNU_LIBRARY__
 small_tables_done:
     __libc_lock_unlock(_ufc_tables_lock);
diff -N -r --unified glibc-2.19/csu/libc-start.c glibc-2.19-totalpartial/csu/libc-start.c
--- glibc-2.19/csu/libc-start.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/csu/libc-start.c	2017-03-15 17:00:18.714392029 -0700
@@ -104,6 +104,889 @@
 # define MAIN_AUXVEC_PARAM
 #endif
 
+#ifdef USE_MVEE_LIBC
+static __thread int   mvee_master_thread_id         = 0;
+static unsigned char  mvee_sync_enabled             = 0;
+static unsigned char  mvee_libc_initialized         = 0;
+static unsigned char  mvee_master_variant           = 0;
+static unsigned char  mvee_buffer_valid             = 0;
+static unsigned short mvee_num_childs               = 0;
+static unsigned short mvee_child_num                = 0;
+#ifdef MVEE_EXTENDED_QUEUE
+static unsigned short mvee_op_number                = 1;
+#endif
+#ifdef MVEE_LOG_EIPS
+DEFINE_MVEE_QUEUE(lock, 1);
+#else
+DEFINE_MVEE_QUEUE(lock, 0);
+#endif
+static __thread unsigned long  mvee_prev_flush_cnt           = 0;
+static __thread unsigned long  mvee_lock_buffer_prev_pos     = 0;
+#if defined(MVEE_EXTENDED_QUEUE) && defined(MVEE_CHECK_LOCK_TYPE)
+static __thread unsigned long  mvee_original_call_site       = 0;
+#endif
+
+#define likely(x)       __builtin_expect((x),1)
+#define unlikely(x)     __builtin_expect((x),0)
+
+#ifdef MVEE_DEBUG_MALLOC
+DEFINE_MVEE_QUEUE(malloc, 1);
+#endif
+
+/* MVEE PATCH:
+   Checks wether or not all variants got ALIGNMENT aligned heaps from
+   the previous mmap request. If some of them have not, ALL variants
+   have to bail out and fall back to another heap allocation method.
+   This ensures that the variants stay in sync with respect to future mm
+   requests.
+*/
+#define ALIGNMENT 0x4000000
+
+int
+mvee_all_heaps_aligned(char* heap, unsigned long alloc_size)
+{
+  // if we're not running under MVEE control,
+  // just check the alignment of the current heap
+  if (!mvee_thread_local_queue)
+  {
+      if ((unsigned long)heap & (ALIGNMENT-1))
+		  return 0;
+      return 1;
+  }
+
+  // We ARE running under MVEE control
+  // => ask the MVEE to check the alignments
+  // of ALL heaps
+  return syscall(MVEE_ALL_HEAPS_ALIGNED, heap, ALIGNMENT, alloc_size);
+}
+
+/* 
+ * mvee_infinite_loop:
+ * this function is used for both thread transfering and signal delivery 
+ * 
+ * 1) to transfer threads to a new monitor, the original monitor (i.e. the 
+ * monitor that monitors the childs that instigated the fork event) needs to
+ * detach from the threads first. While the threads are detached, they can
+ * run freely, without the intervention of a debugger.
+ * As such, we have to move the program counter to an infinite loop while
+ * the threads are detached. This way, the threads will all be in an equivalent
+ * state when the new monitor attaches to them.
+ * Because we're going to replace the registers by their original contents
+ * when the new monitor attaches, we can use sys_pause calls in the infinite
+ * loop.
+ * 
+ * 2) delivering signals through the ptrace API happens asynchronously 
+ * (I found out the hard way). As such, we should wait for the threads to be
+ * in equivalent states (e.g. stopped on the same syscall). Then the registers
+ * should be backed up and the syscall nr should be replaced by a harmless
+ * syscall that doesn't modify the program state. We use sys_getpid for this
+ * purpose. When that replaced syscall returns, we change the pc to this
+ * infinite loop while we wait for async signal delivery.
+ * We probably cannot use syscalls while waiting for signal delivery. 
+ * One possible exception is sys_sched_yield. Our modified MVEE kernel does
+ * not report this syscall to the ptracer
+ * 
+ * the with_syscalls parameter is passed through the ecx register!
+ */
+void mvee_infinite_loop(int with_syscalls, int dummy)
+{
+	if (with_syscalls)
+    {
+		for (;;)
+			syscall(__NR_pause);
+    }
+	else
+    {
+		for (;;)
+		{
+			dummy = dummy << 2;
+		}
+    }
+}
+
+/*
+ * logs a (truncated) stack into the specified "eip" buffer. This stack is logged for EVERY variant,
+ * which greatly facilitates debugging. The MVEE can dump the contents of this buffer very efficiently, 
+ * including source lines/info
+ * 
+ * Do note that __builtin_return_address() can trap (SEGV) if the entire stack contains less than
+ * MVEE_MAX_STACK_DEPTH entries. The MVEE will however trap the SEGV and if it comes from this function,
+ * the offending instruction will be skipped.
+ */
+static void __attribute__ ((noinline)) mvee_log_stack(void* eip_buffer, int eip_buffer_slot_size, volatile unsigned int* eip_buffer_pos_ptr, int start_depth)
+{
+#ifdef MVEE_LOG_EIPS
+	int entries_logged = 0;
+	int next_entry = start_depth;
+
+	while (entries_logged < MVEE_STACK_DEPTH)
+    {
+		unsigned long ret_addr = 0;
+		switch (next_entry)
+		{
+			// __builtin_* intrinics need const arguments so unfortunately, we have to do the following...
+#define DEF_CASE(x)														\
+			case x:														\
+				ret_addr = (unsigned long)__builtin_return_address(x);	\
+				break;
+			DEF_CASE(0);
+#if defined(MVEE_EXTENDED_QUEUE) && defined (MVEE_CHECK_LOCK_TYPE)
+			case 1:
+				ret_addr = (unsigned long)mvee_original_call_site;
+				break;
+#else
+			DEF_CASE(1);
+#endif
+
+#if MVEE_STACK_DEPTH > 1
+			DEF_CASE(2);
+# if MVEE_STACK_DEPTH > 2
+			DEF_CASE(3);
+#  if MVEE_STACK_DEPTH > 3
+			DEF_CASE(4);
+#   if MVEE_STACK_DEPTH > 4
+			DEF_CASE(5);
+#    if MVEE_STACK_DEPTH > 5
+			DEF_CASE(6);
+#     if MVEE_STACK_DEPTH > 6
+			DEF_CASE(7);
+#      if MVEE_STACK_DEPTH > 7
+			DEF_CASE(8);
+#       if MVEE_STACK_DEPTH > 8
+			DEF_CASE(9);
+#        if MVEE_STACK_DEPTH > 9
+			DEF_CASE(10);
+#        endif
+#       endif
+#      endif
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+		}
+		*(unsigned long*)((unsigned long)eip_buffer + 
+						  eip_buffer_slot_size * (*eip_buffer_pos_ptr) + 
+						  MVEE_STACK_DEPTH * sizeof(unsigned long) * mvee_child_num + 
+						  sizeof(unsigned long) * entries_logged) 
+			= ret_addr;
+		entries_logged++;
+		next_entry++;
+    }
+#endif
+}
+
+static void mvee_check_buffer(void)
+{
+	register unsigned short tid asm("al") = mvee_master_thread_id;
+	if (unlikely(!tid))
+    {
+		int tmp_id;
+		__asm__ volatile("int $0x80" : "=a" (tmp_id) : "0" (MVEE_GET_MASTERTHREAD_ID) : "memory", "cc");
+		mvee_master_thread_id = tmp_id;
+
+		if (!mvee_buffer_valid)
+		{
+			mvee_buffer_valid = 1;
+#ifdef MVEE_PARTIAL_ORDER_REPLICATION
+			INIT_MVEE_QUEUE(lock, MVEE_LOCK_QUEUE_SLOT_SIZE, MVEE_LIBC_LOCK_BUFFER_PARTIAL);
+#else
+			INIT_MVEE_QUEUE(lock, MVEE_LOCK_QUEUE_SLOT_SIZE, MVEE_LIBC_LOCK_BUFFER);
+#endif
+
+#ifdef MVEE_DEBUG_MALLOC
+			INIT_MVEE_QUEUE(malloc, 4*sizeof(int) + 3*sizeof(long), MVEE_LIBC_MALLOC_DEBUG_BUFFER);
+#endif
+		}
+    }
+}
+
+
+// This function is a bit tricky, especially on x86_64!
+// In some contexts, such as syscalls that enable asynchronous cancellation,
+// libc expects none of the code it executes to touch registers other than
+// %rax and %r11. Consequently, we have to make sure that at most 2 registers
+// live at any point during our mvee funcs!
+static inline int mvee_should_sync(void)
+{
+	if (unlikely(!mvee_libc_initialized))
+	{
+		long res = syscall(MVEE_RUNS_UNDER_MVEE_CONTROL, &mvee_sync_enabled, &mvee_infinite_loop, 
+						   &mvee_num_childs, &mvee_child_num, &mvee_master_variant);
+		if (!(res < 0 && res > -4095))
+			mvee_check_buffer();
+		mvee_libc_initialized = 1;
+	}
+	return mvee_sync_enabled;
+}
+
+
+int mvee_should_sync_tid(void)
+{
+	return mvee_should_sync();
+}
+
+// the buffer initialization is NOT thread-safe. Therefore, it must be initialized
+// in single threaded context!!!
+void mvee_invalidate_buffer(void)
+{
+	mvee_buffer_valid = 0;
+	mvee_master_thread_id = 0;
+}
+
+#define cpu_relax() asm volatile("rep; nop" ::: "memory")
+
+#define gcc_barrier() asm volatile("" ::: "memory")
+
+static inline unsigned int mvee_write_lock_result_prepare(void)
+{
+	while (1)
+    {
+		if (orig_atomic_decrement_and_test(mvee_lock_buffer_lock))
+			return *mvee_lock_buffer_pos;
+      
+		while (*mvee_lock_buffer_lock <= 0)
+			cpu_relax();
+    }
+
+	return *mvee_lock_buffer_pos;
+}
+
+static inline void mvee_write_lock_result_finish(void)
+{
+	gcc_barrier();
+	orig_nonatomic_increment(mvee_lock_buffer_pos);
+	*mvee_lock_buffer_lock = 1;
+}
+
+#ifdef MVEE_EXTENDED_QUEUE
+static inline void mvee_write_lock_result_write(unsigned int pos, unsigned short op_type, void* word_ptr, unsigned char is_store)
+#else
+	static inline void mvee_write_lock_result_write(unsigned int pos, void* word_ptr, unsigned char is_store)
+#endif
+{
+restart:
+	if (likely(pos < mvee_lock_buffer_slots))
+    {
+#if defined(MVEE_LOG_EIPS) && defined(MVEE_EXTENDED_QUEUE)
+		MVEE_LOG_STACK(lock, 1, &pos);
+#endif
+		gcc_barrier();
+
+#ifdef MVEE_PARTIAL_ORDER_REPLICATION
+		MVEE_LOG_QUEUE_DATA(lock, pos, 0, (unsigned long)(((unsigned long)word_ptr) | is_store));
+# ifdef MVEE_EXTENDED_QUEUE
+		MVEE_LOG_QUEUE_DATA(lock, pos, sizeof(long) + sizeof(short), op_type);
+# endif
+		MVEE_LOG_QUEUE_DATA(lock, pos, sizeof(long), ((unsigned short)mvee_master_thread_id));
+#else // MVEE_TOTAL_ORDER_REPLICATION
+# ifdef MVEE_EXTENDED_QUEUE
+		MVEE_LOG_QUEUE_DATA(lock, pos, sizeof(long), ((unsigned long)word_ptr));
+		MVEE_LOG_QUEUE_DATA(lock, pos, sizeof(short), op_type);
+# endif
+		MVEE_LOG_QUEUE_DATA(lock, pos, 0, ((unsigned short)mvee_master_thread_id));
+#endif // !MVEE_PARTIAL_ORDER_REPLICATION
+    }
+	else
+    {      
+		// we log the tid of the flushing thread into the last slot
+#ifdef MVEE_PARTIAL_ORDER_REPLICATION
+		MVEE_LOG_QUEUE_DATA(lock, pos, sizeof(long), ((unsigned short)mvee_master_thread_id));
+		syscall(MVEE_FLUSH_SHARED_BUFFER, MVEE_LIBC_LOCK_BUFFER_PARTIAL);
+#else
+		MVEE_LOG_QUEUE_DATA(lock, pos, 0, ((unsigned short)mvee_master_thread_id));
+		syscall(MVEE_FLUSH_SHARED_BUFFER, MVEE_LIBC_LOCK_BUFFER);
+#endif
+		*mvee_lock_buffer_pos = pos = 0;
+		goto restart;
+    }
+}
+
+static inline unsigned char mvee_op_is_tagged(unsigned long pos)
+{
+#ifdef MVEE_EXTENDED_QUEUE
+	unsigned short tagged;
+	MVEE_READ_QUEUE_DATA(lock, pos, sizeof(long) + sizeof(short) * (mvee_child_num + 1), tagged);
+#else
+	unsigned char tagged;
+	MVEE_READ_QUEUE_DATA(lock, pos, sizeof(long) + sizeof(short) + (mvee_child_num - 1), tagged);
+#endif
+	return tagged ? 1 : 0;
+}
+
+static inline unsigned char mvee_pos_still_valid(void)
+{
+	if (*mvee_lock_buffer_flushing || *mvee_lock_buffer_flush_cnt != mvee_prev_flush_cnt)
+		return 0;
+	return 1;
+}
+
+#ifdef MVEE_EXTENDED_QUEUE
+static inline void mvee_read_lock_result_wait(unsigned short op_type, void* word_ptr)
+#else
+static inline void mvee_read_lock_result_wait(void)
+#endif
+{
+#ifdef MVEE_PARTIAL_ORDER_REPLICATION
+	unsigned char is_store = 0;
+	unsigned char all_tagged;
+	unsigned long master_word_ptr;
+	unsigned int i;
+	unsigned int orig_pos;
+	unsigned int nextpos = 0;
+	unsigned int temppos;
+
+	while(true)
+	{
+		// STEP 1: FIND THE CORRESPONDING MASTER WORD POINTER
+		//
+		// Our algorithm relies on the fact that all replicae
+		// are semantically equivalent.
+		//
+		// Therefore, we may safely assume that the first non-tagged
+		// operation of this thread's corresponding master thread.
+		// is an operation on the same logical word.
+		//
+		// Caching:
+		// We start the search at the previously replicated operation 
+		// by this thread. The index of the previously replicated
+		// operation is stored in mvee_lock_buffer_prev_pos.
+		// It remains valid until the queue is flushed.
+		// When the queue is flushed, we increment the flush counter
+		// which is stored in the upper 4 bytes of mvee_lock_buffer_pos.
+		//
+
+		// check if the queue has been flushed since the last operation we've replicated
+		if (unlikely(*mvee_lock_buffer_flush_cnt != mvee_prev_flush_cnt))
+		{
+			// it has been flushed, update flush cnt and reset the 
+			// position of our previously replicated operation
+			mvee_prev_flush_cnt = *mvee_lock_buffer_flush_cnt;
+			mvee_lock_buffer_prev_pos = 0;
+			nextpos = 0;
+		}
+
+		temppos = *mvee_lock_buffer_pos;
+
+		// Meanwhile, some other thread _MAY_ have moved the position
+		// pointer past our previously replicated operation
+		//
+		// If so, we start the search there instead
+		orig_pos = temppos;
+		if (temppos < mvee_lock_buffer_prev_pos)
+			nextpos = mvee_lock_buffer_prev_pos;
+		else if (!nextpos)
+			nextpos = orig_pos;
+
+		master_word_ptr = 0;
+
+		for (temppos = nextpos; temppos <= mvee_lock_buffer_slots; ++temppos)
+		{
+			unsigned short tid;
+			MVEE_READ_QUEUE_DATA(lock, temppos, sizeof(long), tid);
+			// MVEE_READ_QUEUE_DATA(lock, temppos, 0, tid);
+
+			// no tid => the slaves are running ahead of the master
+			// or the master stores are not visible yet
+			if (!tid)
+			{
+				master_word_ptr = 0;
+				break;
+			}
+
+			if (tid != (unsigned short)mvee_master_thread_id || mvee_op_is_tagged(temppos))
+				continue;
+
+			// if tid is visible, then this will be too
+			MVEE_READ_QUEUE_DATA(lock, temppos, 0, master_word_ptr);
+			if (master_word_ptr & 1)
+				is_store = 1;
+			master_word_ptr &= ~(sizeof(long) - 1);
+
+			// this will only happen if we're at the end of the queue
+			// at which point we log a pseudo-operation with master_word_ptr == 0
+			if (!master_word_ptr)
+			{
+				if (temppos == mvee_lock_buffer_slots)
+				{
+					while (true)
+					{
+						all_tagged = 1;
+
+						for (temppos = orig_pos; temppos < mvee_lock_buffer_slots; ++temppos)
+						{		    
+							if (!mvee_op_is_tagged(temppos))
+							{
+								all_tagged = 0;
+								orig_pos = temppos;
+								break;
+							}
+						}
+
+						if (!all_tagged)
+							syscall(__NR_sched_yield);
+						else
+							break;
+					}
+
+					*mvee_lock_buffer_flushing = 1;
+					atomic_full_barrier();
+
+					syscall(MVEE_FLUSH_SHARED_BUFFER, MVEE_LIBC_LOCK_BUFFER_PARTIAL);
+
+#ifdef MVEE_EXTENDED_QUEUE
+					mvee_op_number = 1;
+#endif
+
+					*mvee_lock_buffer_pos = 0;
+					atomic_full_barrier();
+					*mvee_lock_buffer_flush_cnt = (++mvee_prev_flush_cnt);
+					*mvee_lock_buffer_flushing = 0;
+
+					temppos = mvee_lock_buffer_prev_pos = 0;
+					break;
+				}
+
+				// we could also see a NULLed out master_word_ptr if another thread is flushing
+				temppos = mvee_lock_buffer_prev_pos = 0;
+				break;
+			}
+
+			// a weird corner case could happen here.
+			// it is possible that by the time we get here, some other thread has flushed and the master
+			// thread has caught up with us again. In other words,
+			// we MIGHT have missed a complete flush cycle
+			//
+			// => we need to check if our data is still valid!!!
+			if (!mvee_pos_still_valid())
+			{
+				master_word_ptr = 0;
+				break;
+			}
+
+#if defined(MVEE_EXTENDED_QUEUE) && defined(MVEE_CHECK_LOCK_TYPE)
+			unsigned short master_op_type;
+			MVEE_READ_QUEUE_DATA(lock, temppos, sizeof(long) + sizeof(short), master_op_type);
+
+			if (master_op_type != op_type && mvee_pos_still_valid())
+			{
+#  ifdef MVEE_LOG_EIPS
+				MVEE_LOG_STACK(lock, 1, &temppos);
+#  endif
+
+				syscall(__NR_gettid, 1337, 10000001, 60, mvee_lock_buffer_slot_size, temppos);
+				syscall(__NR_gettid, 1337, 10000001, 59, master_op_type, op_type);
+				return;
+			}
+
+			if (master_word_ptr != ((unsigned long)word_ptr & ~(sizeof(long) - 1)) && mvee_pos_still_valid())
+			{
+#  ifdef MVEE_LOG_EIPS
+				MVEE_LOG_STACK(lock, 1, &temppos);
+#  endif
+
+				syscall(__NR_gettid, 1337, 10000001, 61, word_ptr, temppos);
+			}
+#endif
+
+			break;
+		}
+
+		if (master_word_ptr)
+			break;
+
+		// if we get to this point, it means that the slave 
+		// has caught up with the master
+		// => we restart the iteration but this time
+		// we start at the position we were at
+		nextpos = temppos;
+		syscall(__NR_sched_yield);
+	}
+
+	// STEP 2: FIND PRECEDING OPERATIONS ON THIS LOCATION
+	// 
+	// Rules:
+	// * Stores can continue if all preceding loads and stores
+	// have been replicated
+	// * Loads can continue if all preceding stores 
+	// have been replicated
+	//
+	unsigned char seen_preceding_op = 1;
+	while (seen_preceding_op)
+    {
+		seen_preceding_op = 0;
+		for (i = orig_pos; i < temppos; ++i)
+		{
+			unsigned long temp_word_ptr;
+			MVEE_READ_QUEUE_DATA(lock, i, 0, temp_word_ptr);
+
+			// check if the results are being logged out of order
+			if (!temp_word_ptr)
+			{
+				seen_preceding_op = 1;
+				orig_pos = i;
+				break;
+			}
+
+			if ((temp_word_ptr & ~(sizeof(long) - 1)) == master_word_ptr)
+			{
+				if (is_store || (temp_word_ptr & (sizeof(long) - 1)))
+				{
+					if (!mvee_op_is_tagged(i))
+					{
+						seen_preceding_op = 1;
+						orig_pos = i;
+						break;
+					}
+				}
+			}
+		}
+
+		// We haven't seen a preceding operation that must be completed
+		// before this one
+		if (!seen_preceding_op)
+		{
+			mvee_lock_buffer_prev_pos = temppos;
+			break;
+		}
+
+		syscall(__NR_sched_yield);
+    } 
+ 
+#ifdef MVEE_LOG_EIPS
+	MVEE_LOG_STACK(lock, 1, &temppos);
+#endif
+
+#else
+
+	while (true)
+    {
+		int temppos = *(volatile int*)mvee_lock_buffer_pos;
+      
+		if (temppos < mvee_lock_buffer_slots)
+		{
+			unsigned short tid, type;
+
+			MVEE_READ_QUEUE_DATA(lock, temppos, 0, tid);
+			if (tid == (unsigned short)mvee_master_thread_id)
+			{
+# if defined(MVEE_EXTENDED_QUEUE) && defined(MVEE_CHECK_LOCK_TYPE)
+	      
+				MVEE_READ_QUEUE_DATA(lock, temppos, sizeof(short), type);
+
+				if (type != op_type)
+				{
+#  ifdef MVEE_LOG_EIPS
+					MVEE_LOG_STACK(lock, 1, &temppos);
+#  endif
+					syscall(__NR_gettid, 1337, 10000001, 60, mvee_lock_buffer_slot_size, temppos);
+					syscall(__NR_gettid, 1337, 10000001, 59, type, op_type);
+				}
+# endif
+				break;
+			}
+
+			syscall(__NR_sched_yield);
+		}
+		else
+		{
+			// we have to flush... figure out which thread does the flush
+			unsigned short tid;
+			MVEE_READ_QUEUE_DATA(lock, temppos, 0, tid);
+
+			if (tid == (unsigned short)mvee_master_thread_id)
+			{
+				// we should do it...
+				syscall(MVEE_FLUSH_SHARED_BUFFER, MVEE_LIBC_LOCK_BUFFER);
+				*mvee_lock_buffer_pos = 0;
+			}
+			else if (!tid)
+			{
+				// we don't know who should do it yet. wait for more info
+				while (temppos >= mvee_lock_buffer_slots && 
+					   !tid)
+				{
+					cpu_relax();
+					temppos = *(volatile int*)mvee_lock_buffer_pos;
+					MVEE_READ_QUEUE_DATA(lock, temppos, 0, tid);					
+				}
+			}
+			else
+			{
+				// some other thread should do it. wait for the flush
+				while (*mvee_lock_buffer_pos >= mvee_lock_buffer_slots)
+					syscall(__NR_sched_yield);
+			}
+		}
+    }
+#endif
+}
+
+static inline void mvee_read_lock_result_wake(void)
+{
+#ifdef MVEE_EXTENDED_QUEUE
+	int pos;
+
+# ifdef MVEE_PARTIAL_ORDER_REPLICATION
+	pos = mvee_lock_buffer_prev_pos;
+# else
+	pos = *mvee_lock_buffer_pos;
+# endif
+
+# ifdef MVEE_LOG_EIPS
+//	MVEE_LOG_STACK(lock, 1, &pos);
+# endif
+
+	// check call site, should be ASLR proof
+# ifdef MVEE_CHECK_LOCK_TYPE
+#  ifdef MVEE_LOG_EIPS
+	unsigned long parent_eip = *(unsigned long*)((unsigned long)mvee_lock_eip_buffer + sizeof(unsigned long)*MVEE_STACK_DEPTH*mvee_num_childs * pos);
+	unsigned long our_eip = (unsigned long)mvee_original_call_site;
+
+	//  if (parent_eip != our_eip)
+	if (parent_eip != our_eip)
+#  endif
+    {
+		unsigned short lock_type;
+#  ifdef MVEE_PARTIAL_ORDER_REPLICATION
+		MVEE_READ_QUEUE_DATA(lock, pos, sizeof(long) + sizeof(short), lock_type);
+#  else
+		MVEE_READ_QUEUE_DATA(lock, pos, sizeof(short), lock_type);
+#  endif
+#  ifdef MVEE_LOG_EIPS
+		syscall(__NR_gettid, 1337, 10000001, 90, lock_type, parent_eip, our_eip);
+#  endif
+    }
+# endif // !MVEE_CHECK_LOCK_TYPE
+
+#endif // !MVEE_EXTENDED_QUEUE
+
+#ifdef MVEE_PARTIAL_ORDER_REPLICATION
+	// see if we can move the position pointer
+	unsigned int orig_pos = *mvee_lock_buffer_pos;
+	if (!mvee_pos_still_valid())
+		return;
+
+	for (unsigned int i = orig_pos; i < mvee_lock_buffer_slots; ++i)
+    {
+		if (!mvee_op_is_tagged(i) && i != mvee_lock_buffer_prev_pos)
+		{
+			// if it looks like we're able to move the position pointer, 
+			// attempt to do so with a CAS. Again, keep in mind that this
+			// operation might happen at the same time as a flush from another thread
+			// => check if the original pos pointer is still in place
+			// If not, another thread has either increased the pos or has flushed => bail out
+			// If yes, the flushing thread will just need an extra iteration to flush
+			//
+			// we cannot use a regular store here since that might cause us to not flush!
+			// i.e. some thread might move us to the last position, which will cause the next atomic op to flush first
+			// but some other thread might move use back!
+			if (i > orig_pos)
+				__sync_bool_compare_and_swap(mvee_lock_buffer_pos, orig_pos, i);
+			break;
+		}
+    }
+
+	// now tag the slot
+  
+# ifdef MVEE_EXTENDED_QUEUE
+	//  unsigned short tag = __sync_fetch_and_add(&mvee_op_number, 1);
+	unsigned short tag = 1;
+	MVEE_LOG_QUEUE_DATA(lock, mvee_lock_buffer_prev_pos, sizeof(long) + sizeof(short) * (mvee_child_num + 1), tag);
+# else  
+	unsigned char tag = 1;
+	MVEE_LOG_QUEUE_DATA(lock, mvee_lock_buffer_prev_pos, sizeof(long) + sizeof(short) + (mvee_child_num - 1), tag);
+# endif
+
+#else // MVEE_TOTAL_ORDER_REPLICATION
+    (*mvee_lock_buffer_pos)++;
+#endif // !MVEE_PARTIAL_ORDER_REPLICATION
+}
+
+#ifdef MVEE_EXTENDED_QUEUE
+unsigned char mvee_atomic_preop_internal(unsigned char is_store, void* word_ptr, unsigned short op_type)
+#else
+	unsigned char mvee_atomic_preop_internal(unsigned char is_store, void* word_ptr)
+#endif
+{
+	if (unlikely(!mvee_should_sync()))
+		return 0;
+	mvee_check_buffer();
+#if defined(MVEE_EXTENDED_QUEUE) && defined(MVEE_CHECK_LOCK_TYPE)
+	if (!mvee_original_call_site)
+		mvee_original_call_site = (unsigned long)__builtin_return_address(0);
+#endif
+	if (likely(mvee_master_variant))
+    {
+		unsigned int pos = mvee_write_lock_result_prepare();
+#ifdef MVEE_EXTENDED_QUEUE
+		mvee_write_lock_result_write(pos, op_type, word_ptr, is_store);
+#else
+		mvee_write_lock_result_write(pos, word_ptr, is_store);
+#endif
+		return 1;
+    }
+	else
+    {
+#ifdef MVEE_EXTENDED_QUEUE
+		mvee_read_lock_result_wait(op_type, word_ptr);
+#else
+		mvee_read_lock_result_wait();
+#endif
+		return 2;
+    }
+}
+
+void mvee_atomic_postop_internal(unsigned char preop_result)
+{
+	if(likely(preop_result) == 1)
+		mvee_write_lock_result_finish();
+	else if (likely(preop_result) == 2)
+		mvee_read_lock_result_wake();
+#if defined(MVEE_EXTENDED_QUEUE) && defined(MVEE_CHECK_LOCK_TYPE)		
+	mvee_original_call_site = 0;
+#endif   
+}
+
+unsigned char mvee_atomic_preop(unsigned short op_type, void* word_ptr)
+{
+#ifdef MVEE_EXTENDED_QUEUE
+# ifdef MVEE_CHECK_LOCK_TYPE
+	mvee_original_call_site = (unsigned long)__builtin_return_address(0);
+# endif
+	return mvee_atomic_preop_internal(op_type > mvee_atomic_load ? 1 : 0, word_ptr, op_type + __MVEE_BASE_ATOMICS_MAX__);
+#else
+	return mvee_atomic_preop_internal(op_type > mvee_atomic_load ? 1 : 0, word_ptr);
+#endif
+}
+
+void mvee_atomic_postop(unsigned char preop_result)
+{
+	mvee_atomic_postop_internal(preop_result);
+}
+
+
+#ifdef MVEE_DEBUG_MALLOC
+void mvee_malloc_hook(int alloc_type, int msg, long chunksize, void* ar_ptr, void* chunk_ptr)
+{
+	if (mvee_num_childs)
+    {
+		mvee_check_buffer();
+		if (mvee_master_variant)
+			mvee_write_malloc_info(alloc_type, msg, chunksize, ar_ptr, chunk_ptr);
+		else
+			mvee_verify_malloc_info(alloc_type, msg, chunksize, ar_ptr, chunk_ptr);
+    }
+}
+
+void mvee_write_malloc_info(int alloc_type, int msg, long chunksize, void* ar_ptr, void* chunk_ptr)
+{
+	while (1)
+    {
+		if (orig_atomic_decrement_and_test(mvee_malloc_buffer_lock))
+			break;
+      
+		while (*mvee_lock_buffer_lock <= 0)
+			cpu_relax();
+    }
+
+	unsigned int pos = *mvee_malloc_buffer_pos;
+
+	MVEE_LOG_QUEUE_DATA(malloc, pos, 4*sizeof(int) + 2 * sizeof(long), (unsigned long)chunk_ptr);
+	MVEE_LOG_QUEUE_DATA(malloc, pos, 4*sizeof(int) +     sizeof(long), (unsigned long)ar_ptr);
+	MVEE_LOG_QUEUE_DATA(malloc, pos, 4*sizeof(int)                   , chunksize);
+	MVEE_LOG_QUEUE_DATA(malloc, pos, 3*sizeof(int)                   , msg);
+	MVEE_LOG_QUEUE_DATA(malloc, pos, 2*sizeof(int)                   , alloc_type);
+
+	MVEE_LOG_STACK(malloc, 1, mvee_malloc_buffer_pos);
+
+	MVEE_LOG_QUEUE_DATA(malloc, pos, 0, mvee_master_thread_id);
+
+	gcc_barrier();
+	if (++(*mvee_malloc_buffer_pos) >= mvee_malloc_buffer_slots)
+    {
+		syscall(MVEE_FLUSH_SHARED_BUFFER, MVEE_LIBC_MALLOC_DEBUG_BUFFER);
+		*mvee_malloc_buffer_pos = 0;
+    }
+
+	*mvee_malloc_buffer_lock = 1;
+}
+
+struct mvee_malloc_error
+{
+  int alloc_type, msg;
+  long chunksize;
+  void* ar_ptr, * chunk_ptr;
+};
+
+void mvee_verify_malloc_info(int alloc_type, int msg, long chunksize, void* ar_ptr, void* chunk_ptr)
+{
+	unsigned int prevpos = 0;
+	int master_alloc_type, master_msg;
+	long master_chunksize;
+	void* master_ar_ptr, * master_chunk_ptr;
+
+	while (true)
+    {
+		volatile unsigned int temppos = *mvee_malloc_buffer_pos;
+
+		if (temppos < mvee_malloc_buffer_slots)
+		{
+			int tid;
+			MVEE_READ_QUEUE_DATA(malloc, temppos, 0, tid);
+			if (tid == mvee_master_thread_id)
+			{
+				MVEE_READ_QUEUE_DATA(malloc, temppos, 2*sizeof(int), master_alloc_type);
+				MVEE_READ_QUEUE_DATA(malloc, temppos, 3*sizeof(int), master_msg);
+				MVEE_READ_QUEUE_DATA(malloc, temppos, 4*sizeof(int), master_chunksize);
+				MVEE_READ_QUEUE_DATA(malloc, temppos, 4*sizeof(int)+sizeof(long), master_ar_ptr);
+				MVEE_READ_QUEUE_DATA(malloc, temppos, 4*sizeof(int)+2*sizeof(long), master_chunk_ptr);
+				MVEE_LOG_STACK(malloc, 1, mvee_malloc_buffer_pos);
+	      
+				if (alloc_type != master_alloc_type
+					|| msg != master_msg
+					|| chunksize != master_chunksize
+#ifndef MVEE_MALLOC_IGNORE_ASLR
+					|| ar_ptr != master_ar_ptr
+					|| chunk_ptr != master_chunk_ptr
+#endif
+					)
+				{
+					struct mvee_malloc_error err;
+					err.alloc_type = master_alloc_type;
+					err.msg = master_msg;
+					err.chunksize = master_chunksize;
+					err.ar_ptr = master_ar_ptr;
+					err.chunk_ptr = master_chunk_ptr;
+					syscall(__NR_gettid, 1337, 10000001, 74, &err);
+		  
+					err.alloc_type = alloc_type;
+					err.msg = msg;
+					err.chunksize = chunksize;
+					err.ar_ptr = ar_ptr;
+					err.chunk_ptr = chunk_ptr;
+					syscall(__NR_gettid, 1337, 10000001, 75, &err);
+				}
+				break;
+			}
+		}
+    }
+
+	if (*mvee_malloc_buffer_pos +1 >= mvee_malloc_buffer_slots)
+    {
+		syscall(MVEE_FLUSH_SHARED_BUFFER, MVEE_LIBC_MALLOC_DEBUG_BUFFER);
+		*mvee_malloc_buffer_pos = 0;
+    }
+	else
+		(*mvee_malloc_buffer_pos)++;
+}
+
+#endif // !MVEE_DEBUG_MALLOC
+
+#endif
+
+
 STATIC int LIBC_START_MAIN (int (*main) (int, char **, char **
 					 MAIN_AUXVEC_DECL),
 			    int argc,
diff -N -r --unified glibc-2.19/csu/Versions glibc-2.19-totalpartial/csu/Versions
--- glibc-2.19/csu/Versions	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/csu/Versions	2017-03-04 01:35:20.345744068 -0800
@@ -4,6 +4,13 @@
   GLIBC_2.0 {
     # helper functions
     __libc_init_first; __libc_start_main;
+    mvee_atomic_preop;
+    mvee_atomic_postop;
+    mvee_atomic_preop_internal;
+    mvee_atomic_postop_internal;
+    mvee_invalidate_buffer;
+    mvee_all_heaps_aligned;
+    mvee_should_sync_tid;
   }
   GLIBC_2.1 {
     # New special glibc functions.
diff -N -r --unified glibc-2.19/inet/getnetgrent_r.c glibc-2.19-totalpartial/inet/getnetgrent_r.c
--- glibc-2.19/inet/getnetgrent_r.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/inet/getnetgrent_r.c	2017-03-04 01:35:20.345744068 -0800
@@ -50,7 +50,7 @@
   static service_user *startp;
   int no_more;
 
-  if (!startp_initialized)
+  if (!atomic_load(startp_initialized))
     {
       /* Executing this more than once at the same time must yield the
 	 same result every time.  So we need no locking.  */
@@ -60,7 +60,7 @@
       PTR_MANGLE (startp);
 #endif
       atomic_write_barrier ();
-      startp_initialized = true;
+      atomic_store(startp_initialized, true);
     }
   else
     {
diff -N -r --unified glibc-2.19/intl/Makefile glibc-2.19-totalpartial/intl/Makefile
--- glibc-2.19/intl/Makefile	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/intl/Makefile	2017-03-09 18:15:19.512950488 -0800
@@ -41,6 +41,15 @@
 generated-dirs := domaindir localedir
 
 ifneq (no,$(BISON))
+BISONVERGT2 := $(shell expr `bison -V | grep ^bison | sed 's/^.* //' | cut -f1 -d.` \> 2)
+plural.y: plural2.y plural3.y
+ifeq (0,$(BISONVERGT2))
+	cp plural2.y plural.y
+	cp plural-exp2.h plural-exp.h
+else
+	cp plural3.y plural.y
+	cp plural-exp3.h plural-exp.h
+endif
 plural.c: plural.y
 	$(BISON) $(BISONFLAGS) $@ $^
 endif
diff -N -r --unified glibc-2.19/intl/plural2.y glibc-2.19-totalpartial/intl/plural2.y
--- glibc-2.19/intl/plural2.y	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.19-totalpartial/intl/plural2.y	2017-03-04 01:34:56.677742470 -0800
@@ -0,0 +1,409 @@
+%{
+/* Expression parsing for plural form selection.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* The bison generated parser uses alloca.  AIX 3 forces us to put this
+   declaration at the beginning of the file.  The declaration in bison's
+   skeleton file comes too late.  This must come before <config.h>
+   because <config.h> may include arbitrary system headers.  */
+#if defined _AIX && !defined __GNUC__
+ #pragma alloca
+#endif
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include "plural-exp.h"
+
+/* The main function generated by the parser is called __gettextparse,
+   but we want it to be called PLURAL_PARSE.  */
+#ifndef _LIBC
+# define __gettextparse PLURAL_PARSE
+#endif
+
+#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
+#define YYPARSE_PARAM	arg
+%}
+%pure_parser
+%expect 7
+
+%union {
+  unsigned long int num;
+  enum operator op;
+  struct expression *exp;
+}
+
+%{
+/* Prototypes for local functions.  */
+static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+					   struct expression * const *args));
+static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+						   struct expression *right));
+static struct expression *new_exp_2 PARAMS ((enum operator op,
+					     struct expression *left,
+					     struct expression *right));
+static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+						   struct expression *bexp,
+						   struct expression *tbranch,
+						   struct expression *fbranch));
+static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
+static void yyerror PARAMS ((const char *str));
+
+/* Allocation of expressions.  */
+
+static struct expression *
+new_exp (nargs, op, args)
+     int nargs;
+     enum operator op;
+     struct expression * const *args;
+{
+  int i;
+  struct expression *newp;
+
+  /* If any of the argument could not be malloc'ed, just return NULL.  */
+  for (i = nargs - 1; i >= 0; i--)
+    if (args[i] == NULL)
+      goto fail;
+
+  /* Allocate a new expression.  */
+  newp = (struct expression *) malloc (sizeof (*newp));
+  if (newp != NULL)
+    {
+      newp->nargs = nargs;
+      newp->operation = op;
+      for (i = nargs - 1; i >= 0; i--)
+	newp->val.args[i] = args[i];
+      return newp;
+    }
+
+ fail:
+  for (i = nargs - 1; i >= 0; i--)
+    FREE_EXPRESSION (args[i]);
+
+  return NULL;
+}
+
+static inline struct expression *
+new_exp_0 (op)
+     enum operator op;
+{
+  return new_exp (0, op, NULL);
+}
+
+static inline struct expression *
+new_exp_1 (op, right)
+     enum operator op;
+     struct expression *right;
+{
+  struct expression *args[1];
+
+  args[0] = right;
+  return new_exp (1, op, args);
+}
+
+static struct expression *
+new_exp_2 (op, left, right)
+     enum operator op;
+     struct expression *left;
+     struct expression *right;
+{
+  struct expression *args[2];
+
+  args[0] = left;
+  args[1] = right;
+  return new_exp (2, op, args);
+}
+
+static inline struct expression *
+new_exp_3 (op, bexp, tbranch, fbranch)
+     enum operator op;
+     struct expression *bexp;
+     struct expression *tbranch;
+     struct expression *fbranch;
+{
+  struct expression *args[3];
+
+  args[0] = bexp;
+  args[1] = tbranch;
+  args[2] = fbranch;
+  return new_exp (3, op, args);
+}
+
+%}
+
+/* This declares that all operators have the same associativity and the
+   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].
+   There is no unary minus and no bitwise operators.
+   Operators with the same syntactic behaviour have been merged into a single
+   token, to save space in the array generated by bison.  */
+%right '?'		/*   ?		*/
+%left '|'		/*   ||		*/
+%left '&'		/*   &&		*/
+%left EQUOP2		/*   == !=	*/
+%left CMPOP2		/*   < > <= >=	*/
+%left ADDOP2		/*   + -	*/
+%left MULOP2		/*   * / %	*/
+%right '!'		/*   !		*/
+
+%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2
+%token <num> NUMBER
+%type <exp> exp
+
+%%
+
+start:	  exp
+	  {
+	    if ($1 == NULL)
+	      YYABORT;
+	    ((struct parse_args *) arg)->res = $1;
+	  }
+	;
+
+exp:	  exp '?' exp ':' exp
+	  {
+	    $$ = new_exp_3 (qmop, $1, $3, $5);
+	  }
+	| exp '|' exp
+	  {
+	    $$ = new_exp_2 (lor, $1, $3);
+	  }
+	| exp '&' exp
+	  {
+	    $$ = new_exp_2 (land, $1, $3);
+	  }
+	| exp EQUOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp CMPOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp ADDOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp MULOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| '!' exp
+	  {
+	    $$ = new_exp_1 (lnot, $2);
+	  }
+	| 'n'
+	  {
+	    $$ = new_exp_0 (var);
+	  }
+	| NUMBER
+	  {
+	    if (($$ = new_exp_0 (num)) != NULL)
+	      $$->val.num = $1;
+	  }
+	| '(' exp ')'
+	  {
+	    $$ = $2;
+	  }
+	;
+
+%%
+
+void
+internal_function
+FREE_EXPRESSION (exp)
+     struct expression *exp;
+{
+  if (exp == NULL)
+    return;
+
+  /* Handle the recursive case.  */
+  switch (exp->nargs)
+    {
+    case 3:
+      FREE_EXPRESSION (exp->val.args[2]);
+      /* FALLTHROUGH */
+    case 2:
+      FREE_EXPRESSION (exp->val.args[1]);
+      /* FALLTHROUGH */
+    case 1:
+      FREE_EXPRESSION (exp->val.args[0]);
+      /* FALLTHROUGH */
+    default:
+      break;
+    }
+
+  free (exp);
+}
+
+
+static int
+yylex (lval, pexp)
+     YYSTYPE *lval;
+     const char **pexp;
+{
+  const char *exp = *pexp;
+  int result;
+
+  while (1)
+    {
+      if (exp[0] == '\0')
+	{
+	  *pexp = exp;
+	  return YYEOF;
+	}
+
+      if (exp[0] != ' ' && exp[0] != '\t')
+	break;
+
+      ++exp;
+    }
+
+  result = *exp++;
+  switch (result)
+    {
+    case '0': case '1': case '2': case '3': case '4':
+    case '5': case '6': case '7': case '8': case '9':
+      {
+	unsigned long int n = result - '0';
+	while (exp[0] >= '0' && exp[0] <= '9')
+	  {
+	    n *= 10;
+	    n += exp[0] - '0';
+	    ++exp;
+	  }
+	lval->num = n;
+	result = NUMBER;
+      }
+      break;
+
+    case '=':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = equal;
+	  result = EQUOP2;
+	}
+      else
+	result = YYERRCODE;
+      break;
+
+    case '!':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = not_equal;
+	  result = EQUOP2;
+	}
+      break;
+
+    case '&':
+    case '|':
+      if (exp[0] == result)
+	++exp;
+      else
+	result = YYERRCODE;
+      break;
+
+    case '<':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = less_or_equal;
+	}
+      else
+	lval->op = less_than;
+      result = CMPOP2;
+      break;
+
+    case '>':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = greater_or_equal;
+	}
+      else
+	lval->op = greater_than;
+      result = CMPOP2;
+      break;
+
+    case '*':
+      lval->op = mult;
+      result = MULOP2;
+      break;
+
+    case '/':
+      lval->op = divide;
+      result = MULOP2;
+      break;
+
+    case '%':
+      lval->op = module;
+      result = MULOP2;
+      break;
+
+    case '+':
+      lval->op = plus;
+      result = ADDOP2;
+      break;
+
+    case '-':
+      lval->op = minus;
+      result = ADDOP2;
+      break;
+
+    case 'n':
+    case '?':
+    case ':':
+    case '(':
+    case ')':
+      /* Nothing, just return the character.  */
+      break;
+
+    case ';':
+    case '\n':
+    case '\0':
+      /* Be safe and let the user call this function again.  */
+      --exp;
+      result = YYEOF;
+      break;
+
+    default:
+      result = YYERRCODE;
+#if YYDEBUG != 0
+      --exp;
+#endif
+      break;
+    }
+
+  *pexp = exp;
+
+  return result;
+}
+
+
+static void
+yyerror (str)
+     const char *str;
+{
+  /* Do nothing.  We don't print error messages here.  */
+}
diff -N -r --unified glibc-2.19/intl/plural3.y glibc-2.19-totalpartial/intl/plural3.y
--- glibc-2.19/intl/plural3.y	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.19-totalpartial/intl/plural3.y	2017-03-09 18:16:52.086956736 -0800
@@ -0,0 +1,409 @@
+%{
+/* Expression parsing for plural form selection.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* The bison generated parser uses alloca.  AIX 3 forces us to put this
+   declaration at the beginning of the file.  The declaration in bison's
+   skeleton file comes too late.  This must come before <config.h>
+   because <config.h> may include arbitrary system headers.  */
+#if defined _AIX && !defined __GNUC__
+ #pragma alloca
+#endif
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include "plural-exp.h"
+
+/* The main function generated by the parser is called __gettextparse,
+   but we want it to be called PLURAL_PARSE.  */
+#ifndef _LIBC
+# define __gettextparse PLURAL_PARSE
+#endif
+	%}
+%param {struct parse_args *arg}
+%define api.pure full
+%expect 7
+
+%union {
+	unsigned long int num;
+	enum operator op;
+	struct expression *exp;
+}
+
+%{
+/* Prototypes for local functions.  */
+	static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+											   struct expression * const *args));
+	static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+	static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+														struct expression *right));
+	static struct expression *new_exp_2 PARAMS ((enum operator op,
+												 struct expression *left,
+												 struct expression *right));
+	static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+														struct expression *bexp,
+														struct expression *tbranch,
+														struct expression *fbranch));
+	static int yylex PARAMS ((YYSTYPE *lval, struct parse_args *arg));
+	static void yyerror PARAMS ((struct parse_args *arg, const char *str));
+
+/* Allocation of expressions.  */
+
+static struct expression *
+	new_exp (nargs, op, args)
+	int nargs;
+enum operator op;
+struct expression * const *args;
+{
+	int i;
+	struct expression *newp;
+
+	/* If any of the argument could not be malloc'ed, just return NULL.  */
+	for (i = nargs - 1; i >= 0; i--)
+		if (args[i] == NULL)
+			goto fail;
+
+	/* Allocate a new expression.  */
+	newp = (struct expression *) malloc (sizeof (*newp));
+	if (newp != NULL)
+    {
+		newp->nargs = nargs;
+		newp->operation = op;
+		for (i = nargs - 1; i >= 0; i--)
+			newp->val.args[i] = args[i];
+		return newp;
+    }
+
+fail:
+	for (i = nargs - 1; i >= 0; i--)
+		FREE_EXPRESSION (args[i]);
+
+	return NULL;
+}
+
+static inline struct expression *
+	new_exp_0 (op)
+	enum operator op;
+{
+	return new_exp (0, op, NULL);
+}
+
+static inline struct expression *
+	new_exp_1 (op, right)
+	enum operator op;
+struct expression *right;
+{
+	struct expression *args[1];
+
+	args[0] = right;
+	return new_exp (1, op, args);
+}
+
+static struct expression *
+	new_exp_2 (op, left, right)
+	enum operator op;
+struct expression *left;
+struct expression *right;
+{
+	struct expression *args[2];
+
+	args[0] = left;
+	args[1] = right;
+	return new_exp (2, op, args);
+}
+
+static inline struct expression *
+	new_exp_3 (op, bexp, tbranch, fbranch)
+	enum operator op;
+struct expression *bexp;
+struct expression *tbranch;
+struct expression *fbranch;
+{
+	struct expression *args[3];
+
+	args[0] = bexp;
+	args[1] = tbranch;
+	args[2] = fbranch;
+	return new_exp (3, op, args);
+}
+
+%}
+
+/* This declares that all operators have the same associativity and the
+   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].
+   There is no unary minus and no bitwise operators.
+   Operators with the same syntactic behaviour have been merged into a single
+   token, to save space in the array generated by bison.  */
+%right '?'/*   ?*/
+%left '|'/*   ||*/
+%left '&'/*   &&*/
+%left EQUOP2/*   == !=*/
+%left CMPOP2/*   < > <= >=*/
+%left ADDOP2/*   + -*/
+%left MULOP2/*   * / %*/
+%right '!'/*   !*/
+
+%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2
+%token <num> NUMBER
+%type <exp> exp
+
+%%
+
+start:  exp
+{
+	if ($1 == NULL)
+		YYABORT;
+	arg->res = $1;
+}
+;
+
+exp:  exp '?' exp ':' exp
+{
+	$$ = new_exp_3 (qmop, $1, $3, $5);
+}
+| exp '|' exp
+{
+	$$ = new_exp_2 (lor, $1, $3);
+}
+| exp '&' exp
+{
+	$$ = new_exp_2 (land, $1, $3);
+}
+| exp EQUOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| exp CMPOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| exp ADDOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| exp MULOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| '!' exp
+{
+	$$ = new_exp_1 (lnot, $2);
+}
+| 'n'
+{
+	$$ = new_exp_0 (var);
+}
+| NUMBER
+{
+	if (($$ = new_exp_0 (num)) != NULL)
+		$$->val.num = $1;
+}
+| '(' exp ')'
+{
+	$$ = $2;
+}
+;
+
+%%
+
+void
+internal_function
+FREE_EXPRESSION (exp)
+struct expression *exp;
+{
+	if (exp == NULL)
+		return;
+
+	/* Handle the recursive case.  */
+	switch (exp->nargs)
+    {
+		case 3:
+			FREE_EXPRESSION (exp->val.args[2]);
+			/* FALLTHROUGH */
+		case 2:
+			FREE_EXPRESSION (exp->val.args[1]);
+			/* FALLTHROUGH */
+		case 1:
+			FREE_EXPRESSION (exp->val.args[0]);
+			/* FALLTHROUGH */
+		default:
+			break;
+    }
+
+	free (exp);
+}
+
+
+static int
+yylex (lval, arg)
+YYSTYPE *lval;
+struct parse_args *arg;
+{
+	const char *exp = arg->cp;
+	int result;
+
+	while (1)
+    {
+		if (exp[0] == '\0')
+		{
+			arg->cp = exp;
+			return YYEOF;
+		}
+
+		if (exp[0] != ' ' && exp[0] != '\t')
+			break;
+
+		++exp;
+    }
+
+	result = *exp++;
+	switch (result)
+    {
+		case '0': case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+		{
+			unsigned long int n = result - '0';
+			while (exp[0] >= '0' && exp[0] <= '9')
+			{
+				n *= 10;
+				n += exp[0] - '0';
+				++exp;
+			}
+			lval->num = n;
+			result = NUMBER;
+		}
+		break;
+
+		case '=':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = equal;
+				result = EQUOP2;
+			}
+			else
+				result = YYERRCODE;
+			break;
+
+		case '!':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = not_equal;
+				result = EQUOP2;
+			}
+			break;
+
+		case '&':
+		case '|':
+			if (exp[0] == result)
+				++exp;
+			else
+				result = YYERRCODE;
+			break;
+
+		case '<':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = less_or_equal;
+			}
+			else
+				lval->op = less_than;
+			result = CMPOP2;
+			break;
+
+		case '>':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = greater_or_equal;
+			}
+			else
+				lval->op = greater_than;
+			result = CMPOP2;
+			break;
+
+		case '*':
+			lval->op = mult;
+			result = MULOP2;
+			break;
+
+		case '/':
+			lval->op = divide;
+			result = MULOP2;
+			break;
+
+		case '%':
+			lval->op = module;
+			result = MULOP2;
+			break;
+
+		case '+':
+			lval->op = plus;
+			result = ADDOP2;
+			break;
+
+		case '-':
+			lval->op = minus;
+			result = ADDOP2;
+			break;
+
+		case 'n':
+		case '?':
+		case ':':
+		case '(':
+		case ')':
+			/* Nothing, just return the character.  */
+			break;
+
+		case ';':
+		case '\n':
+		case '\0':
+			/* Be safe and let the user call this function again.  */
+			--exp;
+			result = YYEOF;
+			break;
+
+		default:
+			result = YYERRCODE;
+#if YYDEBUG != 0
+			--exp;
+#endif
+			break;
+    }
+
+	arg->cp = exp; 
+
+	return result;
+}
+
+
+static void
+yyerror (arg, str)
+struct parse_args *arg;
+const char *str;
+{
+	/* Do nothing.  We don't print error messages here.  */
+}
diff -N -r --unified glibc-2.19/intl/plural.c glibc-2.19-totalpartial/intl/plural.c
--- glibc-2.19/intl/plural.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/intl/plural.c	2017-03-09 18:17:24.273958908 -0800
@@ -1,8 +1,8 @@
-/* A Bison parser, made by GNU Bison 2.7.  */
+/* A Bison parser, made by GNU Bison 3.0.2.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
-      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989-1990, 2000-2013 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -44,13 +44,13 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.7"
+#define YYBISON_VERSION "3.0.2"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
 
 /* Pure parsers.  */
-#define YYPURE 1
+#define YYPURE 2
 
 /* Push parsers.  */
 #define YYPUSH 0
@@ -63,17 +63,15 @@
 #define yyparse         __gettextparse
 #define yylex           __gettextlex
 #define yyerror         __gettexterror
-#define yylval          __gettextlval
-#define yychar          __gettextchar
 #define yydebug         __gettextdebug
 #define yynerrs         __gettextnerrs
 
+
 /* Copy the first part of user declarations.  */
-/* Line 371 of yacc.c  */
-#line 1 "plural.y"
+#line 1 "plural.y" /* yacc.c:339  */
 
 /* Expression parsing for plural form selection.
-   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
 
@@ -88,8 +86,9 @@
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 /* The bison generated parser uses alloca.  AIX 3 forces us to put this
    declaration at the beginning of the file.  The declaration in bison's
@@ -112,18 +111,15 @@
 #ifndef _LIBC
 # define __gettextparse PLURAL_PARSE
 #endif
+	
 
-#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
-#define YYPARSE_PARAM	arg
-
-/* Line 371 of yacc.c  */
-#line 121 "plural.c"
+#line 117 "plural.c" /* yacc.c:339  */
 
-# ifndef YY_NULL
+# ifndef YY_NULLPTR
 #  if defined __cplusplus && 201103L <= __cplusplus
-#   define YY_NULL nullptr
+#   define YY_NULLPTR nullptr
 #  else
-#   define YY_NULL 0
+#   define YY_NULLPTR 0
 #  endif
 # endif
 
@@ -136,7 +132,7 @@
 #endif
 
 
-/* Enabling traces.  */
+/* Debug traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
 #endif
@@ -144,18 +140,17 @@
 extern int __gettextdebug;
 #endif
 
-/* Tokens.  */
+/* Token type.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     EQUOP2 = 258,
-     CMPOP2 = 259,
-     ADDOP2 = 260,
-     MULOP2 = 261,
-     NUMBER = 262
-   };
+  enum yytokentype
+  {
+    EQUOP2 = 258,
+    CMPOP2 = 259,
+    ADDOP2 = 260,
+    MULOP2 = 261,
+    NUMBER = 262
+  };
 #endif
 /* Tokens.  */
 #define EQUOP2 258
@@ -164,147 +159,130 @@
 #define MULOP2 261
 #define NUMBER 262
 
-
-
+/* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
+typedef union YYSTYPE YYSTYPE;
+union YYSTYPE
 {
-/* Line 387 of yacc.c  */
-#line 49 "plural.y"
+#line 48 "plural.y" /* yacc.c:355  */
 
-  unsigned long int num;
-  enum operator op;
-  struct expression *exp;
+	unsigned long int num;
+	enum operator op;
+	struct expression *exp;
 
-
-/* Line 387 of yacc.c  */
-#line 182 "plural.c"
-} YYSTYPE;
+#line 174 "plural.c" /* yacc.c:355  */
+};
 # define YYSTYPE_IS_TRIVIAL 1
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 #endif
 
 
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int __gettextparse (void *YYPARSE_PARAM);
-#else
-int __gettextparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int __gettextparse (void);
-#else
-int __gettextparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
+
+int __gettextparse (struct parse_args *arg);
 
 
 
 /* Copy the second part of user declarations.  */
-/* Line 390 of yacc.c  */
-#line 55 "plural.y"
+#line 54 "plural.y" /* yacc.c:358  */
 
 /* Prototypes for local functions.  */
-static struct expression *new_exp PARAMS ((int nargs, enum operator op,
-					   struct expression * const *args));
-static inline struct expression *new_exp_0 PARAMS ((enum operator op));
-static inline struct expression *new_exp_1 PARAMS ((enum operator op,
-						   struct expression *right));
-static struct expression *new_exp_2 PARAMS ((enum operator op,
-					     struct expression *left,
-					     struct expression *right));
-static inline struct expression *new_exp_3 PARAMS ((enum operator op,
-						   struct expression *bexp,
-						   struct expression *tbranch,
-						   struct expression *fbranch));
-static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
-static void yyerror PARAMS ((const char *str));
+	static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+											   struct expression * const *args));
+	static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+	static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+														struct expression *right));
+	static struct expression *new_exp_2 PARAMS ((enum operator op,
+												 struct expression *left,
+												 struct expression *right));
+	static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+														struct expression *bexp,
+														struct expression *tbranch,
+														struct expression *fbranch));
+	static int yylex PARAMS ((YYSTYPE *lval, struct parse_args *arg));
+	static void yyerror PARAMS ((struct parse_args *arg, const char *str));
 
 /* Allocation of expressions.  */
 
 static struct expression *
-new_exp (nargs, op, args)
-     int nargs;
-     enum operator op;
-     struct expression * const *args;
-{
-  int i;
-  struct expression *newp;
-
-  /* If any of the argument could not be malloc'ed, just return NULL.  */
-  for (i = nargs - 1; i >= 0; i--)
-    if (args[i] == NULL)
-      goto fail;
-
-  /* Allocate a new expression.  */
-  newp = (struct expression *) malloc (sizeof (*newp));
-  if (newp != NULL)
-    {
-      newp->nargs = nargs;
-      newp->operation = op;
-      for (i = nargs - 1; i >= 0; i--)
-	newp->val.args[i] = args[i];
-      return newp;
-    }
-
- fail:
-  for (i = nargs - 1; i >= 0; i--)
-    FREE_EXPRESSION (args[i]);
+	new_exp (nargs, op, args)
+	int nargs;
+enum operator op;
+struct expression * const *args;
+{
+	int i;
+	struct expression *newp;
+
+	/* If any of the argument could not be malloc'ed, just return NULL.  */
+	for (i = nargs - 1; i >= 0; i--)
+		if (args[i] == NULL)
+			goto fail;
+
+	/* Allocate a new expression.  */
+	newp = (struct expression *) malloc (sizeof (*newp));
+	if (newp != NULL)
+    {
+		newp->nargs = nargs;
+		newp->operation = op;
+		for (i = nargs - 1; i >= 0; i--)
+			newp->val.args[i] = args[i];
+		return newp;
+    }
+
+fail:
+	for (i = nargs - 1; i >= 0; i--)
+		FREE_EXPRESSION (args[i]);
 
-  return NULL;
+	return NULL;
 }
 
 static inline struct expression *
-new_exp_0 (op)
-     enum operator op;
+	new_exp_0 (op)
+	enum operator op;
 {
-  return new_exp (0, op, NULL);
+	return new_exp (0, op, NULL);
 }
 
 static inline struct expression *
-new_exp_1 (op, right)
-     enum operator op;
-     struct expression *right;
+	new_exp_1 (op, right)
+	enum operator op;
+struct expression *right;
 {
-  struct expression *args[1];
+	struct expression *args[1];
 
-  args[0] = right;
-  return new_exp (1, op, args);
+	args[0] = right;
+	return new_exp (1, op, args);
 }
 
 static struct expression *
-new_exp_2 (op, left, right)
-     enum operator op;
-     struct expression *left;
-     struct expression *right;
-{
-  struct expression *args[2];
-
-  args[0] = left;
-  args[1] = right;
-  return new_exp (2, op, args);
+	new_exp_2 (op, left, right)
+	enum operator op;
+struct expression *left;
+struct expression *right;
+{
+	struct expression *args[2];
+
+	args[0] = left;
+	args[1] = right;
+	return new_exp (2, op, args);
 }
 
 static inline struct expression *
-new_exp_3 (op, bexp, tbranch, fbranch)
-     enum operator op;
-     struct expression *bexp;
-     struct expression *tbranch;
-     struct expression *fbranch;
-{
-  struct expression *args[3];
-
-  args[0] = bexp;
-  args[1] = tbranch;
-  args[2] = fbranch;
-  return new_exp (3, op, args);
+	new_exp_3 (op, bexp, tbranch, fbranch)
+	enum operator op;
+struct expression *bexp;
+struct expression *tbranch;
+struct expression *fbranch;
+{
+	struct expression *args[3];
+
+	args[0] = bexp;
+	args[1] = tbranch;
+	args[2] = fbranch;
+	return new_exp (3, op, args);
 }
 
 
-/* Line 390 of yacc.c  */
-#line 308 "plural.c"
+#line 286 "plural.c" /* yacc.c:358  */
 
 #ifdef short
 # undef short
@@ -318,11 +296,8 @@
 
 #ifdef YYTYPE_INT8
 typedef YYTYPE_INT8 yytype_int8;
-#elif (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-typedef signed char yytype_int8;
 #else
-typedef short int yytype_int8;
+typedef signed char yytype_int8;
 #endif
 
 #ifdef YYTYPE_UINT16
@@ -342,8 +317,7 @@
 #  define YYSIZE_T __SIZE_TYPE__
 # elif defined size_t
 #  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+# elif ! defined YYSIZE_T
 #  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
 #  define YYSIZE_T size_t
 # else
@@ -365,6 +339,33 @@
 # endif
 #endif
 
+#ifndef YY_ATTRIBUTE
+# if (defined __GNUC__                                               \
+      && (2 < __GNUC__ || (__GNUC__ == 2 && 96 <= __GNUC_MINOR__)))  \
+     || defined __SUNPRO_C && 0x5110 <= __SUNPRO_C
+#  define YY_ATTRIBUTE(Spec) __attribute__(Spec)
+# else
+#  define YY_ATTRIBUTE(Spec) /* empty */
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_PURE
+# define YY_ATTRIBUTE_PURE   YY_ATTRIBUTE ((__pure__))
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# define YY_ATTRIBUTE_UNUSED YY_ATTRIBUTE ((__unused__))
+#endif
+
+#if !defined _Noreturn \
+     && (!defined __STDC_VERSION__ || __STDC_VERSION__ < 201112)
+# if defined _MSC_VER && 1200 <= _MSC_VER
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn YY_ATTRIBUTE ((__noreturn__))
+# endif
+#endif
+
 /* Suppress unused-variable warnings by "using" E.  */
 #if ! defined lint || defined __GNUC__
 # define YYUSE(E) ((void) (E))
@@ -372,23 +373,25 @@
 # define YYUSE(E) /* empty */
 #endif
 
-/* Identity function, used to suppress warnings about constant conditions.  */
-#ifndef lint
-# define YYID(N) (N)
-#else
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static int
-YYID (int yyi)
+#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
+    _Pragma ("GCC diagnostic pop")
 #else
-static int
-YYID (yyi)
-    int yyi;
+# define YY_INITIAL_VALUE(Value) Value
 #endif
-{
-  return yyi;
-}
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
 #endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
 
 #if ! defined yyoverflow || YYERROR_VERBOSE
 
@@ -407,8 +410,7 @@
 #    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
       /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
 #     ifndef EXIT_SUCCESS
@@ -420,8 +422,8 @@
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
 #  ifndef YYSTACK_ALLOC_MAXIMUM
     /* The OS might guarantee only one guard page at the bottom of the stack,
        and a page size can be as small as 4096 bytes.  So we cannot safely
@@ -437,7 +439,7 @@
 #  endif
 #  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        && ! ((defined YYMALLOC || defined malloc) \
-	     && (defined YYFREE || defined free)))
+             && (defined YYFREE || defined free)))
 #   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
 #   ifndef EXIT_SUCCESS
 #    define EXIT_SUCCESS 0
@@ -445,15 +447,13 @@
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#   if ! defined malloc && ! defined EXIT_SUCCESS
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
+#   if ! defined free && ! defined EXIT_SUCCESS
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
@@ -463,7 +463,7 @@
 
 #if (! defined yyoverflow \
      && (! defined __cplusplus \
-	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
@@ -488,16 +488,16 @@
    elements in the stack, and YYPTR gives the new location of the
    stack.  Advance YYPTR to a properly aligned location for the next
    stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
-	Stack = &yyptr->Stack_alloc;					\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYSIZE_T yynewbytes;                                            \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / sizeof (*yyptr);                          \
+      }                                                                 \
+    while (0)
 
 #endif
 
@@ -516,7 +516,7 @@
           for (yyi = 0; yyi < (Count); yyi++)   \
             (Dst)[yyi] = (Src)[yyi];            \
         }                                       \
-      while (YYID (0))
+      while (0)
 #  endif
 # endif
 #endif /* !YYCOPY_NEEDED */
@@ -532,17 +532,19 @@
 #define YYNNTS  3
 /* YYNRULES -- Number of rules.  */
 #define YYNRULES  13
-/* YYNRULES -- Number of states.  */
+/* YYNSTATES -- Number of states.  */
 #define YYNSTATES  27
 
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
+   by yylex, with out-of-bounds checking.  */
 #define YYUNDEFTOK  2
 #define YYMAXUTOK   262
 
-#define YYTRANSLATE(YYX)						\
+#define YYTRANSLATE(YYX)                                                \
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, without out-of-bounds checking.  */
 static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -575,29 +577,11 @@
 };
 
 #if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const yytype_uint8 yyprhs[] =
-{
-       0,     0,     3,     5,    11,    15,    19,    23,    27,    31,
-      35,    38,    40,    42
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
-static const yytype_int8 yyrhs[] =
-{
-      17,     0,    -1,    18,    -1,    18,     3,    18,    12,    18,
-      -1,    18,     4,    18,    -1,    18,     5,    18,    -1,    18,
-       6,    18,    -1,    18,     7,    18,    -1,    18,     8,    18,
-      -1,    18,     9,    18,    -1,    10,    18,    -1,    13,    -1,
-      11,    -1,    14,    18,    15,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_uint8 yyrline[] =
 {
-       0,   174,   174,   182,   186,   190,   194,   198,   202,   206,
-     210,   214,   218,   223
+       0,   173,   173,   181,   185,   189,   193,   197,   201,   205,
+     209,   213,   217,   222
 };
 #endif
 
@@ -608,13 +592,13 @@
 {
   "$end", "error", "$undefined", "'?'", "'|'", "'&'", "EQUOP2", "CMPOP2",
   "ADDOP2", "MULOP2", "'!'", "NUMBER", "':'", "'n'", "'('", "')'",
-  "$accept", "start", "exp", YY_NULL
+  "$accept", "start", "exp", YY_NULLPTR
 };
 #endif
 
 # ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
 static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,    63,   124,    38,   258,   259,   260,   261,
@@ -622,23 +606,28 @@
 };
 # endif
 
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
-{
-       0,    16,    17,    18,    18,    18,    18,    18,    18,    18,
-      18,    18,    18,    18
-};
+#define YYPACT_NINF -10
 
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
+#define yypact_value_is_default(Yystate) \
+  (!!((Yystate) == (-10)))
+
+#define YYTABLE_NINF -1
+
+#define yytable_value_is_error(Yytable_value) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
 {
-       0,     2,     1,     5,     3,     3,     3,     3,     3,     3,
-       2,     1,     1,     3
+      -9,    -9,   -10,   -10,    -9,     8,    36,   -10,    13,   -10,
+      -9,    -9,    -9,    -9,    -9,    -9,    -9,   -10,    26,    41,
+      45,    18,    -2,    14,   -10,    -9,    36
 };
 
-/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
-   Performed when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
 static const yytype_uint8 yydefact[] =
 {
        0,     0,    12,    11,     0,     0,     2,    10,     0,     1,
@@ -646,32 +635,21 @@
        5,     6,     7,     8,     9,     0,     3
 };
 
-/* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int8 yydefgoto[] =
-{
-      -1,     5,     6
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -10
-static const yytype_int8 yypact[] =
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
 {
-      -9,    -9,   -10,   -10,    -9,     8,    36,   -10,    13,   -10,
-      -9,    -9,    -9,    -9,    -9,    -9,    -9,   -10,    26,    41,
-      45,    18,    -2,    14,   -10,    -9,    36
+     -10,   -10,    -1
 };
 
-/* YYPGOTO[NTERM-NUM].  */
-static const yytype_int8 yypgoto[] =
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
 {
-     -10,   -10,    -1
+      -1,     5,     6
 };
 
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -1
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_uint8 yytable[] =
 {
        7,     1,     2,     8,     3,     4,    15,    16,     9,    18,
@@ -682,12 +660,6 @@
       16,    13,    14,    15,    16
 };
 
-#define yypact_value_is_default(Yystate) \
-  (!!((Yystate) == (-10)))
-
-#define yytable_value_is_error(Yytable_value) \
-  YYID (0)
-
 static const yytype_int8 yycheck[] =
 {
        1,    10,    11,     4,    13,    14,     8,     9,     0,    10,
@@ -698,8 +670,8 @@
        9,     6,     7,     8,     9
 };
 
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
 static const yytype_uint8 yystos[] =
 {
        0,    10,    11,    13,    14,    17,    18,    18,    18,     0,
@@ -707,30 +679,30 @@
       18,    18,    18,    18,    18,    12,    18
 };
 
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  However,
-   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
-   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
-   discussed.  */
-
-#define YYFAIL		goto yyerrlab
-#if defined YYFAIL
-  /* This is here to suppress warnings from the GCC cpp's
-     -Wunused-macros.  Normally we don't worry about that warning, but
-     some users do, and we want to make it easy for users to remove
-     YYFAIL uses, which will produce warnings from Bison 2.5.  */
-#endif
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    16,    17,    18,    18,    18,    18,    18,    18,    18,
+      18,    18,    18,    18
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     5,     3,     3,     3,     3,     3,     3,
+       2,     1,     1,     3
+};
+
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+#define YYEMPTY         (-2)
+#define YYEOF           0
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
 
 #define YYRECOVERING()  (!!yyerrstatus)
 
@@ -746,28 +718,16 @@
     }                                                           \
   else                                                          \
     {                                                           \
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;							\
-    }								\
-while (YYID (0))
+      yyerror (arg, YY_("syntax error: cannot back up")); \
+      YYERROR;                                                  \
+    }                                                           \
+while (0)
 
 /* Error token number */
-#define YYTERROR	1
-#define YYERRCODE	256
+#define YYTERROR        1
+#define YYERRCODE       256
 
 
-/* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (&yylval, YYLEX_PARAM)
-#else
-# define YYLEX yylex (&yylval)
-#endif
 
 /* Enable debugging if requested.  */
 #if YYDEBUG
@@ -777,56 +737,47 @@
 #  define YYFPRINTF fprintf
 # endif
 
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (YYID (0))
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
-do {									  \
-  if (yydebug)								  \
-    {									  \
-      YYFPRINTF (stderr, "%s ", Title);					  \
-      yy_symbol_print (stderr,						  \
-		  Type, Value); \
-      YYFPRINTF (stderr, "\n");						  \
-    }									  \
-} while (YYID (0))
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
 
+/* This macro is provided for backward compatibility. */
+#ifndef YY_LOCATION_PRINT
+# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#endif
 
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
 
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Type, Value, arg); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*----------------------------------------.
+| Print this symbol's value on YYOUTPUT.  |
+`----------------------------------------*/
+
 static void
-yy_symbol_value_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, struct parse_args *arg)
 {
   FILE *yyo = yyoutput;
   YYUSE (yyo);
+  YYUSE (arg);
   if (!yyvaluep)
     return;
 # ifdef YYPRINT
   if (yytype < YYNTOKENS)
     YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# else
-  YYUSE (yyoutput);
 # endif
-  switch (yytype)
-    {
-      default:
-        break;
-    }
+  YYUSE (yytype);
 }
 
 
@@ -834,24 +785,13 @@
 | Print this symbol on YYOUTPUT.  |
 `--------------------------------*/
 
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
 static void
-yy_symbol_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, struct parse_args *arg)
 {
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+  YYFPRINTF (yyoutput, "%s %s (",
+             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
 
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep, arg);
   YYFPRINTF (yyoutput, ")");
 }
 
@@ -860,16 +800,8 @@
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
 static void
 yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
-#else
-static void
-yy_stack_print (yybottom, yytop)
-    yytype_int16 *yybottom;
-    yytype_int16 *yytop;
-#endif
 {
   YYFPRINTF (stderr, "Stack now");
   for (; yybottom <= yytop; yybottom++)
@@ -880,49 +812,42 @@
   YYFPRINTF (stderr, "\n");
 }
 
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (YYID (0))
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
-#else
-static void
-yy_reduce_print (yyvsp, yyrule)
-    YYSTYPE *yyvsp;
-    int yyrule;
-#endif
+yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, struct parse_args *arg)
 {
+  unsigned long int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
   int yyi;
-  unsigned long int yylno = yyrline[yyrule];
   YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-	     yyrule - 1, yylno);
+             yyrule - 1, yylno);
   /* The symbols being reduced.  */
   for (yyi = 0; yyi < yynrhs; yyi++)
     {
       YYFPRINTF (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
-		       &(yyvsp[(yyi + 1) - (yynrhs)])
-				       );
+      yy_symbol_print (stderr,
+                       yystos[yyssp[yyi + 1 - yynrhs]],
+                       &(yyvsp[(yyi + 1) - (yynrhs)])
+                                              , arg);
       YYFPRINTF (stderr, "\n");
     }
 }
 
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (yyvsp, Rule); \
-} while (YYID (0))
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule, arg); \
+} while (0)
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
@@ -936,7 +861,7 @@
 
 
 /* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
+#ifndef YYINITDEPTH
 # define YYINITDEPTH 200
 #endif
 
@@ -959,15 +884,8 @@
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
 yystrlen (const char *yystr)
-#else
-static YYSIZE_T
-yystrlen (yystr)
-    const char *yystr;
-#endif
 {
   YYSIZE_T yylen;
   for (yylen = 0; yystr[yylen]; yylen++)
@@ -983,16 +901,8 @@
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
 static char *
 yystpcpy (char *yydest, const char *yysrc)
-#else
-static char *
-yystpcpy (yydest, yysrc)
-    char *yydest;
-    const char *yysrc;
-#endif
 {
   char *yyd = yydest;
   const char *yys = yysrc;
@@ -1022,27 +932,27 @@
       char const *yyp = yystr;
 
       for (;;)
-	switch (*++yyp)
-	  {
-	  case '\'':
-	  case ',':
-	    goto do_not_strip_quotes;
-
-	  case '\\':
-	    if (*++yyp != '\\')
-	      goto do_not_strip_quotes;
-	    /* Fall through.  */
-	  default:
-	    if (yyres)
-	      yyres[yyn] = *yyp;
-	    yyn++;
-	    break;
-
-	  case '"':
-	    if (yyres)
-	      yyres[yyn] = '\0';
-	    return yyn;
-	  }
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            /* Fall through.  */
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
     do_not_strip_quotes: ;
     }
 
@@ -1065,11 +975,11 @@
 yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
                 yytype_int16 *yyssp, int yytoken)
 {
-  YYSIZE_T yysize0 = yytnamerr (YY_NULL, yytname[yytoken]);
+  YYSIZE_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
   YYSIZE_T yysize = yysize0;
   enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
   /* Internationalized format string. */
-  const char *yyformat = YY_NULL;
+  const char *yyformat = YY_NULLPTR;
   /* Arguments of yyformat. */
   char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
   /* Number of reported tokens (one for the "unexpected", one per
@@ -1077,10 +987,6 @@
   int yycount = 0;
 
   /* There are many possibilities here to consider:
-     - Assume YYFAIL is not used.  It's too flawed to consider.  See
-       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
-       for details.  YYERROR is fine as it does not invoke this
-       function.
      - If this state is a consistent state with a default action, then
        the only way this function was invoked is if the default action
        is an error action.  In that case, don't check for expected
@@ -1130,7 +1036,7 @@
                   }
                 yyarg[yycount++] = yytname[yyx];
                 {
-                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULL, yytname[yyx]);
+                  YYSIZE_T yysize1 = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
                   if (! (yysize <= yysize1
                          && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
                     return 2;
@@ -1197,31 +1103,18 @@
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
-#else
 static void
-yydestruct (yymsg, yytype, yyvaluep)
-    const char *yymsg;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, struct parse_args *arg)
 {
   YYUSE (yyvaluep);
-
+  YYUSE (arg);
   if (!yymsg)
     yymsg = "Deleting";
   YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
 
-  switch (yytype)
-    {
-
-      default:
-        break;
-    }
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yytype);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
@@ -1231,56 +1124,18 @@
 | yyparse.  |
 `----------*/
 
-#ifdef YYPARSE_PARAM
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void *YYPARSE_PARAM)
-#else
-int
-yyparse (YYPARSE_PARAM)
-    void *YYPARSE_PARAM;
-#endif
-#else /* ! YYPARSE_PARAM */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void)
-#else
 int
-yyparse ()
-
-#endif
-#endif
+yyparse (struct parse_args *arg)
 {
 /* The lookahead symbol.  */
 int yychar;
 
 
-#if defined __GNUC__ && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
-/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN \
-    _Pragma ("GCC diagnostic push") \
-    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
-    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END \
-    _Pragma ("GCC diagnostic pop")
-#else
+/* The semantic value of the lookahead symbol.  */
 /* Default value used for initialization, for pacifying older GCCs
    or non-GCC compilers.  */
-static YYSTYPE yyval_default;
-# define YY_INITIAL_VALUE(Value) = Value
-#endif
-#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-# define YY_IGNORE_MAYBE_UNINITIALIZED_END
-#endif
-#ifndef YY_INITIAL_VALUE
-# define YY_INITIAL_VALUE(Value) /* Nothing. */
-#endif
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);
+YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
+YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
     /* Number of syntax errors so far.  */
     int yynerrs;
@@ -1290,8 +1145,8 @@
     int yyerrstatus;
 
     /* The stacks and their tools:
-       `yyss': related to states.
-       `yyvs': related to semantic values.
+       'yyss': related to states.
+       'yyvs': related to semantic values.
 
        Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
@@ -1359,23 +1214,23 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to reallocate the stack.  Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	yytype_int16 *yyss1 = yyss;
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow (YY_("memory exhausted"),
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yystacksize);
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        YYSTYPE *yyvs1 = yyvs;
+        yytype_int16 *yyss1 = yyss;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * sizeof (*yyssp),
+                    &yyvs1, yysize * sizeof (*yyvsp),
+                    &yystacksize);
 
-	yyss = yyss1;
-	yyvs = yyvs1;
+        yyss = yyss1;
+        yyvs = yyvs1;
       }
 #else /* no yyoverflow */
 # ifndef YYSTACK_RELOCATE
@@ -1383,22 +1238,22 @@
 # else
       /* Extend the stack our own way.  */
       if (YYMAXDEPTH <= yystacksize)
-	goto yyexhaustedlab;
+        goto yyexhaustedlab;
       yystacksize *= 2;
       if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
+        yystacksize = YYMAXDEPTH;
 
       {
-	yytype_int16 *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss_alloc, yyss);
-	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+        yytype_int16 *yyss1 = yyss;
+        union yyalloc *yyptr =
+          (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 #  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
       }
 # endif
 #endif /* no yyoverflow */
@@ -1407,10 +1262,10 @@
       yyvsp = yyvs + yysize - 1;
 
       YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
+                  (unsigned long int) yystacksize));
 
       if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
+        YYABORT;
     }
 
   YYDPRINTF ((stderr, "Entering state %d\n", yystate));
@@ -1439,7 +1294,7 @@
   if (yychar == YYEMPTY)
     {
       YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
+      yychar = yylex (&yylval, arg);
     }
 
   if (yychar <= YYEOF)
@@ -1504,7 +1359,7 @@
   yylen = yyr2[yyn];
 
   /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
+     '$$ = $1'.
 
      Otherwise, the following line sets YYVAL to garbage.
      This behavior is undocumented and Bison
@@ -1518,107 +1373,106 @@
   switch (yyn)
     {
         case 2:
-/* Line 1792 of yacc.c  */
-#line 175 "plural.y"
+#line 174 "plural.y" /* yacc.c:1646  */
     {
-	    if ((yyvsp[(1) - (1)].exp) == NULL)
-	      YYABORT;
-	    ((struct parse_args *) arg)->res = (yyvsp[(1) - (1)].exp);
-	  }
+	if ((yyvsp[0].exp) == NULL)
+		YYABORT;
+	arg->res = (yyvsp[0].exp);
+}
+#line 1383 "plural.c" /* yacc.c:1646  */
     break;
 
   case 3:
-/* Line 1792 of yacc.c  */
-#line 183 "plural.y"
+#line 182 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_3 (qmop, (yyvsp[(1) - (5)].exp), (yyvsp[(3) - (5)].exp), (yyvsp[(5) - (5)].exp));
-	  }
+	(yyval.exp) = new_exp_3 (qmop, (yyvsp[-4].exp), (yyvsp[-2].exp), (yyvsp[0].exp));
+}
+#line 1391 "plural.c" /* yacc.c:1646  */
     break;
 
   case 4:
-/* Line 1792 of yacc.c  */
-#line 187 "plural.y"
+#line 186 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_2 (lor, (yyvsp[(1) - (3)].exp), (yyvsp[(3) - (3)].exp));
-	  }
+	(yyval.exp) = new_exp_2 (lor, (yyvsp[-2].exp), (yyvsp[0].exp));
+}
+#line 1399 "plural.c" /* yacc.c:1646  */
     break;
 
   case 5:
-/* Line 1792 of yacc.c  */
-#line 191 "plural.y"
+#line 190 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_2 (land, (yyvsp[(1) - (3)].exp), (yyvsp[(3) - (3)].exp));
-	  }
+	(yyval.exp) = new_exp_2 (land, (yyvsp[-2].exp), (yyvsp[0].exp));
+}
+#line 1407 "plural.c" /* yacc.c:1646  */
     break;
 
   case 6:
-/* Line 1792 of yacc.c  */
-#line 195 "plural.y"
+#line 194 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_2 ((yyvsp[(2) - (3)].op), (yyvsp[(1) - (3)].exp), (yyvsp[(3) - (3)].exp));
-	  }
+	(yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));
+}
+#line 1415 "plural.c" /* yacc.c:1646  */
     break;
 
   case 7:
-/* Line 1792 of yacc.c  */
-#line 199 "plural.y"
+#line 198 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_2 ((yyvsp[(2) - (3)].op), (yyvsp[(1) - (3)].exp), (yyvsp[(3) - (3)].exp));
-	  }
+	(yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));
+}
+#line 1423 "plural.c" /* yacc.c:1646  */
     break;
 
   case 8:
-/* Line 1792 of yacc.c  */
-#line 203 "plural.y"
+#line 202 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_2 ((yyvsp[(2) - (3)].op), (yyvsp[(1) - (3)].exp), (yyvsp[(3) - (3)].exp));
-	  }
+	(yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));
+}
+#line 1431 "plural.c" /* yacc.c:1646  */
     break;
 
   case 9:
-/* Line 1792 of yacc.c  */
-#line 207 "plural.y"
+#line 206 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_2 ((yyvsp[(2) - (3)].op), (yyvsp[(1) - (3)].exp), (yyvsp[(3) - (3)].exp));
-	  }
+	(yyval.exp) = new_exp_2 ((yyvsp[-1].op), (yyvsp[-2].exp), (yyvsp[0].exp));
+}
+#line 1439 "plural.c" /* yacc.c:1646  */
     break;
 
   case 10:
-/* Line 1792 of yacc.c  */
-#line 211 "plural.y"
+#line 210 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_1 (lnot, (yyvsp[(2) - (2)].exp));
-	  }
+	(yyval.exp) = new_exp_1 (lnot, (yyvsp[0].exp));
+}
+#line 1447 "plural.c" /* yacc.c:1646  */
     break;
 
   case 11:
-/* Line 1792 of yacc.c  */
-#line 215 "plural.y"
+#line 214 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = new_exp_0 (var);
-	  }
+	(yyval.exp) = new_exp_0 (var);
+}
+#line 1455 "plural.c" /* yacc.c:1646  */
     break;
 
   case 12:
-/* Line 1792 of yacc.c  */
-#line 219 "plural.y"
+#line 218 "plural.y" /* yacc.c:1646  */
     {
-	    if (((yyval.exp) = new_exp_0 (num)) != NULL)
-	      (yyval.exp)->val.num = (yyvsp[(1) - (1)].num);
-	  }
+	if (((yyval.exp) = new_exp_0 (num)) != NULL)
+		(yyval.exp)->val.num = (yyvsp[0].num);
+}
+#line 1464 "plural.c" /* yacc.c:1646  */
     break;
 
   case 13:
-/* Line 1792 of yacc.c  */
-#line 224 "plural.y"
+#line 223 "plural.y" /* yacc.c:1646  */
     {
-	    (yyval.exp) = (yyvsp[(2) - (3)].exp);
-	  }
+	(yyval.exp) = (yyvsp[-1].exp);
+}
+#line 1472 "plural.c" /* yacc.c:1646  */
     break;
 
 
-/* Line 1792 of yacc.c  */
-#line 1622 "plural.c"
+#line 1476 "plural.c" /* yacc.c:1646  */
       default: break;
     }
   /* User semantic actions sometimes alter yychar, and that requires
@@ -1640,7 +1494,7 @@
 
   *++yyvsp = yyval;
 
-  /* Now `shift' the result of the reduction.  Determine what state
+  /* Now 'shift' the result of the reduction.  Determine what state
      that goes to, based on the state we popped back to and the rule
      number reduced by.  */
 
@@ -1655,9 +1509,9 @@
   goto yynewstate;
 
 
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
 yyerrlab:
   /* Make sure we have latest lookahead translation.  See comments at
      user semantic actions for why this is necessary.  */
@@ -1668,7 +1522,7 @@
     {
       ++yynerrs;
 #if ! YYERROR_VERBOSE
-      yyerror (YY_("syntax error"));
+      yyerror (arg, YY_("syntax error"));
 #else
 # define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
                                         yyssp, yytoken)
@@ -1695,7 +1549,7 @@
                 yymsgp = yymsg;
               }
           }
-        yyerror (yymsgp);
+        yyerror (arg, yymsgp);
         if (yysyntax_error_status == 2)
           goto yyexhaustedlab;
       }
@@ -1708,20 +1562,20 @@
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
+         error, discard it.  */
 
       if (yychar <= YYEOF)
-	{
-	  /* Return failure if at end of input.  */
-	  if (yychar == YYEOF)
-	    YYABORT;
-	}
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
       else
-	{
-	  yydestruct ("Error: discarding",
-		      yytoken, &yylval);
-	  yychar = YYEMPTY;
-	}
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval, arg);
+          yychar = YYEMPTY;
+        }
     }
 
   /* Else will try to reuse lookahead token after shifting the error
@@ -1740,7 +1594,7 @@
   if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
 
-  /* Do not reclaim the symbols of the rule which action triggered
+  /* Do not reclaim the symbols of the rule whose action triggered
      this YYERROR.  */
   YYPOPSTACK (yylen);
   yylen = 0;
@@ -1753,29 +1607,29 @@
 | yyerrlab1 -- common code for both syntax error and YYERROR.  |
 `-------------------------------------------------------------*/
 yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
+        {
+          yyn += YYTERROR;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
 
       /* Pop the current state because it cannot handle the error token.  */
       if (yyssp == yyss)
-	YYABORT;
+        YYABORT;
 
 
       yydestruct ("Error: popping",
-		  yystos[yystate], yyvsp);
+                  yystos[yystate], yyvsp, arg);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
@@ -1812,7 +1666,7 @@
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
 yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
+  yyerror (arg, YY_("memory exhausted"));
   yyresult = 2;
   /* Fall through.  */
 #endif
@@ -1824,16 +1678,16 @@
          user semantic actions for why this is necessary.  */
       yytoken = YYTRANSLATE (yychar);
       yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval);
+                  yytoken, &yylval, arg);
     }
-  /* Do not reclaim the symbols of the rule which action triggered
+  /* Do not reclaim the symbols of the rule whose action triggered
      this YYABORT or YYACCEPT.  */
   YYPOPSTACK (yylen);
   YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp);
+                  yystos[*yyssp], yyvsp, arg);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
@@ -1844,191 +1698,188 @@
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
 #endif
-  /* Make sure YYID is used.  */
-  return YYID (yyresult);
+  return yyresult;
 }
-
-
-/* Line 2055 of yacc.c  */
-#line 229 "plural.y"
+#line 228 "plural.y" /* yacc.c:1906  */
 
 
 void
 internal_function
 FREE_EXPRESSION (exp)
-     struct expression *exp;
+struct expression *exp;
 {
-  if (exp == NULL)
-    return;
+	if (exp == NULL)
+		return;
 
-  /* Handle the recursive case.  */
-  switch (exp->nargs)
+	/* Handle the recursive case.  */
+	switch (exp->nargs)
     {
-    case 3:
-      FREE_EXPRESSION (exp->val.args[2]);
-      /* FALLTHROUGH */
-    case 2:
-      FREE_EXPRESSION (exp->val.args[1]);
-      /* FALLTHROUGH */
-    case 1:
-      FREE_EXPRESSION (exp->val.args[0]);
-      /* FALLTHROUGH */
-    default:
-      break;
+		case 3:
+			FREE_EXPRESSION (exp->val.args[2]);
+			/* FALLTHROUGH */
+		case 2:
+			FREE_EXPRESSION (exp->val.args[1]);
+			/* FALLTHROUGH */
+		case 1:
+			FREE_EXPRESSION (exp->val.args[0]);
+			/* FALLTHROUGH */
+		default:
+			break;
     }
 
-  free (exp);
+	free (exp);
 }
 
 
 static int
-yylex (lval, pexp)
-     YYSTYPE *lval;
-     const char **pexp;
-{
-  const char *exp = *pexp;
-  int result;
-
-  while (1)
-    {
-      if (exp[0] == '\0')
-	{
-	  *pexp = exp;
-	  return YYEOF;
-	}
-
-      if (exp[0] != ' ' && exp[0] != '\t')
-	break;
-
-      ++exp;
-    }
-
-  result = *exp++;
-  switch (result)
-    {
-    case '0': case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8': case '9':
-      {
-	unsigned long int n = result - '0';
-	while (exp[0] >= '0' && exp[0] <= '9')
-	  {
-	    n *= 10;
-	    n += exp[0] - '0';
-	    ++exp;
-	  }
-	lval->num = n;
-	result = NUMBER;
-      }
-      break;
-
-    case '=':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = equal;
-	  result = EQUOP2;
-	}
-      else
-	result = YYERRCODE;
-      break;
-
-    case '!':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = not_equal;
-	  result = EQUOP2;
-	}
-      break;
-
-    case '&':
-    case '|':
-      if (exp[0] == result)
-	++exp;
-      else
-	result = YYERRCODE;
-      break;
+yylex (lval, arg)
+YYSTYPE *lval;
+struct parse_args *arg;
+{
+	const char *exp = arg->cp;
+	int result;
+
+	while (1)
+    {
+		if (exp[0] == '\0')
+		{
+			arg->cp = exp;
+			return YYEOF;
+		}
+
+		if (exp[0] != ' ' && exp[0] != '\t')
+			break;
+
+		++exp;
+    }
+
+	result = *exp++;
+	switch (result)
+    {
+		case '0': case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+		{
+			unsigned long int n = result - '0';
+			while (exp[0] >= '0' && exp[0] <= '9')
+			{
+				n *= 10;
+				n += exp[0] - '0';
+				++exp;
+			}
+			lval->num = n;
+			result = NUMBER;
+		}
+		break;
 
-    case '<':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = less_or_equal;
-	}
-      else
-	lval->op = less_than;
-      result = CMPOP2;
-      break;
-
-    case '>':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = greater_or_equal;
-	}
-      else
-	lval->op = greater_than;
-      result = CMPOP2;
-      break;
-
-    case '*':
-      lval->op = mult;
-      result = MULOP2;
-      break;
-
-    case '/':
-      lval->op = divide;
-      result = MULOP2;
-      break;
-
-    case '%':
-      lval->op = module;
-      result = MULOP2;
-      break;
-
-    case '+':
-      lval->op = plus;
-      result = ADDOP2;
-      break;
-
-    case '-':
-      lval->op = minus;
-      result = ADDOP2;
-      break;
-
-    case 'n':
-    case '?':
-    case ':':
-    case '(':
-    case ')':
-      /* Nothing, just return the character.  */
-      break;
-
-    case ';':
-    case '\n':
-    case '\0':
-      /* Be safe and let the user call this function again.  */
-      --exp;
-      result = YYEOF;
-      break;
+		case '=':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = equal;
+				result = EQUOP2;
+			}
+			else
+				result = YYERRCODE;
+			break;
+
+		case '!':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = not_equal;
+				result = EQUOP2;
+			}
+			break;
+
+		case '&':
+		case '|':
+			if (exp[0] == result)
+				++exp;
+			else
+				result = YYERRCODE;
+			break;
+
+		case '<':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = less_or_equal;
+			}
+			else
+				lval->op = less_than;
+			result = CMPOP2;
+			break;
+
+		case '>':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = greater_or_equal;
+			}
+			else
+				lval->op = greater_than;
+			result = CMPOP2;
+			break;
+
+		case '*':
+			lval->op = mult;
+			result = MULOP2;
+			break;
+
+		case '/':
+			lval->op = divide;
+			result = MULOP2;
+			break;
+
+		case '%':
+			lval->op = module;
+			result = MULOP2;
+			break;
+
+		case '+':
+			lval->op = plus;
+			result = ADDOP2;
+			break;
+
+		case '-':
+			lval->op = minus;
+			result = ADDOP2;
+			break;
+
+		case 'n':
+		case '?':
+		case ':':
+		case '(':
+		case ')':
+			/* Nothing, just return the character.  */
+			break;
+
+		case ';':
+		case '\n':
+		case '\0':
+			/* Be safe and let the user call this function again.  */
+			--exp;
+			result = YYEOF;
+			break;
 
-    default:
-      result = YYERRCODE;
+		default:
+			result = YYERRCODE;
 #if YYDEBUG != 0
-      --exp;
+			--exp;
 #endif
-      break;
+			break;
     }
 
-  *pexp = exp;
+	arg->cp = exp; 
 
-  return result;
+	return result;
 }
 
 
 static void
-yyerror (str)
-     const char *str;
+yyerror (arg, str)
+struct parse_args *arg;
+const char *str;
 {
-  /* Do nothing.  We don't print error messages here.  */
+	/* Do nothing.  We don't print error messages here.  */
 }
diff -N -r --unified glibc-2.19/intl/plural-exp2.h glibc-2.19-totalpartial/intl/plural-exp2.h
--- glibc-2.19/intl/plural-exp2.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.19-totalpartial/intl/plural-exp2.h	2017-03-04 01:34:56.673742470 -0800
@@ -0,0 +1,125 @@
+/* Expression parsing and evaluation for plural form selection.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _PLURAL_EXP_H
+#define _PLURAL_EXP_H
+
+#ifndef PARAMS
+# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+#ifndef attribute_hidden
+# define attribute_hidden
+#endif
+
+
+/* This is the representation of the expressions to determine the
+   plural form.  */
+struct expression
+{
+  int nargs;			/* Number of arguments.  */
+  enum operator
+  {
+    /* Without arguments:  */
+    var,			/* The variable "n".  */
+    num,			/* Decimal number.  */
+    /* Unary operators:  */
+    lnot,			/* Logical NOT.  */
+    /* Binary operators:  */
+    mult,			/* Multiplication.  */
+    divide,			/* Division.  */
+    module,			/* Modulo operation.  */
+    plus,			/* Addition.  */
+    minus,			/* Subtraction.  */
+    less_than,			/* Comparison.  */
+    greater_than,		/* Comparison.  */
+    less_or_equal,		/* Comparison.  */
+    greater_or_equal,		/* Comparison.  */
+    equal,			/* Comparison for equality.  */
+    not_equal,			/* Comparison for inequality.  */
+    land,			/* Logical AND.  */
+    lor,			/* Logical OR.  */
+    /* Ternary operators:  */
+    qmop			/* Question mark operator.  */
+  } operation;
+  union
+  {
+    unsigned long int num;	/* Number value for `num'.  */
+    struct expression *args[3];	/* Up to three arguments.  */
+  } val;
+};
+
+/* This is the data structure to pass information to the parser and get
+   the result in a thread-safe way.  */
+struct parse_args
+{
+  const char *cp;
+  struct expression *res;
+};
+
+
+/* Names for the libintl functions are a problem.  This source code is used
+   1. in the GNU C Library library,
+   2. in the GNU libintl library,
+   3. in the GNU gettext tools.
+   The function names in each situation must be different, to allow for
+   binary incompatible changes in 'struct expression'.  Furthermore,
+   1. in the GNU C Library library, the names have a __ prefix,
+   2.+3. in the GNU libintl library and in the GNU gettext tools, the names
+         must follow ANSI C and not start with __.
+   So we have to distinguish the three cases.  */
+#ifdef _LIBC
+# define FREE_EXPRESSION __gettext_free_exp
+# define PLURAL_PARSE __gettextparse
+# define GERMANIC_PLURAL __gettext_germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION __gettext_extract_plural
+#elif defined (IN_LIBINTL)
+# define FREE_EXPRESSION libintl_gettext_free_exp
+# define PLURAL_PARSE libintl_gettextparse
+# define GERMANIC_PLURAL libintl_gettext_germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION libintl_gettext_extract_plural
+#else
+# define FREE_EXPRESSION free_plural_expression
+# define PLURAL_PARSE parse_plural_expression
+# define GERMANIC_PLURAL germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION extract_plural_expression
+#endif
+
+extern void FREE_EXPRESSION PARAMS ((struct expression *exp))
+     internal_function;
+extern int PLURAL_PARSE PARAMS ((void *arg));
+extern const struct expression GERMANIC_PLURAL attribute_hidden;
+extern void EXTRACT_PLURAL_EXPRESSION PARAMS
+  ((const char *nullentry, const struct expression **pluralp,
+    unsigned long int *npluralsp)) internal_function;
+
+#if !defined (_LIBC) && !defined (IN_LIBINTL)
+extern unsigned long int plural_eval PARAMS ((const struct expression *pexp,
+					      unsigned long int n));
+#endif
+
+#endif /* _PLURAL_EXP_H */
diff -N -r --unified glibc-2.19/intl/plural-exp3.h glibc-2.19-totalpartial/intl/plural-exp3.h
--- glibc-2.19/intl/plural-exp3.h	1969-12-31 16:00:00.000000000 -0800
+++ glibc-2.19-totalpartial/intl/plural-exp3.h	2017-03-09 18:16:08.682953806 -0800
@@ -0,0 +1,126 @@
+/* Expression parsing and evaluation for plural form selection.
+   Copyright (C) 2000, 2001, 2002, 2005, 2007 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _PLURAL_EXP_H
+#define _PLURAL_EXP_H
+
+#ifndef PARAMS
+# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+#ifndef attribute_hidden
+# define attribute_hidden
+#endif
+
+
+/* This is the representation of the expressions to determine the
+   plural form.  */
+struct expression
+{
+	int nargs;/* Number of arguments.  */
+  enum operator
+  {
+	  /* Without arguments:  */
+	  var,/* The variable "n".  */
+	  num,/* Decimal number.  */
+	  /* Unary operators:  */
+	  lnot,/* Logical NOT.  */
+	  /* Binary operators:  */
+	  mult,/* Multiplication.  */
+	  divide,/* Division.  */
+	  module,/* Modulo operation.  */
+	  plus,/* Addition.  */
+	  minus,/* Subtraction.  */
+	  less_than,/* Comparison.  */
+	  greater_than,/* Comparison.  */
+	  less_or_equal,/* Comparison.  */
+	  greater_or_equal,/* Comparison.  */
+	  equal,/* Comparison for equality.  */
+	  not_equal,/* Comparison for inequality.  */
+	  land,/* Logical AND.  */
+	  lor,/* Logical OR.  */
+	  /* Ternary operators:  */
+	  qmop/* Question mark operator.  */
+  } operation;
+  union
+  {
+	  unsigned long int num;/* Number value for `num'.  */
+	  struct expression *args[3];/* Up to three arguments.  */
+  } val;
+};
+
+/* This is the data structure to pass information to the parser and get
+   the result in a thread-safe way.  */
+struct parse_args
+{
+	const char *cp;
+	struct expression *res;
+};
+
+
+/* Names for the libintl functions are a problem.  This source code is used
+   1. in the GNU C Library library,
+   2. in the GNU libintl library,
+   3. in the GNU gettext tools.
+   The function names in each situation must be different, to allow for
+   binary incompatible changes in 'struct expression'.  Furthermore,
+   1. in the GNU C Library library, the names have a __ prefix,
+   2.+3. in the GNU libintl library and in the GNU gettext tools, the names
+         must follow ANSI C and not start with __.
+   So we have to distinguish the three cases.  */
+#ifdef _LIBC
+# define FREE_EXPRESSION __gettext_free_exp
+# define PLURAL_PARSE __gettextparse
+# define GERMANIC_PLURAL __gettext_germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION __gettext_extract_plural
+#elif defined (IN_LIBINTL)
+# define FREE_EXPRESSION libintl_gettext_free_exp
+# define PLURAL_PARSE libintl_gettextparse
+# define GERMANIC_PLURAL libintl_gettext_germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION libintl_gettext_extract_plural
+#else
+# define FREE_EXPRESSION free_plural_expression
+# define PLURAL_PARSE parse_plural_expression
+# define GERMANIC_PLURAL germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION extract_plural_expression
+#endif
+
+extern void FREE_EXPRESSION PARAMS ((struct expression *exp))
+	internal_function;
+extern int PLURAL_PARSE PARAMS ((struct parse_args *arg));
+extern const struct expression GERMANIC_PLURAL attribute_hidden;
+extern void EXTRACT_PLURAL_EXPRESSION PARAMS
+((const char *nullentry, const struct expression **pluralp,
+  unsigned long int *npluralsp)) internal_function;
+
+#if !defined (_LIBC) && !defined (IN_LIBINTL)
+extern unsigned long int plural_eval PARAMS ((const struct expression *pexp,
+											  unsigned long int n));
+#endif
+
+#endif /* _PLURAL_EXP_H */
diff -N -r --unified glibc-2.19/intl/plural-exp.h glibc-2.19-totalpartial/intl/plural-exp.h
--- glibc-2.19/intl/plural-exp.h	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/intl/plural-exp.h	2017-03-09 18:17:24.235958906 -0800
@@ -1,5 +1,5 @@
 /* Expression parsing and evaluation for plural form selection.
-   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001, 2002, 2005, 2007 Free Software Foundation, Inc.
    Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
    This file is part of the GNU C Library.
 
@@ -14,8 +14,9 @@
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 #ifndef _PLURAL_EXP_H
 #define _PLURAL_EXP_H
@@ -41,35 +42,35 @@
    plural form.  */
 struct expression
 {
-  int nargs;			/* Number of arguments.  */
+	int nargs;/* Number of arguments.  */
   enum operator
   {
-    /* Without arguments:  */
-    var,			/* The variable "n".  */
-    num,			/* Decimal number.  */
-    /* Unary operators:  */
-    lnot,			/* Logical NOT.  */
-    /* Binary operators:  */
-    mult,			/* Multiplication.  */
-    divide,			/* Division.  */
-    module,			/* Modulo operation.  */
-    plus,			/* Addition.  */
-    minus,			/* Subtraction.  */
-    less_than,			/* Comparison.  */
-    greater_than,		/* Comparison.  */
-    less_or_equal,		/* Comparison.  */
-    greater_or_equal,		/* Comparison.  */
-    equal,			/* Comparison for equality.  */
-    not_equal,			/* Comparison for inequality.  */
-    land,			/* Logical AND.  */
-    lor,			/* Logical OR.  */
-    /* Ternary operators:  */
-    qmop			/* Question mark operator.  */
+	  /* Without arguments:  */
+	  var,/* The variable "n".  */
+	  num,/* Decimal number.  */
+	  /* Unary operators:  */
+	  lnot,/* Logical NOT.  */
+	  /* Binary operators:  */
+	  mult,/* Multiplication.  */
+	  divide,/* Division.  */
+	  module,/* Modulo operation.  */
+	  plus,/* Addition.  */
+	  minus,/* Subtraction.  */
+	  less_than,/* Comparison.  */
+	  greater_than,/* Comparison.  */
+	  less_or_equal,/* Comparison.  */
+	  greater_or_equal,/* Comparison.  */
+	  equal,/* Comparison for equality.  */
+	  not_equal,/* Comparison for inequality.  */
+	  land,/* Logical AND.  */
+	  lor,/* Logical OR.  */
+	  /* Ternary operators:  */
+	  qmop/* Question mark operator.  */
   } operation;
   union
   {
-    unsigned long int num;	/* Number value for `num'.  */
-    struct expression *args[3];	/* Up to three arguments.  */
+	  unsigned long int num;/* Number value for `num'.  */
+	  struct expression *args[3];/* Up to three arguments.  */
   } val;
 };
 
@@ -77,8 +78,8 @@
    the result in a thread-safe way.  */
 struct parse_args
 {
-  const char *cp;
-  struct expression *res;
+	const char *cp;
+	struct expression *res;
 };
 
 
@@ -110,16 +111,16 @@
 #endif
 
 extern void FREE_EXPRESSION PARAMS ((struct expression *exp))
-     internal_function;
-extern int PLURAL_PARSE PARAMS ((void *arg));
+	internal_function;
+extern int PLURAL_PARSE PARAMS ((struct parse_args *arg));
 extern const struct expression GERMANIC_PLURAL attribute_hidden;
 extern void EXTRACT_PLURAL_EXPRESSION PARAMS
-  ((const char *nullentry, const struct expression **pluralp,
-    unsigned long int *npluralsp)) internal_function;
+((const char *nullentry, const struct expression **pluralp,
+  unsigned long int *npluralsp)) internal_function;
 
 #if !defined (_LIBC) && !defined (IN_LIBINTL)
 extern unsigned long int plural_eval PARAMS ((const struct expression *pexp,
-					      unsigned long int n));
+											  unsigned long int n));
 #endif
 
 #endif /* _PLURAL_EXP_H */
diff -N -r --unified glibc-2.19/intl/plural.y glibc-2.19-totalpartial/intl/plural.y
--- glibc-2.19/intl/plural.y	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/intl/plural.y	2017-03-09 18:17:24.231958905 -0800
@@ -1,6 +1,6 @@
 %{
 /* Expression parsing for plural form selection.
-   Copyright (C) 2000-2014 Free Software Foundation, Inc.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
 
@@ -15,8 +15,9 @@
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
 
 /* The bison generated parser uses alloca.  AIX 3 forces us to put this
    declaration at the beginning of the file.  The declaration in bison's
@@ -39,114 +40,112 @@
 #ifndef _LIBC
 # define __gettextparse PLURAL_PARSE
 #endif
-
-#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
-#define YYPARSE_PARAM	arg
-%}
-%pure_parser
+	%}
+%param {struct parse_args *arg}
+%define api.pure full
 %expect 7
 
 %union {
-  unsigned long int num;
-  enum operator op;
-  struct expression *exp;
+	unsigned long int num;
+	enum operator op;
+	struct expression *exp;
 }
 
 %{
 /* Prototypes for local functions.  */
-static struct expression *new_exp PARAMS ((int nargs, enum operator op,
-					   struct expression * const *args));
-static inline struct expression *new_exp_0 PARAMS ((enum operator op));
-static inline struct expression *new_exp_1 PARAMS ((enum operator op,
-						   struct expression *right));
-static struct expression *new_exp_2 PARAMS ((enum operator op,
-					     struct expression *left,
-					     struct expression *right));
-static inline struct expression *new_exp_3 PARAMS ((enum operator op,
-						   struct expression *bexp,
-						   struct expression *tbranch,
-						   struct expression *fbranch));
-static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
-static void yyerror PARAMS ((const char *str));
+	static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+											   struct expression * const *args));
+	static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+	static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+														struct expression *right));
+	static struct expression *new_exp_2 PARAMS ((enum operator op,
+												 struct expression *left,
+												 struct expression *right));
+	static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+														struct expression *bexp,
+														struct expression *tbranch,
+														struct expression *fbranch));
+	static int yylex PARAMS ((YYSTYPE *lval, struct parse_args *arg));
+	static void yyerror PARAMS ((struct parse_args *arg, const char *str));
 
 /* Allocation of expressions.  */
 
 static struct expression *
-new_exp (nargs, op, args)
-     int nargs;
-     enum operator op;
-     struct expression * const *args;
-{
-  int i;
-  struct expression *newp;
-
-  /* If any of the argument could not be malloc'ed, just return NULL.  */
-  for (i = nargs - 1; i >= 0; i--)
-    if (args[i] == NULL)
-      goto fail;
-
-  /* Allocate a new expression.  */
-  newp = (struct expression *) malloc (sizeof (*newp));
-  if (newp != NULL)
+	new_exp (nargs, op, args)
+	int nargs;
+enum operator op;
+struct expression * const *args;
+{
+	int i;
+	struct expression *newp;
+
+	/* If any of the argument could not be malloc'ed, just return NULL.  */
+	for (i = nargs - 1; i >= 0; i--)
+		if (args[i] == NULL)
+			goto fail;
+
+	/* Allocate a new expression.  */
+	newp = (struct expression *) malloc (sizeof (*newp));
+	if (newp != NULL)
     {
-      newp->nargs = nargs;
-      newp->operation = op;
-      for (i = nargs - 1; i >= 0; i--)
-	newp->val.args[i] = args[i];
-      return newp;
+		newp->nargs = nargs;
+		newp->operation = op;
+		for (i = nargs - 1; i >= 0; i--)
+			newp->val.args[i] = args[i];
+		return newp;
     }
 
- fail:
-  for (i = nargs - 1; i >= 0; i--)
-    FREE_EXPRESSION (args[i]);
+fail:
+	for (i = nargs - 1; i >= 0; i--)
+		FREE_EXPRESSION (args[i]);
 
-  return NULL;
+	return NULL;
 }
 
 static inline struct expression *
-new_exp_0 (op)
-     enum operator op;
+	new_exp_0 (op)
+	enum operator op;
 {
-  return new_exp (0, op, NULL);
+	return new_exp (0, op, NULL);
 }
 
 static inline struct expression *
-new_exp_1 (op, right)
-     enum operator op;
-     struct expression *right;
+	new_exp_1 (op, right)
+	enum operator op;
+struct expression *right;
 {
-  struct expression *args[1];
+	struct expression *args[1];
 
-  args[0] = right;
-  return new_exp (1, op, args);
+	args[0] = right;
+	return new_exp (1, op, args);
 }
 
 static struct expression *
-new_exp_2 (op, left, right)
-     enum operator op;
-     struct expression *left;
-     struct expression *right;
-{
-  struct expression *args[2];
-
-  args[0] = left;
-  args[1] = right;
-  return new_exp (2, op, args);
+	new_exp_2 (op, left, right)
+	enum operator op;
+struct expression *left;
+struct expression *right;
+{
+	struct expression *args[2];
+
+	args[0] = left;
+	args[1] = right;
+	return new_exp (2, op, args);
 }
 
 static inline struct expression *
-new_exp_3 (op, bexp, tbranch, fbranch)
-     enum operator op;
-     struct expression *bexp;
-     struct expression *tbranch;
-     struct expression *fbranch;
-{
-  struct expression *args[3];
-
-  args[0] = bexp;
-  args[1] = tbranch;
-  args[2] = fbranch;
-  return new_exp (3, op, args);
+	new_exp_3 (op, bexp, tbranch, fbranch)
+	enum operator op;
+struct expression *bexp;
+struct expression *tbranch;
+struct expression *fbranch;
+{
+	struct expression *args[3];
+
+	args[0] = bexp;
+	args[1] = tbranch;
+	args[2] = fbranch;
+	return new_exp (3, op, args);
 }
 
 %}
@@ -156,14 +155,14 @@
    There is no unary minus and no bitwise operators.
    Operators with the same syntactic behaviour have been merged into a single
    token, to save space in the array generated by bison.  */
-%right '?'		/*   ?		*/
-%left '|'		/*   ||		*/
-%left '&'		/*   &&		*/
-%left EQUOP2		/*   == !=	*/
-%left CMPOP2		/*   < > <= >=	*/
-%left ADDOP2		/*   + -	*/
-%left MULOP2		/*   * / %	*/
-%right '!'		/*   !		*/
+%right '?'/*   ?*/
+%left '|'/*   ||*/
+%left '&'/*   &&*/
+%left EQUOP2/*   == !=*/
+%left CMPOP2/*   < > <= >=*/
+%left ADDOP2/*   + -*/
+%left MULOP2/*   * / %*/
+%right '!'/*   !*/
 
 %token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2
 %token <num> NUMBER
@@ -171,239 +170,240 @@
 
 %%
 
-start:	  exp
-	  {
-	    if ($1 == NULL)
-	      YYABORT;
-	    ((struct parse_args *) arg)->res = $1;
-	  }
-	;
-
-exp:	  exp '?' exp ':' exp
-	  {
-	    $$ = new_exp_3 (qmop, $1, $3, $5);
-	  }
-	| exp '|' exp
-	  {
-	    $$ = new_exp_2 (lor, $1, $3);
-	  }
-	| exp '&' exp
-	  {
-	    $$ = new_exp_2 (land, $1, $3);
-	  }
-	| exp EQUOP2 exp
-	  {
-	    $$ = new_exp_2 ($2, $1, $3);
-	  }
-	| exp CMPOP2 exp
-	  {
-	    $$ = new_exp_2 ($2, $1, $3);
-	  }
-	| exp ADDOP2 exp
-	  {
-	    $$ = new_exp_2 ($2, $1, $3);
-	  }
-	| exp MULOP2 exp
-	  {
-	    $$ = new_exp_2 ($2, $1, $3);
-	  }
-	| '!' exp
-	  {
-	    $$ = new_exp_1 (lnot, $2);
-	  }
-	| 'n'
-	  {
-	    $$ = new_exp_0 (var);
-	  }
-	| NUMBER
-	  {
-	    if (($$ = new_exp_0 (num)) != NULL)
-	      $$->val.num = $1;
-	  }
-	| '(' exp ')'
-	  {
-	    $$ = $2;
-	  }
-	;
+start:  exp
+{
+	if ($1 == NULL)
+		YYABORT;
+	arg->res = $1;
+}
+;
+
+exp:  exp '?' exp ':' exp
+{
+	$$ = new_exp_3 (qmop, $1, $3, $5);
+}
+| exp '|' exp
+{
+	$$ = new_exp_2 (lor, $1, $3);
+}
+| exp '&' exp
+{
+	$$ = new_exp_2 (land, $1, $3);
+}
+| exp EQUOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| exp CMPOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| exp ADDOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| exp MULOP2 exp
+{
+	$$ = new_exp_2 ($2, $1, $3);
+}
+| '!' exp
+{
+	$$ = new_exp_1 (lnot, $2);
+}
+| 'n'
+{
+	$$ = new_exp_0 (var);
+}
+| NUMBER
+{
+	if (($$ = new_exp_0 (num)) != NULL)
+		$$->val.num = $1;
+}
+| '(' exp ')'
+{
+	$$ = $2;
+}
+;
 
 %%
 
 void
 internal_function
 FREE_EXPRESSION (exp)
-     struct expression *exp;
+struct expression *exp;
 {
-  if (exp == NULL)
-    return;
+	if (exp == NULL)
+		return;
 
-  /* Handle the recursive case.  */
-  switch (exp->nargs)
+	/* Handle the recursive case.  */
+	switch (exp->nargs)
     {
-    case 3:
-      FREE_EXPRESSION (exp->val.args[2]);
-      /* FALLTHROUGH */
-    case 2:
-      FREE_EXPRESSION (exp->val.args[1]);
-      /* FALLTHROUGH */
-    case 1:
-      FREE_EXPRESSION (exp->val.args[0]);
-      /* FALLTHROUGH */
-    default:
-      break;
+		case 3:
+			FREE_EXPRESSION (exp->val.args[2]);
+			/* FALLTHROUGH */
+		case 2:
+			FREE_EXPRESSION (exp->val.args[1]);
+			/* FALLTHROUGH */
+		case 1:
+			FREE_EXPRESSION (exp->val.args[0]);
+			/* FALLTHROUGH */
+		default:
+			break;
     }
 
-  free (exp);
+	free (exp);
 }
 
 
 static int
-yylex (lval, pexp)
-     YYSTYPE *lval;
-     const char **pexp;
+yylex (lval, arg)
+YYSTYPE *lval;
+struct parse_args *arg;
 {
-  const char *exp = *pexp;
-  int result;
+	const char *exp = arg->cp;
+	int result;
 
-  while (1)
+	while (1)
     {
-      if (exp[0] == '\0')
-	{
-	  *pexp = exp;
-	  return YYEOF;
-	}
+		if (exp[0] == '\0')
+		{
+			arg->cp = exp;
+			return YYEOF;
+		}
 
-      if (exp[0] != ' ' && exp[0] != '\t')
-	break;
+		if (exp[0] != ' ' && exp[0] != '\t')
+			break;
 
-      ++exp;
+		++exp;
     }
 
-  result = *exp++;
-  switch (result)
+	result = *exp++;
+	switch (result)
     {
-    case '0': case '1': case '2': case '3': case '4':
-    case '5': case '6': case '7': case '8': case '9':
-      {
-	unsigned long int n = result - '0';
-	while (exp[0] >= '0' && exp[0] <= '9')
-	  {
-	    n *= 10;
-	    n += exp[0] - '0';
-	    ++exp;
-	  }
-	lval->num = n;
-	result = NUMBER;
-      }
-      break;
-
-    case '=':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = equal;
-	  result = EQUOP2;
-	}
-      else
-	result = YYERRCODE;
-      break;
-
-    case '!':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = not_equal;
-	  result = EQUOP2;
-	}
-      break;
-
-    case '&':
-    case '|':
-      if (exp[0] == result)
-	++exp;
-      else
-	result = YYERRCODE;
-      break;
-
-    case '<':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = less_or_equal;
-	}
-      else
-	lval->op = less_than;
-      result = CMPOP2;
-      break;
-
-    case '>':
-      if (exp[0] == '=')
-	{
-	  ++exp;
-	  lval->op = greater_or_equal;
-	}
-      else
-	lval->op = greater_than;
-      result = CMPOP2;
-      break;
-
-    case '*':
-      lval->op = mult;
-      result = MULOP2;
-      break;
-
-    case '/':
-      lval->op = divide;
-      result = MULOP2;
-      break;
-
-    case '%':
-      lval->op = module;
-      result = MULOP2;
-      break;
-
-    case '+':
-      lval->op = plus;
-      result = ADDOP2;
-      break;
-
-    case '-':
-      lval->op = minus;
-      result = ADDOP2;
-      break;
-
-    case 'n':
-    case '?':
-    case ':':
-    case '(':
-    case ')':
-      /* Nothing, just return the character.  */
-      break;
-
-    case ';':
-    case '\n':
-    case '\0':
-      /* Be safe and let the user call this function again.  */
-      --exp;
-      result = YYEOF;
-      break;
+		case '0': case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+		{
+			unsigned long int n = result - '0';
+			while (exp[0] >= '0' && exp[0] <= '9')
+			{
+				n *= 10;
+				n += exp[0] - '0';
+				++exp;
+			}
+			lval->num = n;
+			result = NUMBER;
+		}
+		break;
+
+		case '=':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = equal;
+				result = EQUOP2;
+			}
+			else
+				result = YYERRCODE;
+			break;
+
+		case '!':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = not_equal;
+				result = EQUOP2;
+			}
+			break;
+
+		case '&':
+		case '|':
+			if (exp[0] == result)
+				++exp;
+			else
+				result = YYERRCODE;
+			break;
+
+		case '<':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = less_or_equal;
+			}
+			else
+				lval->op = less_than;
+			result = CMPOP2;
+			break;
+
+		case '>':
+			if (exp[0] == '=')
+			{
+				++exp;
+				lval->op = greater_or_equal;
+			}
+			else
+				lval->op = greater_than;
+			result = CMPOP2;
+			break;
+
+		case '*':
+			lval->op = mult;
+			result = MULOP2;
+			break;
+
+		case '/':
+			lval->op = divide;
+			result = MULOP2;
+			break;
+
+		case '%':
+			lval->op = module;
+			result = MULOP2;
+			break;
+
+		case '+':
+			lval->op = plus;
+			result = ADDOP2;
+			break;
+
+		case '-':
+			lval->op = minus;
+			result = ADDOP2;
+			break;
+
+		case 'n':
+		case '?':
+		case ':':
+		case '(':
+		case ')':
+			/* Nothing, just return the character.  */
+			break;
+
+		case ';':
+		case '\n':
+		case '\0':
+			/* Be safe and let the user call this function again.  */
+			--exp;
+			result = YYEOF;
+			break;
 
-    default:
-      result = YYERRCODE;
+		default:
+			result = YYERRCODE;
 #if YYDEBUG != 0
-      --exp;
+			--exp;
 #endif
-      break;
+			break;
     }
 
-  *pexp = exp;
+	arg->cp = exp; 
 
-  return result;
+	return result;
 }
 
 
 static void
-yyerror (str)
-     const char *str;
+yyerror (arg, str)
+struct parse_args *arg;
+const char *str;
 {
-  /* Do nothing.  We don't print error messages here.  */
+	/* Do nothing.  We don't print error messages here.  */
 }
diff -N -r --unified glibc-2.19/malloc/arena.c glibc-2.19-totalpartial/malloc/arena.c
--- glibc-2.19/malloc/arena.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/malloc/arena.c	2017-03-15 16:59:21.370388159 -0700
@@ -526,7 +526,7 @@
 new_heap (size_t size, size_t top_pad)
 {
   size_t page_mask = GLRO (dl_pagesize) - 1;
-  char *p1, *p2;
+  char *p1, *p2, *prev_heap_area;
   unsigned long ul;
   heap_info *h;
 
@@ -545,12 +545,34 @@
      mapping (on Linux, this is the case for all non-writable mappings
      anyway). */
   p2 = MAP_FAILED;
-  if (aligned_heap_area)
+  prev_heap_area = atomic_load(aligned_heap_area);
+  if (prev_heap_area)
     {
-      p2 = (char *) MMAP (aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,
+      p2 = (char *) MMAP (prev_heap_area, HEAP_MAX_SIZE, PROT_NONE,
                           MAP_NORESERVE);
-      aligned_heap_area = NULL;
-      if (p2 != MAP_FAILED && ((unsigned long) p2 & (HEAP_MAX_SIZE - 1)))
+      atomic_store(aligned_heap_area, NULL);
+      /* MVEE Patch:
+	 The original code tries to do the following:
+	 1) It tries to allocate a new heap that expands the previously
+	 allocated heap (prev_heap_area) downwards. This way, 
+	 fragmentation can be minimized.
+	 2) It ensures that the newly allocated heap is HEAP_MAX_SIZE
+	 aligned. If it is not, the allocation is considered to have failed
+	 and malloc will allocate a HEAP_MAX_SIZE aligned block elsewhere.
+
+	 Inside the MVEE though, there is a bit of a problem. With ASLR
+	 enabled, it is very much possible that some replicae get a
+	 HEAP_MAX_SIZE aligned block, while others do not. This can happen
+	 because the previous heap cannot be extended downwards and the
+	 kernel picks a new base address randomly.
+
+	 In order to maintain consistent behavior later on, all allocations
+	 must either fail or succeed.
+	 => if we run under the MVEE's control, we check whether all
+	 heaps are aligned. If not, we unmap all of them, even if some
+	 WERE aligned!!!
+       */
+      if (p2 != MAP_FAILED && !mvee_all_heaps_aligned(p2, HEAP_MAX_SIZE))
         {
           __munmap (p2, HEAP_MAX_SIZE);
           p2 = MAP_FAILED;
@@ -558,6 +580,17 @@
     }
   if (p2 == MAP_FAILED)
     {
+      /* MVEE Patch:
+	 The MVEE will hold its internal MMAN lock across this mmap call
+	 and the subsequent (optional) munmap calls, thus ensuring that
+	 all replicae will have a consistent memory map after this whole
+	 operation.
+	 
+	 Because of this, we have to make sure that the MMAP+munmaps
+	 sequence is atomic and cannot block (=> we should _NOT_ grab
+	 ANY locks until after the last munmap)	
+       */
+	  (void)mvee_all_heaps_aligned(0, HEAP_MAX_SIZE);
       p1 = (char *) MMAP (0, HEAP_MAX_SIZE << 1, PROT_NONE, MAP_NORESERVE);
       if (p1 != MAP_FAILED)
         {
@@ -566,9 +599,10 @@
           ul = p2 - p1;
           if (ul)
             __munmap (p1, ul);
-          else
-            aligned_heap_area = p2 + HEAP_MAX_SIZE;
+
           __munmap (p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);
+
+	  atomic_store(aligned_heap_area, p2 + HEAP_MAX_SIZE);
         }
       else
         {
@@ -578,7 +612,8 @@
           if (p2 == MAP_FAILED)
             return 0;
 
-          if ((unsigned long) p2 & (HEAP_MAX_SIZE - 1))
+	  /* MVEE patch: see comment above */
+          if (!mvee_all_heaps_aligned(p2, HEAP_MAX_SIZE))
             {
               __munmap (p2, HEAP_MAX_SIZE);
               return 0;
@@ -661,8 +696,8 @@
 
 #define delete_heap(heap) \
   do {									      \
-      if ((char *) (heap) + HEAP_MAX_SIZE == aligned_heap_area)		      \
-        aligned_heap_area = NULL;					      \
+    if ((char *) (heap) + HEAP_MAX_SIZE == atomic_load(aligned_heap_area)) \
+      atomic_store(aligned_heap_area, NULL);				\
       __munmap ((char *) (heap), HEAP_MAX_SIZE);			      \
     } while (0)
 
@@ -786,14 +821,10 @@
 static mstate
 get_free_list (void)
 {
+  (void) mutex_lock (&list_lock);
   mstate result = free_list;
-  if (result != NULL)
-    {
-      (void) mutex_lock (&list_lock);
-      result = free_list;
       if (result != NULL)
         free_list = result->next_free;
-      (void) mutex_unlock (&list_lock);
 
       if (result != NULL)
         {
@@ -802,7 +833,8 @@
           tsd_setspecific (arena_key, (void *) result);
           THREAD_STAT (++(result->stat_lock_loop));
         }
-    }
+
+  (void) mutex_unlock (&list_lock);
 
   return result;
 }
@@ -858,24 +890,24 @@
   if (a == NULL)
     {
       /* Nothing immediately available, so generate a new arena.  */
-      if (narenas_limit == 0)
+      if (atomic_load(narenas_limit) == 0)
         {
           if (mp_.arena_max != 0)
-            narenas_limit = mp_.arena_max;
-          else if (narenas > mp_.arena_test)
+            atomic_store(narenas_limit, mp_.arena_max);
+          else if (atomic_load(narenas) > mp_.arena_test)
             {
               int n = __get_nprocs ();
 
               if (n >= 1)
-                narenas_limit = NARENAS_FROM_NCORES (n);
+                atomic_store(narenas_limit, NARENAS_FROM_NCORES (n));
               else
                 /* We have no information about the system.  Assume two
                    cores.  */
-                narenas_limit = NARENAS_FROM_NCORES (2);
+                atomic_store(narenas_limit, NARENAS_FROM_NCORES (2));
             }
         }
     repeat:;
-      size_t n = narenas;
+      size_t n = atomic_load(narenas);
       /* NB: the following depends on the fact that (size_t)0 - 1 is a
          very large number and that the underflow is OK.  If arena_max
          is set the value of arena_test is irrelevant.  If arena_test
@@ -883,7 +915,7 @@
          narenas_limit is 0.  There is no possibility for narenas to
          be too big for the test to always fail since there is not
          enough address space to create that many arenas.  */
-      if (__builtin_expect (n <= narenas_limit - 1, 0))
+      if (__builtin_expect (n <= atomic_load(narenas_limit) - 1, 0))
         {
           if (catomic_compare_and_exchange_bool_acq (&narenas, n + 1, n))
             goto repeat;
diff -N -r --unified glibc-2.19/malloc/malloc.c glibc-2.19-totalpartial/malloc/malloc.c
--- glibc-2.19/malloc/malloc.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/malloc/malloc.c	2017-03-04 01:35:20.346744068 -0800
@@ -1705,6 +1705,9 @@
 
 struct malloc_par
 {
+  /* MVEE patch */
+  mutex_t mutex;
+
   /* Tunable parameters */
   unsigned long trim_threshold;
   INTERNAL_SIZE_T top_pad;
@@ -1748,6 +1751,7 @@
 
 static struct malloc_par mp_ =
 {
+  .mutex = MUTEX_INITIALIZER,
   .top_pad = DEFAULT_TOP_PAD,
   .n_mmaps_max = DEFAULT_MMAP_MAX,
   .mmap_threshold = DEFAULT_MMAP_THRESHOLD,
@@ -2275,10 +2279,12 @@
      allocated mmapped regions, try to directly map this request
      rather than expanding top.
    */
-
+  
+  (void) mutex_lock(&mp_.mutex);
   if ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold) &&
       (mp_.n_mmaps < mp_.n_mmaps_max))
     {
+      (void) mutex_unlock(&mp_.mutex);
       char *mm;           /* return value from mmap call*/
 
     try_mmap:
@@ -2349,6 +2355,8 @@
             }
         }
     }
+  else
+    (void) mutex_unlock(&mp_.mutex);
 
   /* Record incoming configuration of top */
 
@@ -2883,13 +2891,17 @@
 
   arena_lock (ar_ptr, bytes);
   if (!ar_ptr)
-    return 0;
+    {
+      MVEE_MALLOC_HOOK(LIBC_MALLOC, 0, bytes, 0, 0);
+      return 0;
+    }
 
   victim = _int_malloc (ar_ptr, bytes);
   if (!victim)
     {
       LIBC_PROBE (memory_malloc_retry, 1, bytes);
       ar_ptr = arena_get_retry (ar_ptr, bytes);
+      MVEE_MALLOC_HOOK(LIBC_MALLOC, 1, bytes, ar_ptr, 0);
       if (__builtin_expect (ar_ptr != NULL, 1))
         {
           victim = _int_malloc (ar_ptr, bytes);
@@ -2897,9 +2909,15 @@
         }
     }
   else
-    (void) mutex_unlock (&ar_ptr->mutex);
+    {
+      MVEE_MALLOC_HOOK(LIBC_MALLOC, 2, bytes, ar_ptr, victim);
+      (void) mutex_unlock (&ar_ptr->mutex);
+    }
+
   assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||
           ar_ptr == arena_for_chunk (mem2chunk (victim)));
+
+  MVEE_MALLOC_HOOK(LIBC_MALLOC, 3, bytes, ar_ptr, victim);
   return victim;
 }
 libc_hidden_def (__libc_malloc)
@@ -2925,7 +2943,9 @@
 
   if (chunk_is_mmapped (p))                       /* release mmapped memory. */
     {
+      MVEE_MALLOC_HOOK(LIBC_FREE, 0, chunksize(p), 0, p);
       /* see if the dynamic brk/mmap threshold needs adjusting */
+      (void) mutex_lock(&mp_.mutex);
       if (!mp_.no_dyn_threshold
           && p->size > mp_.mmap_threshold
           && p->size <= DEFAULT_MMAP_THRESHOLD_MAX)
@@ -2935,11 +2955,13 @@
           LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,
                       mp_.mmap_threshold, mp_.trim_threshold);
         }
+      (void) mutex_unlock(&mp_.mutex);
       munmap_chunk (p);
       return;
     }
 
   ar_ptr = arena_for_chunk (p);
+  MVEE_MALLOC_HOOK(LIBC_FREE, 1, chunksize(p), ar_ptr, p);
   _int_free (ar_ptr, p, 0);
 }
 libc_hidden_def (__libc_free)
@@ -2997,15 +3019,22 @@
 #endif
       /* Note the extra SIZE_SZ overhead. */
       if (oldsize - SIZE_SZ >= nb)
-        return oldmem;                         /* do nothing */
+	{
+	  MVEE_MALLOC_HOOK(LIBC_REALLOC, 0, bytes, 0, oldmem);
+	  return oldmem;                         /* do nothing */
+	}
 
       /* Must alloc, copy, free. */
       newmem = __libc_malloc (bytes);
       if (newmem == 0)
-        return 0;              /* propagate failure */
+	{
+	  MVEE_MALLOC_HOOK(LIBC_REALLOC, 1, bytes, 0, oldmem);
+	  return 0;              /* propagate failure */
+	}
 
       memcpy (newmem, oldmem, oldsize - 2 * SIZE_SZ);
       munmap_chunk (oldp);
+      MVEE_MALLOC_HOOK(LIBC_REALLOC, 2, bytes, 0, newmem);
       return newmem;
     }
 
@@ -3023,6 +3052,7 @@
 #endif
 
 
+  MVEE_MALLOC_HOOK(LIBC_REALLOC, 3, bytes, ar_ptr, oldp);
   newp = _int_realloc (ar_ptr, oldp, oldsize, nb);
 
   (void) mutex_unlock (&ar_ptr->mutex);
@@ -3031,6 +3061,7 @@
 
   if (newp == NULL)
     {
+      MVEE_MALLOC_HOOK(LIBC_REALLOC, 4, bytes, 0, oldp);
       /* Try harder to allocate memory in other arenas.  */
       LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);
       newp = __libc_malloc (bytes);
@@ -3041,6 +3072,7 @@
         }
     }
 
+  MVEE_MALLOC_HOOK(LIBC_REALLOC, 5, bytes, 0, newp);
   return newp;
 }
 libc_hidden_def (__libc_realloc)
@@ -3049,6 +3081,7 @@
 __libc_memalign (size_t alignment, size_t bytes)
 {
   void *address = RETURN_ADDRESS (0);
+  MVEE_MALLOC_HOOK(LIBC_MEMALIGN, 0, bytes, NULL, (void*)alignment);
   return _mid_memalign (alignment, bytes, address);
 }
 
@@ -3115,6 +3148,7 @@
     (void) mutex_unlock (&ar_ptr->mutex);
   assert (!p || chunk_is_mmapped (mem2chunk (p)) ||
           ar_ptr == arena_for_chunk (mem2chunk (p)));
+  MVEE_MALLOC_HOOK(LIBC_MEMALIGN, 1, bytes, ar_ptr, p);
   return p;
 }
 /* For ISO C11.  */
@@ -3191,9 +3225,13 @@
 
   sz = bytes;
 
+  MVEE_MALLOC_HOOK(LIBC_CALLOC, 0, bytes, 0, 0);
   arena_get (av, sz);
   if (!av)
-    return 0;
+    {
+      MVEE_MALLOC_HOOK(LIBC_CALLOC, 1, bytes, 0, 0);
+      return 0;
+    }
 
   /* Check if we hand out the top chunk, in which case there may be no
      need to clear. */
@@ -3221,6 +3259,7 @@
 
   if (mem == 0)
     {
+      MVEE_MALLOC_HOOK(LIBC_CALLOC, 2, bytes, 0, 0);
       LIBC_PROBE (memory_calloc_retry, 1, sz);
       av = arena_get_retry (av, sz);
       if (__builtin_expect (av != NULL, 1))
@@ -3238,6 +3277,7 @@
   /* Two optional cases in which clearing not necessary */
   if (chunk_is_mmapped (p))
     {
+      MVEE_MALLOC_HOOK(LIBC_CALLOC, 3, bytes, 0, 0);
       if (__builtin_expect (perturb_byte, 0))
         return memset (mem, 0, sz);
 
@@ -3254,6 +3294,8 @@
     }
 #endif
 
+  MVEE_MALLOC_HOOK(LIBC_CALLOC, 4, bytes, 0, 0);
+
   /* Unroll clear of <= 36 bytes (72 if 8byte sizes).  We know that
      contents have an odd number of INTERNAL_SIZE_T-sized words;
      minimally 3.  */
@@ -3328,6 +3370,8 @@
 
   checked_request2size (bytes, nb);
 
+  MVEE_MALLOC_HOOK(_INT_MALLOC, 0, nb, 0, 0);
+
   /*
      If the size qualifies as a fastbin, first check corresponding bin.
      This code is safe to execute even if av is not yet initialized, so we
@@ -3335,8 +3379,9 @@
    */
 
   if ((unsigned long) (nb) <= (unsigned long) (get_max_fast ()))
-    {
+    {      
       idx = fastbin_index (nb);
+      MVEE_MALLOC_HOOK(_INT_MALLOC, 1, nb, av, idx);
       mfastbinptr *fb = &fastbin (av, idx);
       mchunkptr pp = *fb;
       do
@@ -3349,6 +3394,7 @@
              != victim);
       if (victim != 0)
         {
+	  MVEE_MALLOC_HOOK(_INT_MALLOC, 2, nb, av, victim);
           if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
             {
               errstr = "malloc(): memory corruption (fast)";
@@ -3361,6 +3407,10 @@
           alloc_perturb (p, bytes);
           return p;
         }
+      else
+	{
+	  MVEE_MALLOC_HOOK(_INT_MALLOC, 3, nb, av, 0);
+	}
     }
 
   /*
@@ -3375,13 +3425,18 @@
     {
       idx = smallbin_index (nb);
       bin = bin_at (av, idx);
+      MVEE_MALLOC_HOOK(_INT_MALLOC, 4, nb, av, idx);
 
       if ((victim = last (bin)) != bin)
         {
           if (victim == 0) /* initialization check */
-            malloc_consolidate (av);
+	    {
+	      MVEE_MALLOC_HOOK(_INT_MALLOC, 5, nb, av, idx);
+	      malloc_consolidate (av);
+	    }
           else
             {
+	      MVEE_MALLOC_HOOK(_INT_MALLOC, 6, nb, av, victim);
               bck = victim->bk;
               if (__builtin_expect (bck->fd != victim, 0))
                 {
@@ -3416,8 +3471,12 @@
   else
     {
       idx = largebin_index (nb);
+      MVEE_MALLOC_HOOK(_INT_MALLOC, 7, nb, av, idx);
       if (have_fastchunks (av))
-        malloc_consolidate (av);
+	{
+	  MVEE_MALLOC_HOOK(_INT_MALLOC, 8, nb, av, 0);
+	  malloc_consolidate (av);
+	}
     }
 
   /*
@@ -3460,6 +3519,7 @@
             {
               /* split and reattach remainder */
               remainder_size = size - nb;
+	      MVEE_MALLOC_HOOK(_INT_MALLOC, 9, size, av, victim);
               remainder = chunk_at_offset (victim, nb);
               unsorted_chunks (av)->bk = unsorted_chunks (av)->fd = remainder;
               av->last_remainder = remainder;
@@ -3489,6 +3549,7 @@
 
           if (size == nb)
             {
+	      MVEE_MALLOC_HOOK(_INT_MALLOC, 10, size, av, victim);
               set_inuse_bit_at_offset (victim, size);
               if (av != &main_arena)
                 victim->size |= NON_MAIN_ARENA;
@@ -3562,7 +3623,10 @@
 
 #define MAX_ITERS       10000
           if (++iters >= MAX_ITERS)
-            break;
+	    {
+	      MVEE_MALLOC_HOOK(_INT_MALLOC, 11, nb, av, 0);
+	      break;
+	    }
         }
 
       /*
@@ -3574,6 +3638,8 @@
         {
           bin = bin_at (av, idx);
 
+	  MVEE_MALLOC_HOOK(_INT_MALLOC, 12, nb, av, idx);
+
           /* skip scan if empty or largest chunk is too small */
           if ((victim = first (bin)) != bin &&
               (unsigned long) (victim->size) >= (unsigned long) (nb))
@@ -3588,6 +3654,8 @@
               if (victim != last (bin) && victim->size == victim->fd->size)
                 victim = victim->fd;
 
+	      MVEE_MALLOC_HOOK(_INT_MALLOC, 13, nb, av, victim);
+
               remainder_size = size - nb;
               unlink (victim, bck, fwd);
 
@@ -3649,6 +3717,8 @@
       map = av->binmap[block];
       bit = idx2bit (idx);
 
+      MVEE_MALLOC_HOOK(_INT_MALLOC, 14, nb, av, idx);
+
       for (;; )
         {
           /* Skip rest of block if there are no more set bits in this block.  */
@@ -3688,6 +3758,8 @@
             {
               size = chunksize (victim);
 
+	      MVEE_MALLOC_HOOK(_INT_MALLOC, 15, size, av, idx);
+
               /*  We know the first chunk in this bin is big enough to use. */
               assert ((unsigned long) (size) >= (unsigned long) (nb));
 
@@ -3764,6 +3836,7 @@
 
       if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
         {
+	  MVEE_MALLOC_HOOK(_INT_MALLOC, 16, size, av, idx);
           remainder_size = size - nb;
           remainder = chunk_at_offset (victim, nb);
           av->top = remainder;
@@ -3787,6 +3860,7 @@
             idx = smallbin_index (nb);
           else
             idx = largebin_index (nb);
+	  MVEE_MALLOC_HOOK(_INT_MALLOC, 17, nb, av, idx);
         }
 
       /*
@@ -3794,6 +3868,7 @@
        */
       else
         {
+	  MVEE_MALLOC_HOOK(_INT_MALLOC, 18, nb, av, 0);
           void *p = sysmalloc (nb, av);
           if (p != NULL)
             alloc_perturb (p, bytes);
@@ -3863,6 +3938,8 @@
 #endif
       ) {
 
+    MVEE_MALLOC_HOOK(_INT_FREE, 0, size, av, p);
+
     if (__builtin_expect (chunk_at_offset (p, size)->size <= 2 * SIZE_SZ, 0)
 	|| __builtin_expect (chunksize (chunk_at_offset (p, size))
 			     >= av->system_mem, 0))
@@ -3890,15 +3967,19 @@
 
     free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);
 
+    if (!have_lock)
+      (void) mutex_lock(&av->mutex);
+
     set_fastchunks(av);
     unsigned int idx = fastbin_index(size);
     fb = &fastbin (av, idx);
 
+    MVEE_MALLOC_HOOK(_INT_FREE, 1, size, av, idx);
+
     /* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */
     mchunkptr old = *fb, old2;
     unsigned int old_idx = ~0u;
-    do
-      {
+
 	/* Check that the top of the bin is not the record we are going to add
 	   (i.e., double free).  */
 	if (__builtin_expect (old == p, 0))
@@ -3913,8 +3994,10 @@
 	if (have_lock && old != NULL)
 	  old_idx = fastbin_index(chunksize(old));
 	p->fd = old2 = old;
-      }
-    while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);
+	*fb = p;
+
+    if (!have_lock)
+      (void) mutex_unlock(&av->mutex);
 
     if (have_lock && old != NULL && __builtin_expect (old_idx != idx, 0))
       {
@@ -3942,6 +4025,8 @@
       locked = 1;
     }
 
+    MVEE_MALLOC_HOOK(_INT_FREE, 2, size, av, 0);
+
     nextchunk = chunk_at_offset(p, size);
 
     /* Lightweight tests: check whether the block is already the
@@ -3979,6 +4064,7 @@
     /* consolidate backward */
     if (!prev_inuse(p)) {
       prevsize = p->prev_size;
+      MVEE_MALLOC_HOOK(_INT_FREE, 3, prevsize, av, 0);
       size += prevsize;
       p = chunk_at_offset(p, -((long) prevsize));
       unlink(p, bck, fwd);
@@ -4030,6 +4116,7 @@
     */
 
     else {
+      MVEE_MALLOC_HOOK(_INT_FREE, 4, size, av, 0);
       size += nextsize;
       set_head(p, size | PREV_INUSE);
       av->top = p;
@@ -4050,14 +4137,22 @@
     */
 
     if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
+      MVEE_MALLOC_HOOK(_INT_FREE, 5, size, av, 0);
+
       if (have_fastchunks(av))
 	malloc_consolidate(av);
 
       if (av == &main_arena) {
 #ifndef MORECORE_CANNOT_TRIM
+	(void) mutex_lock(&mp_.mutex);
 	if ((unsigned long)(chunksize(av->top)) >=
 	    (unsigned long)(mp_.trim_threshold))
-	  systrim(mp_.top_pad, av);
+	  {
+	    (void) mutex_unlock(&mp_.mutex);
+	    systrim(mp_.top_pad, av);
+	  }
+	else
+	  (void) mutex_unlock(&mp_.mutex);
 #endif
       } else {
 	/* Always try heap_trim(), even if the top chunk is not
@@ -4079,6 +4174,7 @@
   */
 
   else {
+    MVEE_MALLOC_HOOK(_INT_FREE, 6, size, av, p);
     munmap_chunk (p);
   }
 }
@@ -4115,6 +4211,8 @@
   mchunkptr       bck;
   mchunkptr       fwd;
 
+  int cnt = 0;
+
   /*
     If max_fast is 0, we know that av hasn't
     yet been initialized, in which case do so below
@@ -4184,6 +4282,8 @@
 	    av->top = p;
 	  }
 
+	  cnt++;
+
 	} while ( (p = nextp) != 0);
 
       }
@@ -4193,6 +4293,8 @@
     malloc_init_state(av);
     check_malloc_state(av);
   }
+
+  MVEE_MALLOC_HOOK(MALLOC_CONSOLIDATE, 0, cnt, av, 0);
 }
 
 /*
@@ -4260,6 +4362,7 @@
           (unsigned long) (newsize = oldsize + nextsize) >=
           (unsigned long) (nb + MINSIZE))
         {
+	  MVEE_MALLOC_HOOK(_INT_REALLOC, 0, newsize, av, next);
           set_head_size (oldp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));
           av->top = chunk_at_offset (oldp, nb);
           set_head (av->top, (newsize - nb) | PREV_INUSE);
@@ -4273,6 +4376,7 @@
                (unsigned long) (newsize = oldsize + nextsize) >=
                (unsigned long) (nb))
         {
+	  MVEE_MALLOC_HOOK(_INT_REALLOC, 1, newsize, av, next);
           newp = oldp;
           unlink (next, bck, fwd);
         }
@@ -4280,6 +4384,7 @@
       /* allocate, copy, free */
       else
         {
+	  MVEE_MALLOC_HOOK(_INT_REALLOC, 2, newsize, av, 0);
           newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);
           if (newmem == 0)
             return 0; /* propagate failure */
@@ -4292,6 +4397,7 @@
            */
           if (newp == next)
             {
+	      MVEE_MALLOC_HOOK(_INT_REALLOC, 3, newsize, av, 0);
               newsize += oldsize;
               newp = oldp;
             }
@@ -4302,6 +4408,7 @@
                  We know that contents have an odd number of
                  INTERNAL_SIZE_T-sized words; minimally 3.
                */
+	      MVEE_MALLOC_HOOK(_INT_REALLOC, 4, newsize, av, newmem);
 
               copysize = oldsize - SIZE_SZ;
               s = (INTERNAL_SIZE_T *) (chunk2mem (oldp));
@@ -4349,11 +4456,13 @@
 
   if (remainder_size < MINSIZE)   /* not enough extra to split off */
     {
+      MVEE_MALLOC_HOOK(_INT_REALLOC, 5, newsize, av, newp);
       set_head_size (newp, newsize | (av != &main_arena ? NON_MAIN_ARENA : 0));
       set_inuse_bit_at_offset (newp, newsize);
     }
   else   /* split remainder */
     {
+      MVEE_MALLOC_HOOK(_INT_REALLOC, 6, newsize, av, newp);
       remainder = chunk_at_offset (newp, nb);
       set_head_size (newp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));
       set_head (remainder, remainder_size | PREV_INUSE |
@@ -4532,13 +4641,15 @@
     ptmalloc_init ();
 
   mstate ar_ptr = &main_arena;
+  mstate tmp;
   do
     {
       (void) mutex_lock (&ar_ptr->mutex);
       result |= mtrim (ar_ptr, s);
+      tmp = ar_ptr->next;
       (void) mutex_unlock (&ar_ptr->mutex);
 
-      ar_ptr = ar_ptr->next;
+      ar_ptr = tmp;
     }
   while (ar_ptr != &main_arena);
 
@@ -4639,9 +4750,11 @@
   m->fsmblks += fastavail;
   if (av == &main_arena)
     {
+      (void) mutex_lock(&mp_.mutex);
       m->hblks = mp_.n_mmaps;
       m->hblkhd = mp_.mmapped_mem;
-      m->usmblks = mp_.max_total_mem;
+      m->usmblks = mp_.max_total_mem;      
+      (void) mutex_unlock(&mp_.mutex);
       m->keepcost = chunksize (av->top);
     }
 }
@@ -4652,6 +4765,7 @@
 {
   struct mallinfo m;
   mstate ar_ptr;
+  mstate tmp;
 
   if (__malloc_initialized < 0)
     ptmalloc_init ();
@@ -4662,9 +4776,10 @@
     {
       (void) mutex_lock (&ar_ptr->mutex);
       int_mallinfo (ar_ptr, &m);
+      tmp = ar_ptr->next;
       (void) mutex_unlock (&ar_ptr->mutex);
 
-      ar_ptr = ar_ptr->next;
+      ar_ptr = tmp;
     }
   while (ar_ptr != &main_arena);
 
@@ -4680,7 +4795,10 @@
 {
   int i;
   mstate ar_ptr;
+  mstate tmp;
+  (void) mutex_lock(&mp_.mutex);
   unsigned int in_use_b = mp_.mmapped_mem, system_b = in_use_b;
+  (void) mutex_unlock(&mp_.mutex);
 #if THREAD_STATS
   long stat_lock_direct = 0, stat_lock_loop = 0, stat_lock_wait = 0;
 #endif
@@ -4711,17 +4829,20 @@
       stat_lock_loop += ar_ptr->stat_lock_loop;
       stat_lock_wait += ar_ptr->stat_lock_wait;
 #endif
+      tmp = ar_ptr->next;
       (void) mutex_unlock (&ar_ptr->mutex);
-      ar_ptr = ar_ptr->next;
+      ar_ptr = tmp;
       if (ar_ptr == &main_arena)
         break;
     }
   fprintf (stderr, "Total (incl. mmap):\n");
   fprintf (stderr, "system bytes     = %10u\n", system_b);
   fprintf (stderr, "in use bytes     = %10u\n", in_use_b);
+  (void) mutex_lock(&mp_.mutex);
   fprintf (stderr, "max mmap regions = %10u\n", (unsigned int) mp_.max_n_mmaps);
   fprintf (stderr, "max mmap bytes   = %10lu\n",
            (unsigned long) mp_.max_mmapped_mem);
+  (void) mutex_unlock(&mp_.mutex);
 #if THREAD_STATS
   fprintf (stderr, "heaps created    = %10d\n", stat_n_heaps);
   fprintf (stderr, "locked directly  = %10ld\n", stat_lock_direct);
@@ -4766,20 +4887,25 @@
       break;
 
     case M_TRIM_THRESHOLD:
+      (void) mutex_lock(&mp_.mutex);
       LIBC_PROBE (memory_mallopt_trim_threshold, 3, value,
                   mp_.trim_threshold, mp_.no_dyn_threshold);
       mp_.trim_threshold = value;
       mp_.no_dyn_threshold = 1;
+      (void) mutex_unlock(&mp_.mutex);
       break;
 
     case M_TOP_PAD:
+      (void) mutex_lock(&mp_.mutex);
       LIBC_PROBE (memory_mallopt_top_pad, 3, value,
                   mp_.top_pad, mp_.no_dyn_threshold);
       mp_.top_pad = value;
       mp_.no_dyn_threshold = 1;
+      (void) mutex_unlock(&mp_.mutex);
       break;
 
     case M_MMAP_THRESHOLD:
+      (void) mutex_lock(&mp_.mutex);
       /* Forbid setting the threshold too high. */
       if ((unsigned long) value > HEAP_MAX_SIZE / 2)
         res = 0;
@@ -4790,13 +4916,16 @@
           mp_.mmap_threshold = value;
           mp_.no_dyn_threshold = 1;
         }
+      (void) mutex_unlock(&mp_.mutex);
       break;
 
     case M_MMAP_MAX:
+      (void) mutex_lock(&mp_.mutex);
       LIBC_PROBE (memory_mallopt_mmap_max, 3, value,
                   mp_.n_mmaps_max, mp_.no_dyn_threshold);
       mp_.n_mmaps_max = value;
       mp_.no_dyn_threshold = 1;
+      (void) mutex_unlock(&mp_.mutex);
       break;
 
     case M_CHECK_ACTION:
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-alias.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-alias.c
--- glibc-2.19/nis/nss_nisplus/nisplus-alias.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-alias.c	2017-03-04 01:35:20.346744068 -0800
@@ -43,7 +43,7 @@
 static enum nss_status
 _nss_create_tablename (int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -62,7 +62,7 @@
 
       atomic_write_barrier ();
 
-      tablename_val = p;
+      atomic_store(tablename_val, p);
     }
 
   return NSS_STATUS_SUCCESS;
@@ -176,7 +176,7 @@
     return NSS_STATUS_UNAVAIL;
 
   next_entry = 0;
-  result = nis_list (tablename_val, FOLLOW_PATH | FOLLOW_LINKS, NULL, NULL);
+  result = nis_list (atomic_load(tablename_val), FOLLOW_PATH | FOLLOW_LINKS, NULL, NULL);
   if (result == NULL)
     {
       status = NSS_STATUS_TRYAGAIN;
@@ -279,7 +279,7 @@
 {
   int parse_res;
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-ethers.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-ethers.c
--- glibc-2.19/nis/nss_nisplus/nisplus-ethers.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-ethers.c	2017-03-04 01:35:20.346744068 -0800
@@ -88,7 +88,7 @@
 static enum nss_status
 _nss_create_tablename (int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -107,7 +107,7 @@
 
       atomic_write_barrier ();
 
-      tablename_val = p;
+      atomic_store(tablename_val, p);
     }
   return NSS_STATUS_SUCCESS;
 }
@@ -157,7 +157,7 @@
 internal_nisplus_getetherent_r (struct etherent *ether, char *buffer,
 				size_t buflen, int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       enum nss_status status = _nss_create_tablename (errnop);
 
@@ -236,7 +236,7 @@
 _nss_nisplus_gethostton_r (const char *name, struct etherent *eth,
 			   char *buffer, size_t buflen, int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       enum nss_status status = _nss_create_tablename (errnop);
 
@@ -294,7 +294,7 @@
 _nss_nisplus_getntohost_r (const struct ether_addr *addr, struct etherent *eth,
 			   char *buffer, size_t buflen, int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-grp.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-grp.c
--- glibc-2.19/nis/nss_nisplus/nisplus-grp.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-grp.c	2017-03-04 01:35:20.347744068 -0800
@@ -50,7 +50,7 @@
 enum nss_status
 _nss_grp_create_tablename (int *errnop)
 {
-  if (grp_tablename_val == NULL)
+  if (atomic_load(grp_tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -106,7 +106,7 @@
 {
   enum nss_status status = NSS_STATUS_SUCCESS;
 
-  if (grp_tablename_val == NULL)
+  if (atomic_load(grp_tablename_val) == NULL)
     status = _nss_grp_create_tablename (errnop);
 
   if (status == NSS_STATUS_SUCCESS)
@@ -288,7 +288,7 @@
 {
   int parse_res;
 
-  if (grp_tablename_val == NULL)
+  if (atomic_load(grp_tablename_val) == NULL)
     {
       enum nss_status status = _nss_grp_create_tablename (errnop);
 
@@ -347,7 +347,7 @@
 _nss_nisplus_getgrgid_r (const gid_t gid, struct group *gr,
 			 char *buffer, size_t buflen, int *errnop)
 {
-  if (grp_tablename_val == NULL)
+  if (atomic_load(grp_tablename_val) == NULL)
     {
       enum nss_status status = _nss_grp_create_tablename (errnop);
 
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-hosts.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-hosts.c
--- glibc-2.19/nis/nss_nisplus/nisplus-hosts.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-hosts.c	2017-03-04 01:35:20.347744068 -0800
@@ -191,7 +191,7 @@
 static enum nss_status
 _nss_create_tablename (int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -210,7 +210,7 @@
 
       atomic_write_barrier ();
 
-      tablename_val = p;
+      atomic_store(tablename_val, p);
     }
 
   return NSS_STATUS_SUCCESS;
@@ -231,7 +231,7 @@
       result = NULL;
     }
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     status = _nss_create_tablename (&err);
 
   __libc_lock_unlock (lock);
@@ -271,7 +271,7 @@
       if (result == NULL)
 	{
 	  saved_res = NULL;
-	  if (tablename_val == NULL)
+	  if (atomic_load(tablename_val) == NULL)
 	    {
 	      enum nss_status status = _nss_create_tablename (errnop);
 
@@ -300,7 +300,7 @@
       else
 	{
 	  saved_res = result;
-	  result = nis_next_entry (tablename_val, &result->cookie);
+	  result = nis_next_entry (atomic_load(tablename_val), &result->cookie);
 	  if (result == NULL)
 	    {
 	      *errnop = errno;
@@ -383,7 +383,7 @@
 			   char *buffer, size_t buflen, int *errnop,
 			   int *herrnop, int flags)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       enum nss_status status = get_tablename (herrnop);
       if (status != NSS_STATUS_SUCCESS)
@@ -518,7 +518,7 @@
 			      struct hostent *host, char *buffer,
 			      size_t buflen, int *errnop, int *herrnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       enum nss_status status = get_tablename (herrnop);
       if (status != NSS_STATUS_SUCCESS)
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-network.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-network.c
--- glibc-2.19/nis/nss_nisplus/nisplus-network.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-network.c	2017-03-04 01:35:20.347744068 -0800
@@ -142,7 +142,7 @@
 static enum nss_status
 _nss_create_tablename (int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -161,7 +161,7 @@
 
       atomic_write_barrier ();
 
-      tablename_val = p;
+      atomic_store(tablename_val, p);
     }
 
   return NSS_STATUS_SUCCESS;
@@ -180,7 +180,7 @@
       result = NULL;
     }
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       int err;
       status = _nss_create_tablename (&err);
@@ -222,7 +222,7 @@
 	{
 	  saved_res = NULL;
 
-	  if (tablename_val == NULL)
+	  if (atomic_load(tablename_val) == NULL)
 	    {
 	      enum nss_status status = _nss_create_tablename (errnop);
 
@@ -254,7 +254,7 @@
       else
 	{
 	  saved_res = result;
-	  result = nis_next_entry (tablename_val, &result->cookie);
+	  result = nis_next_entry (atomic_load(tablename_val), &result->cookie);
 	  if (result == NULL)
 	    {
 	      *errnop = errno;
@@ -311,7 +311,7 @@
 {
   int parse_res, retval;
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
@@ -414,7 +414,7 @@
 			     struct netent *network, char *buffer,
 			     size_t buflen, int *errnop, int *herrnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-proto.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-proto.c
--- glibc-2.19/nis/nss_nisplus/nisplus-proto.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-proto.c	2017-03-04 01:35:20.347744068 -0800
@@ -137,7 +137,7 @@
 static enum nss_status
 _nss_create_tablename (int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -156,7 +156,7 @@
 
       atomic_write_barrier ();
 
-      tablename_val = p;
+      atomic_store(tablename_val, p);
     }
 
   return NSS_STATUS_SUCCESS;
@@ -175,7 +175,7 @@
       result = NULL;
     }
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       int err;
       status = _nss_create_tablename (&err);
@@ -216,7 +216,7 @@
       if (result == NULL)
 	{
 	  saved_res = NULL;
-	  if (tablename_val == NULL)
+	  if (atomic_load(tablename_val) == NULL)
 	    {
 	      enum nss_status status = _nss_create_tablename (errnop);
 
@@ -236,7 +236,7 @@
       else
 	{
 	  saved_res = result;
-	  result = nis_next_entry (tablename_val, &result->cookie);
+	  result = nis_next_entry (atomic_load(tablename_val), &result->cookie);
 	  if (result == NULL)
 	    {
 	      *errnop = errno;
@@ -290,7 +290,7 @@
 {
   int parse_res;
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
@@ -383,7 +383,7 @@
 _nss_nisplus_getprotobynumber_r (const int number, struct protoent *proto,
 				 char *buffer, size_t buflen, int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-pwd.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-pwd.c
--- glibc-2.19/nis/nss_nisplus/nisplus-pwd.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-pwd.c	2017-03-04 01:35:20.347744068 -0800
@@ -49,7 +49,7 @@
 enum nss_status
 _nss_pwd_create_tablename (int *errnop)
 {
-  if (pwd_tablename_val == NULL)
+  if (atomic_load(pwd_tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -105,7 +105,7 @@
 {
   enum nss_status status = NSS_STATUS_SUCCESS;
 
-  if (pwd_tablename_val == NULL)
+  if (atomic_load(pwd_tablename_val) == NULL)
     status = _nss_pwd_create_tablename (errnop);
 
   if (status == NSS_STATUS_SUCCESS)
@@ -289,7 +289,7 @@
 {
   int parse_res;
 
-  if (pwd_tablename_val == NULL)
+  if (atomic_load(pwd_tablename_val) == NULL)
     {
       enum nss_status status = _nss_pwd_create_tablename (errnop);
 
@@ -352,7 +352,7 @@
 _nss_nisplus_getpwuid_r (const uid_t uid, struct passwd *pw,
 			 char *buffer, size_t buflen, int *errnop)
 {
-  if (pwd_tablename_val == NULL)
+  if (atomic_load(pwd_tablename_val) == NULL)
     {
       enum nss_status status = _nss_pwd_create_tablename (errnop);
 
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-rpc.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-rpc.c
--- glibc-2.19/nis/nss_nisplus/nisplus-rpc.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-rpc.c	2017-03-04 01:35:20.348744068 -0800
@@ -138,7 +138,7 @@
 static enum nss_status
 _nss_create_tablename (int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -157,7 +157,7 @@
 
       atomic_write_barrier ();
 
-      tablename_val = p;
+      atomic_store(tablename_val, p);
     }
 
   return NSS_STATUS_SUCCESS;
@@ -177,7 +177,7 @@
       result = NULL;
     }
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       int err;
       status = _nss_create_tablename (&err);
@@ -218,7 +218,7 @@
       if (result == NULL)
 	{
 	  saved_res = NULL;
-          if (tablename_val == NULL)
+          if (atomic_load(tablename_val) == NULL)
 	    {
 	      enum nss_status status =  _nss_create_tablename (errnop);
 
@@ -238,7 +238,7 @@
       else
 	{
 	  saved_res = result;
-	  result = nis_next_entry (tablename_val, &result->cookie);
+	  result = nis_next_entry (atomic_load(tablename_val), &result->cookie);
 	  if (result == NULL)
 	    {
 	      *errnop = errno;
@@ -292,7 +292,7 @@
 {
   int parse_res;
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
@@ -385,7 +385,7 @@
 _nss_nisplus_getrpcbynumber_r (const int number, struct rpcent *rpc,
 			       char *buffer, size_t buflen, int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
diff -N -r --unified glibc-2.19/nis/nss_nisplus/nisplus-service.c glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-service.c
--- glibc-2.19/nis/nss_nisplus/nisplus-service.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nis/nss_nisplus/nisplus-service.c	2017-03-04 01:35:20.348744068 -0800
@@ -145,7 +145,7 @@
 static enum nss_status
 _nss_create_tablename (int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       const char *local_dir = nis_local_directory ();
       size_t local_dir_len = strlen (local_dir);
@@ -164,7 +164,7 @@
 
       atomic_write_barrier ();
 
-      tablename_val = p;
+      atomic_store(tablename_val, p);
     }
 
   return NSS_STATUS_SUCCESS;
@@ -185,7 +185,7 @@
       result = NULL;
     }
 
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     status = _nss_create_tablename (&err);
 
   __libc_lock_unlock (lock);
@@ -223,7 +223,7 @@
       if (result == NULL)
 	{
 	  saved_res = NULL;
-          if (tablename_val == NULL)
+          if (atomic_load(tablename_val) == NULL)
 	    {
 	      enum nss_status status = _nss_create_tablename (errnop);
 
@@ -243,7 +243,7 @@
       else
 	{
 	  saved_res = result;
-	  result = nis_next_entry (tablename_val, &result->cookie);
+	  result = nis_next_entry (atomic_load(tablename_val), &result->cookie);
 	  if (result == NULL)
 	    {
 	      *errnop = errno;
@@ -294,7 +294,7 @@
 			      struct servent *serv,
 			      char *buffer, size_t buflen, int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
@@ -396,7 +396,7 @@
 			      struct servent *serv,
 			      char *buffer, size_t buflen, int *errnop)
 {
-  if (tablename_val == NULL)
+  if (atomic_load(tablename_val) == NULL)
     {
       __libc_lock_lock (lock);
 
diff -N -r --unified glibc-2.19/nptl/allocatestack.c glibc-2.19-totalpartial/nptl/allocatestack.c
--- glibc-2.19/nptl/allocatestack.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/allocatestack.c	2017-03-04 01:35:20.348744068 -0800
@@ -130,13 +130,13 @@
 
 
 /* Check whether the stack is still used or not.  */
-#define FREE_P(descr) ((descr)->tid <= 0)
+#define FREE_P(descr) (atomic_load((descr)->tid) <= 0)
 
 
 static void
 stack_list_del (list_t *elem)
 {
-  in_flight_stack = (uintptr_t) elem;
+  atomic_store(in_flight_stack, (uintptr_t) elem);
 
   atomic_write_barrier ();
 
@@ -144,14 +144,14 @@
 
   atomic_write_barrier ();
 
-  in_flight_stack = 0;
+  atomic_store(in_flight_stack, 0);
 }
 
 
 static void
 stack_list_add (list_t *elem, list_t *list)
 {
-  in_flight_stack = (uintptr_t) elem | 1;
+  atomic_store(in_flight_stack, (uintptr_t) elem | 1);
 
   atomic_write_barrier ();
 
@@ -159,7 +159,7 @@
 
   atomic_write_barrier ();
 
-  in_flight_stack = 0;
+  atomic_store(in_flight_stack, 0);
 }
 
 
@@ -215,7 +215,7 @@
     }
 
   /* Don't allow setxid until cloned.  */
-  result->setxid_futex = -1;
+  atomic_store(result->setxid_futex, -1);
 
   /* Dequeue the entry.  */
   stack_list_del (&result->list);
@@ -234,7 +234,7 @@
   *memp = result->stackblock;
 
   /* Cancellation handling is back to the default.  */
-  result->cancelhandling = 0;
+  atomic_store(result->cancelhandling, 0);
   result->cleanup = NULL;
 
   /* No pending event.  */
@@ -437,7 +437,7 @@
       pd->pid = THREAD_GETMEM (THREAD_SELF, pid);
 
       /* Don't allow setxid until cloned.  */
-      pd->setxid_futex = -1;
+      atomic_store(pd->setxid_futex, -1);
 
       /* Allocate the DTV for this thread.  */
       if (_dl_allocate_tls (TLS_TPADJ (pd)) == NULL)
@@ -571,7 +571,7 @@
 #endif
 
 	  /* Don't allow setxid until cloned.  */
-	  pd->setxid_futex = -1;
+	  atomic_store(pd->setxid_futex, -1);
 
 	  /* The process ID is also the same as that of the caller.  */
 	  pd->pid = THREAD_GETMEM (THREAD_SELF, pid);
@@ -823,10 +823,10 @@
      we have to be aware that we might have interrupted a list
      operation.  */
 
-  if (in_flight_stack != 0)
+  if (atomic_load(in_flight_stack) != 0)
     {
-      bool add_p = in_flight_stack & 1;
-      list_t *elem = (list_t *) (in_flight_stack & ~(uintptr_t) 1);
+      bool add_p = atomic_load(in_flight_stack) & 1;
+      list_t *elem = (list_t *) (atomic_load(in_flight_stack) & ~(uintptr_t) 1);
 
       if (add_p)
 	{
@@ -834,13 +834,13 @@
 	     case we only need to check the beginning of these lists.  */
 	  int check_list (list_t *l)
 	  {
-	    if (l->next->prev != l)
+	    if (atomic_load(l->next->prev) != l)
 	      {
-		assert (l->next->prev == elem);
+		assert (atomic_load(l->next->prev) == elem);
 
-		elem->next = l->next;
-		elem->prev = l;
-		l->next = elem;
+		atomic_store(elem->next, l->next);
+		atomic_store(elem->prev, l);
+		atomic_store(l->next, elem);
 
 		return 1;
 	      }
@@ -854,8 +854,8 @@
       else
 	{
 	  /* We can simply always replay the delete operation.  */
-	  elem->next->prev = elem->prev;
-	  elem->prev->next = elem->next;
+	  atomic_store(elem->next->prev, elem->prev);
+	  atomic_store(elem->prev->next, elem->next);
 	}
     }
 
@@ -867,7 +867,7 @@
       if (curp != self)
 	{
 	  /* This marks the stack as free.  */
-	  curp->tid = 0;
+	  atomic_store(curp->tid, 0);
 
 	  /* The PID field must be initialized for the new process.  */
 	  curp->pid = self->pid;
@@ -924,7 +924,7 @@
   /* There is one thread running.  */
   __nptl_nthreads = 1;
 
-  in_flight_stack = 0;
+  atomic_store(in_flight_stack, 0);
 
   /* Initialize locks.  */
   stack_cache_lock = LLL_LOCK_INITIALIZER;
@@ -951,7 +951,7 @@
 
       curp = list_entry (runp, struct pthread, list);
 
-      if (curp->tid == tid)
+      if (atomic_load(curp->tid) == tid)
 	{
 	  result = curp;
 	  goto out;
@@ -965,7 +965,7 @@
 
       curp = list_entry (runp, struct pthread, list);
 
-      if (curp->tid == tid)
+      if (atomic_load(curp->tid) == tid)
 	{
 	  result = curp;
 	  goto out;
@@ -987,18 +987,18 @@
   int ch;
 
   /* Wait until this thread is cloned.  */
-  if (t->setxid_futex == -1
+  if (atomic_load(t->setxid_futex) == -1
       && ! atomic_compare_and_exchange_bool_acq (&t->setxid_futex, -2, -1))
     do
       lll_futex_wait (&t->setxid_futex, -2, LLL_PRIVATE);
-    while (t->setxid_futex == -2);
+    while (atomic_load(t->setxid_futex) == -2);
 
   /* Don't let the thread exit before the setxid handler runs.  */
-  t->setxid_futex = 0;
+  atomic_store(t->setxid_futex, 0);
 
   do
     {
-      ch = t->cancelhandling;
+      ch = atomic_load(t->cancelhandling);
 
       /* If the thread is exiting right now, ignore it.  */
       if ((ch & EXITING_BITMASK) != 0)
@@ -1007,7 +1007,7 @@
 	     progress.  */
 	  if ((ch & SETXID_BITMASK) == 0)
 	    {
-	      t->setxid_futex = 1;
+	      atomic_store(t->setxid_futex, 1);
 	      lll_futex_wake (&t->setxid_futex, 1, LLL_PRIVATE);
 	    }
 	  return;
@@ -1026,7 +1026,7 @@
 
   do
     {
-      ch = t->cancelhandling;
+      ch = atomic_load(t->cancelhandling);
       if ((ch & SETXID_BITMASK) == 0)
 	return;
     }
@@ -1034,7 +1034,7 @@
 					       ch & ~SETXID_BITMASK, ch));
 
   /* Release the futex just in case.  */
-  t->setxid_futex = 1;
+  atomic_store(t->setxid_futex, 1);
   lll_futex_wake (&t->setxid_futex, 1, LLL_PRIVATE);
 }
 
@@ -1043,13 +1043,13 @@
 internal_function
 setxid_signal_thread (struct xid_command *cmdp, struct pthread *t)
 {
-  if ((t->cancelhandling & SETXID_BITMASK) == 0)
+  if ((atomic_load(t->cancelhandling) & SETXID_BITMASK) == 0)
     return 0;
 
   int val;
   INTERNAL_SYSCALL_DECL (err);
   val = INTERNAL_SYSCALL (tgkill, err, 3, THREAD_GETMEM (THREAD_SELF, pid),
-			  t->tid, SIGSETXID);
+			  atomic_load(t->tid), SIGSETXID);
 
   /* If this failed, it must have had not started yet or else exited.  */
   if (!INTERNAL_SYSCALL_ERROR_P (val, err))
diff -N -r --unified glibc-2.19/nptl/descr.h glibc-2.19-totalpartial/nptl/descr.h
--- glibc-2.19/nptl/descr.h	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/descr.h	2017-03-04 01:35:20.348744068 -0800
@@ -342,7 +342,7 @@
      in normal operation.  */
   struct pthread *joinid;
   /* Check whether a thread is detached.  */
-#define IS_DETACHED(pd) ((pd)->joinid == (pd))
+#define IS_DETACHED(pd) (atomic_load((pd)->joinid) == (pd))
 
   /* The result of the thread function.  */
   void *result;
diff -N -r --unified glibc-2.19/nptl/nptl-init.c glibc-2.19-totalpartial/nptl/nptl-init.c
--- glibc-2.19/nptl/nptl-init.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/nptl-init.c	2017-03-04 01:35:20.348744068 -0800
@@ -41,14 +41,14 @@
 size_t __static_tls_size;
 size_t __static_tls_align_m1;
 
-#ifndef __ASSUME_SET_ROBUST_LIST
-/* Negative if we do not have the system call and we can use it.  */
+//#ifndef __ASSUME_SET_ROBUST_LIST
+///* Negative if we do not have the system call and we can use it.  */
 int __set_robust_list_avail;
-# define set_robust_list_not_avail() \
+# define set_robust_list_not_avail()		\
   __set_robust_list_avail = -1
-#else
-# define set_robust_list_not_avail() do { } while (0)
-#endif
+//#else
+//# define set_robust_list_not_avail() do { } while (0)
+//#endif
 
 #ifndef __ASSUME_FUTEX_CLOCK_REALTIME
 /* Nonzero if we do not have FUTEX_CLOCK_REALTIME.  */
@@ -260,7 +260,7 @@
   while (flags != newval);
 
   /* And release the futex.  */
-  self->setxid_futex = 1;
+  atomic_store(self->setxid_futex, 1);
   lll_futex_wake (&self->setxid_futex, 1, LLL_PRIVATE);
 
   if (atomic_decrement_val (&__xidcmd->cntr) == 0)
diff -N -r --unified glibc-2.19/nptl/pthread_barrier_wait.c glibc-2.19-totalpartial/nptl/pthread_barrier_wait.c
--- glibc-2.19/nptl/pthread_barrier_wait.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_barrier_wait.c	2017-03-04 01:35:20.349744068 -0800
@@ -41,7 +41,10 @@
     {
       /* Yes. Increment the event counter to avoid invalid wake-ups and
 	 tell the current waiters that it is their turn.  */
-      ++ibarrier->curr_event;
+
+      // MVEE patch: with partial lock ordering, the original (non-atomic) 
+      // increment raced with the futex_wait loop below.
+      atomic_increment(&ibarrier->curr_event);
 
       /* Wake up everybody.  */
       lll_futex_wake (&ibarrier->curr_event, INT_MAX,
@@ -54,7 +57,9 @@
     {
       /* The number of the event we are waiting for.  The barrier's event
 	 number must be bumped before we continue.  */
-      unsigned int event = ibarrier->curr_event;
+
+      // MVEE patch: racy with partial lock ordering
+      unsigned int event = atomic_load(ibarrier->curr_event);
 
       /* Before suspending, make the barrier available to others.  */
       lll_unlock (ibarrier->lock, ibarrier->private ^ FUTEX_PRIVATE_FLAG);
@@ -63,11 +68,11 @@
       do
 	lll_futex_wait (&ibarrier->curr_event, event,
 			ibarrier->private ^ FUTEX_PRIVATE_FLAG);
-      while (event == ibarrier->curr_event);
+      while (event == atomic_load(ibarrier->curr_event));
     }
 
   /* Make sure the init_count is stored locally or in a register.  */
-  unsigned int init_count = ibarrier->init_count;
+  unsigned int init_count = atomic_load(ibarrier->init_count);
 
   /* If this was the last woken thread, unlock.  */
   if (atomic_increment_val (&ibarrier->left) == init_count)
diff -N -r --unified glibc-2.19/nptl/pthread_cancel.c glibc-2.19-totalpartial/nptl/pthread_cancel.c
--- glibc-2.19/nptl/pthread_cancel.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_cancel.c	2017-03-04 01:35:20.349744068 -0800
@@ -44,7 +44,7 @@
   do
     {
     again:
-      oldval = pd->cancelhandling;
+      oldval = atomic_load(pd->cancelhandling);
       newval = oldval | CANCELING_BITMASK | CANCELED_BITMASK;
 
       /* Avoid doing unnecessary work.  The atomic operation can
@@ -76,7 +76,7 @@
 	     is not guaranteed to be async-safe.  */
 	  int val;
 	  val = INTERNAL_SYSCALL (tgkill, err, 3,
-				  THREAD_GETMEM (THREAD_SELF, pid), pd->tid,
+				  THREAD_GETMEM (THREAD_SELF, pid), atomic_load(pd->tid),
 				  SIGCANCEL);
 
 	  if (INTERNAL_SYSCALL_ERROR_P (val, err))
diff -N -r --unified glibc-2.19/nptl/pthread_cond_signal.c glibc-2.19-totalpartial/nptl/pthread_cond_signal.c
--- glibc-2.19/nptl/pthread_cond_signal.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_cond_signal.c	2017-03-04 01:35:20.349744068 -0800
@@ -47,6 +47,7 @@
       ++cond->__data.__wakeup_seq;
       ++cond->__data.__futex;
 
+#if 0
 #if (defined lll_futex_cmp_requeue_pi \
      && defined __ASSUME_REQUEUE_PI)
       pthread_mutex_t *mut = cond->__data.__mutex;
@@ -69,6 +70,7 @@
 						       &cond->__data.__lock,
 						       pshared), 0))
 	  return 0;
+#endif
 
       /* Fallback if neither of them work.  */
       lll_futex_wake (&cond->__data.__futex, 1, pshared);
diff -N -r --unified glibc-2.19/nptl/pthread_create.c glibc-2.19-totalpartial/nptl/pthread_create.c
--- glibc-2.19/nptl/pthread_create.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_create.c	2017-03-04 01:35:20.349744068 -0800
@@ -265,7 +265,7 @@
   /* If the parent was running cancellation handlers while creating
      the thread the new thread inherited the signal mask.  Reset the
      cancellation signal mask.  */
-  if (__builtin_expect (pd->parent_cancelhandling & CANCELING_BITMASK, 0))
+  if (__builtin_expect (atomic_load(pd->parent_cancelhandling) & CANCELING_BITMASK, 0))
     {
       INTERNAL_SYSCALL_DECL (err);
       sigset_t mask;
@@ -349,7 +349,7 @@
 	      pd->eventbuf.eventdata = pd;
 
 	      do
-		pd->nextevent = __nptl_last_event;
+		pd->nextevent = atomic_load(__nptl_last_event);
 	      while (atomic_compare_and_exchange_bool_acq (&__nptl_last_event,
 							   pd, pd->nextevent));
 	    }
@@ -412,16 +412,16 @@
   if (IS_DETACHED (pd))
     /* Free the TCB.  */
     __free_tcb (pd);
-  else if (__builtin_expect (pd->cancelhandling & SETXID_BITMASK, 0))
+  else if (__builtin_expect (atomic_load(pd->cancelhandling) & SETXID_BITMASK, 0))
     {
       /* Some other thread might call any of the setXid functions and expect
 	 us to reply.  In this case wait until we did that.  */
       do
 	lll_futex_wait (&pd->setxid_futex, 0, LLL_PRIVATE);
-      while (pd->cancelhandling & SETXID_BITMASK);
+      while (atomic_load(pd->cancelhandling) & SETXID_BITMASK);
 
       /* Reset the value so that the stack can be reused.  */
-      pd->setxid_futex = 0;
+      atomic_store(pd->setxid_futex, 0);
     }
 
   /* We cannot call '_exit' here.  '_exit' will terminate the process.
diff -N -r --unified glibc-2.19/nptl/pthread_detach.c glibc-2.19-totalpartial/nptl/pthread_detach.c
--- glibc-2.19/nptl/pthread_detach.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_detach.c	2017-03-04 01:35:20.349744068 -0800
@@ -47,7 +47,7 @@
   else
     /* Check whether the thread terminated meanwhile.  In this case we
        will just free the TCB.  */
-    if ((pd->cancelhandling & EXITING_BITMASK) != 0)
+    if ((atomic_load(pd->cancelhandling) & EXITING_BITMASK) != 0)
       /* Note that the code in __free_tcb makes sure each thread
 	 control block is freed only once.  */
       __free_tcb (pd);
diff -N -r --unified glibc-2.19/nptl/pthread_getattr_np.c glibc-2.19-totalpartial/nptl/pthread_getattr_np.c
--- glibc-2.19/nptl/pthread_getattr_np.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_getattr_np.c	2017-03-04 01:35:20.349744068 -0800
@@ -66,7 +66,7 @@
     {
       /* No stack information available.  This must be for the initial
 	 thread.  Get the info in some magical way.  */
-      assert (abs (thread->pid) == thread->tid);
+      assert (abs (thread->pid) == atomic_load(thread->tid));
 
       /* Stack size limit.  */
       struct rlimit rl;
diff -N -r --unified glibc-2.19/nptl/pthread_getcpuclockid.c glibc-2.19-totalpartial/nptl/pthread_getcpuclockid.c
--- glibc-2.19/nptl/pthread_getcpuclockid.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_getcpuclockid.c	2017-03-04 01:35:20.349744068 -0800
@@ -42,11 +42,11 @@
 
      If some day more clock IDs are needed the ID part can be
      enlarged.  The IDs are entirely internal.  */
-  if (pd->tid >= 1 << (8 * sizeof (*clockid) - CLOCK_IDFIELD_SIZE))
+  if (atomic_load(pd->tid) >= 1 << (8 * sizeof (*clockid) - CLOCK_IDFIELD_SIZE))
     return ERANGE;
 
   /* Store the number.  */
-  *clockid = CLOCK_THREAD_CPUTIME_ID | (pd->tid << CLOCK_IDFIELD_SIZE);
+  *clockid = CLOCK_THREAD_CPUTIME_ID | (atomic_load(pd->tid) << CLOCK_IDFIELD_SIZE);
 
   return 0;
 #else
diff -N -r --unified glibc-2.19/nptl/pthread_getschedparam.c glibc-2.19-totalpartial/nptl/pthread_getschedparam.c
--- glibc-2.19/nptl/pthread_getschedparam.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_getschedparam.c	2017-03-04 01:35:20.349744068 -0800
@@ -46,7 +46,7 @@
      not yet been retrieved do it now.  */
   if ((pd->flags & ATTR_FLAG_SCHED_SET) == 0)
     {
-      if (__sched_getparam (pd->tid, &pd->schedparam) != 0)
+      if (__sched_getparam (atomic_load(pd->tid), &pd->schedparam) != 0)
 	result = 1;
       else
 	pd->flags |= ATTR_FLAG_SCHED_SET;
@@ -54,7 +54,7 @@
 
   if ((pd->flags & ATTR_FLAG_POLICY_SET) == 0)
     {
-      pd->schedpolicy = __sched_getscheduler (pd->tid);
+      pd->schedpolicy = __sched_getscheduler (atomic_load(pd->tid));
       if (pd->schedpolicy == -1)
 	result = 1;
       else
diff -N -r --unified glibc-2.19/nptl/pthread_join.c glibc-2.19-totalpartial/nptl/pthread_join.c
--- glibc-2.19/nptl/pthread_join.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_join.c	2017-03-04 01:35:20.350744068 -0800
@@ -67,11 +67,11 @@
   int oldtype = CANCEL_ASYNC ();
 
   if ((pd == self
-       || (self->joinid == pd
-	   && (pd->cancelhandling
+       || (atomic_load(self->joinid) == pd
+	   && (atomic_load(pd->cancelhandling)
 	       & (CANCELING_BITMASK | CANCELED_BITMASK | EXITING_BITMASK
 		  | TERMINATED_BITMASK)) == 0))
-      && !CANCEL_ENABLED_AND_CANCELED (self->cancelhandling))
+      && !CANCEL_ENABLED_AND_CANCELED (atomic_load(self->cancelhandling)))
     /* This is a deadlock situation.  The threads are waiting for each
        other to finish.  Note that this is a "may" error.  To be 100%
        sure we catch this error we would have to lock the data
@@ -102,7 +102,7 @@
   if (__builtin_expect (result == 0, 1))
     {
       /* We mark the thread as terminated and as joined.  */
-      pd->tid = -1;
+      atomic_store(pd->tid, -1);
 
       /* Store the return value if the caller is interested.  */
       if (thread_return != NULL)
diff -N -r --unified glibc-2.19/nptl/pthread_key_create.c glibc-2.19-totalpartial/nptl/pthread_key_create.c
--- glibc-2.19/nptl/pthread_key_create.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_key_create.c	2017-03-04 01:35:20.350744068 -0800
@@ -29,7 +29,7 @@
   /* Find a slot in __pthread_kyes which is unused.  */
   for (size_t cnt = 0; cnt < PTHREAD_KEYS_MAX; ++cnt)
     {
-      uintptr_t seq = __pthread_keys[cnt].seq;
+      uintptr_t seq = atomic_load(__pthread_keys[cnt].seq);
 
       if (KEY_UNUSED (seq) && KEY_USABLE (seq)
 	  /* We found an unused slot.  Try to allocate it.  */
diff -N -r --unified glibc-2.19/nptl/pthread_key_delete.c glibc-2.19-totalpartial/nptl/pthread_key_delete.c
--- glibc-2.19/nptl/pthread_key_delete.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_key_delete.c	2017-03-04 01:35:20.350744068 -0800
@@ -29,7 +29,7 @@
 
   if (__builtin_expect (key < PTHREAD_KEYS_MAX, 1))
     {
-      unsigned int seq = __pthread_keys[key].seq;
+      unsigned int seq = atomic_load(__pthread_keys[key].seq);
 
       if (__builtin_expect (! KEY_UNUSED (seq), 1)
 	  && ! atomic_compare_and_exchange_bool_acq (&__pthread_keys[key].seq,
diff -N -r --unified glibc-2.19/nptl/pthread_mutex_lock.c glibc-2.19-totalpartial/nptl/pthread_mutex_lock.c
--- glibc-2.19/nptl/pthread_mutex_lock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_mutex_lock.c	2017-03-14 14:32:31.738962191 -0700
@@ -126,7 +126,7 @@
 	{
 	  int cnt = 0;
 	  int max_cnt = MIN (MAX_ADAPTIVE_COUNT,
-			     mutex->__data.__spins * 2 + 10);
+						 atomic_load(mutex->__data.__spins) * 2 + 10);
 	  do
 	    {
 	      if (cnt++ >= max_cnt)
@@ -141,7 +141,7 @@
 	    }
 	  while (LLL_MUTEX_TRYLOCK (mutex) != 0);
 
-	  mutex->__data.__spins += (cnt - mutex->__data.__spins) / 8;
+	  atomic_add(&mutex->__data.__spins, (cnt - mutex->__data.__spins) / 8);
 	}
       assert (mutex->__data.__owner == 0);
     }
@@ -183,7 +183,7 @@
       THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
 		     &mutex->__data.__list.__next);
 
-      oldval = mutex->__data.__lock;
+      oldval = atomic_load(mutex->__data.__lock);
       do
 	{
 	again:
@@ -293,7 +293,7 @@
 			 (void *) (((uintptr_t) &mutex->__data.__list.__next)
 				   | 1));
 
-	oldval = mutex->__data.__lock;
+	oldval = atomic_load(mutex->__data.__lock);
 
 	/* Check whether we already hold the mutex.  */
 	if (__builtin_expect ((oldval & FUTEX_TID_MASK) == id, 0))
@@ -354,7 +354,7 @@
 		  pause_not_cancel ();
 	      }
 
-	    oldval = mutex->__data.__lock;
+	    oldval = atomic_load(mutex->__data.__lock);
 
 	    assert (robust || (oldval & FUTEX_OWNER_DIED) == 0);
 	  }
@@ -416,7 +416,7 @@
       {
 	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
 
-	oldval = mutex->__data.__lock;
+	oldval = atomic_load(mutex->__data.__lock);
 
 	/* Check whether we already hold the mutex.  */
 	if (mutex->__data.__owner == id)
diff -N -r --unified glibc-2.19/nptl/pthread_mutex_setprioceiling.c glibc-2.19-totalpartial/nptl/pthread_mutex_setprioceiling.c
--- glibc-2.19/nptl/pthread_mutex_setprioceiling.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_mutex_setprioceiling.c	2017-03-04 01:35:20.350744068 -0800
@@ -33,7 +33,7 @@
   if ((mutex->__data.__kind & PTHREAD_MUTEX_PRIO_PROTECT_NP) == 0)
     return EINVAL;
 
-  if (__sched_fifo_min_prio == -1)
+  if (atomic_load(__sched_fifo_min_prio) == -1)
     __init_sched_fifo_prio ();
 
   if (__builtin_expect (prioceiling < __sched_fifo_min_prio, 0)
@@ -56,7 +56,7 @@
 	locked = true;
     }
 
-  int oldval = mutex->__data.__lock;
+  int oldval = atomic_load(mutex->__data.__lock);
   if (! locked)
     do
       {
@@ -106,9 +106,9 @@
 
   int newlock = 0;
   if (locked)
-    newlock = (mutex->__data.__lock & ~PTHREAD_MUTEX_PRIO_CEILING_MASK);
-  mutex->__data.__lock = newlock
-			 | (prioceiling << PTHREAD_MUTEX_PRIO_CEILING_SHIFT);
+    newlock = (atomic_load(mutex->__data.__lock) & ~PTHREAD_MUTEX_PRIO_CEILING_MASK);
+  atomic_store(mutex->__data.__lock, newlock
+	       | (prioceiling << PTHREAD_MUTEX_PRIO_CEILING_SHIFT));
   atomic_full_barrier ();
 
   lll_futex_wake (&mutex->__data.__lock, INT_MAX,
diff -N -r --unified glibc-2.19/nptl/pthread_mutex_timedlock.c glibc-2.19-totalpartial/nptl/pthread_mutex_timedlock.c
--- glibc-2.19/nptl/pthread_mutex_timedlock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_mutex_timedlock.c	2017-03-14 14:32:31.344962164 -0700
@@ -101,7 +101,7 @@
     elision: __attribute__((unused))
       /* Don't record ownership */
       return lll_timedlock_elision (mutex->__data.__lock,
-				    mutex->__data.__spins,
+									atomic_load(mutex->__data.__spins),
 				    abstime,
 				    PTHREAD_MUTEX_PSHARED (mutex));
 
@@ -114,7 +114,7 @@
 	{
 	  int cnt = 0;
 	  int max_cnt = MIN (MAX_ADAPTIVE_COUNT,
-			     mutex->__data.__spins * 2 + 10);
+						 atomic_load(mutex->__data.__spins) * 2 + 10);
 	  do
 	    {
 	      if (cnt++ >= max_cnt)
@@ -130,7 +130,7 @@
 	    }
 	  while (lll_trylock (mutex->__data.__lock) != 0);
 
-	  mutex->__data.__spins += (cnt - mutex->__data.__spins) / 8;
+	  atomic_add(&mutex->__data.__spins, (cnt - mutex->__data.__spins) / 8);
 	}
       break;
 
@@ -141,7 +141,7 @@
       THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
 		     &mutex->__data.__list.__next);
 
-      oldval = mutex->__data.__lock;
+      oldval = atomic_load(mutex->__data.__lock);
       do
 	{
 	again:
@@ -247,7 +247,7 @@
 			 (void *) (((uintptr_t) &mutex->__data.__list.__next)
 				   | 1));
 
-	oldval = mutex->__data.__lock;
+	oldval = atomic_load(mutex->__data.__lock);
 
 	/* Check whether we already hold the mutex.  */
 	if (__builtin_expect ((oldval & FUTEX_TID_MASK) == id, 0))
@@ -332,7 +332,7 @@
 		return INTERNAL_SYSCALL_ERRNO (e, __err);
 	      }
 
-	    oldval = mutex->__data.__lock;
+	    oldval = atomic_load(mutex->__data.__lock);
 
 	    assert (robust || (oldval & FUTEX_OWNER_DIED) == 0);
 	  }
@@ -389,7 +389,7 @@
       {
 	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
 
-	oldval = mutex->__data.__lock;
+	oldval = atomic_load(mutex->__data.__lock);
 
 	/* Check whether we already hold the mutex.  */
 	if (mutex->__data.__owner == id)
diff -N -r --unified glibc-2.19/nptl/pthread_mutex_trylock.c glibc-2.19-totalpartial/nptl/pthread_mutex_trylock.c
--- glibc-2.19/nptl/pthread_mutex_trylock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_mutex_trylock.c	2017-03-04 01:35:20.350744068 -0800
@@ -98,7 +98,7 @@
       THREAD_SETMEM (THREAD_SELF, robust_head.list_op_pending,
 		     &mutex->__data.__list.__next);
 
-      oldval = mutex->__data.__lock;
+      oldval = atomic_load(mutex->__data.__lock);
       do
 	{
 	again:
@@ -208,7 +208,7 @@
 			 (void *) (((uintptr_t) &mutex->__data.__list.__next)
 				   | 1));
 
-	oldval = mutex->__data.__lock;
+	oldval = atomic_load(mutex->__data.__lock);
 
 	/* Check whether we already hold the mutex.  */
 	if (__builtin_expect ((oldval & FUTEX_TID_MASK) == id, 0))
@@ -267,7 +267,7 @@
 		return EBUSY;
 	      }
 
-	    oldval = mutex->__data.__lock;
+	    oldval = atomic_load(mutex->__data.__lock);
 	  }
 
 	if (__builtin_expect (oldval & FUTEX_OWNER_DIED, 0))
@@ -326,7 +326,7 @@
       {
 	int kind = mutex->__data.__kind & PTHREAD_MUTEX_KIND_MASK_NP;
 
-	oldval = mutex->__data.__lock;
+	oldval = atomic_load(mutex->__data.__lock);
 
 	/* Check whether we already hold the mutex.  */
 	if (mutex->__data.__owner == id)
diff -N -r --unified glibc-2.19/nptl/pthread_mutex_unlock.c glibc-2.19-totalpartial/nptl/pthread_mutex_unlock.c
--- glibc-2.19/nptl/pthread_mutex_unlock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_mutex_unlock.c	2017-03-04 01:35:20.351744068 -0800
@@ -229,7 +229,7 @@
 	--mutex->__data.__nusers;
 
       /* Unlock.  */
-      if ((mutex->__data.__lock & FUTEX_WAITERS) != 0
+      if ((atomic_load(mutex->__data.__lock) & FUTEX_WAITERS) != 0
 	  || atomic_compare_and_exchange_bool_rel (&mutex->__data.__lock, 0,
 						   THREAD_GETMEM (THREAD_SELF,
 								  tid)))
@@ -277,7 +277,7 @@
       int newval, oldval;
       do
 	{
-	  oldval = mutex->__data.__lock;
+	  oldval = atomic_load(mutex->__data.__lock);
 	  newval = oldval & PTHREAD_MUTEX_PRIO_CEILING_MASK;
 	}
       while (atomic_compare_and_exchange_bool_rel (&mutex->__data.__lock,
diff -N -r --unified glibc-2.19/nptl/pthread_once.c glibc-2.19-totalpartial/nptl/pthread_once.c
--- glibc-2.19/nptl/pthread_once.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_once.c	2017-03-04 01:35:20.351744068 -0800
@@ -1,6 +1,5 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
+/* Copyright (C) 2004-2014 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -9,46 +8,82 @@
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
+   License along with the GNU C Library.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
 #include "pthreadP.h"
 #include <lowlevellock.h>
 
+unsigned long int __fork_generation attribute_hidden;
 
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
 
-static int once_lock = LLL_LOCK_INITIALIZER;
-
+  atomic_store(*once_control, 0);
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+}
 
 int
-__pthread_once (once_control, init_routine)
-     pthread_once_t *once_control;
-     void (*init_routine) (void);
+__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))
 {
-  /* XXX Depending on whether the LOCK_IN_ONCE_T is defined use a
-     global lock variable or one which is part of the pthread_once_t
-     object.  */
-  if (*once_control == PTHREAD_ONCE_INIT)
+  for (;;)
     {
-      lll_lock (once_lock, LLL_PRIVATE);
+      int oldval;
+      int newval;
 
-      /* XXX This implementation is not complete.  It doesn't take
-	 cancelation and fork into account.  */
-      if (*once_control == PTHREAD_ONCE_INIT)
+      /* Pseudo code:
+	 newval = __fork_generation | 1;
+	 oldval = *once_control;
+	 if ((oldval & 2) == 0)
+	   *once_control = newval;
+	 Do this atomically.
+      */
+      do
 	{
-	  init_routine ();
+	  newval = atomic_load(__fork_generation) | 1;
+	  oldval = atomic_load(*once_control);
+	  if (oldval & 2)
+	    break;
+	} while (atomic_compare_and_exchange_val_acq (once_control, newval, oldval) != oldval);
+
+      /* Check if the initializer has already been done.  */
+      if ((oldval & 2) != 0)
+	return 0;
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) == 0)
+	break;
+
+      /* Check whether the initializer execution was interrupted by a fork.  */
+      if (oldval != newval)
+	break;
 
-	  *once_control = !PTHREAD_ONCE_INIT;
-	}
-
-      lll_unlock (once_lock, LLL_PRIVATE);
+      /* Same generation, some other thread was faster. Wait.  */
+      lll_futex_wait (once_control, oldval, LLL_PRIVATE);
     }
 
+  /* This thread is the first here.  Do the initialization.
+     Register a cleanup handler so that in case the thread gets
+     interrupted the initialization can be restarted.  */
+  pthread_cleanup_push (clear_once_control, once_control);
+
+  init_routine ();
+
+  pthread_cleanup_pop (0);
+
+  /* Say that the initialisation is done.  */
+  atomic_store(*once_control, __fork_generation | 2);
+
+  /* Wake up all other threads.  */
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+
   return 0;
 }
-strong_alias (__pthread_once, pthread_once)
+weak_alias (__pthread_once, pthread_once)
 hidden_def (__pthread_once)
diff -N -r --unified glibc-2.19/nptl/pthread_setschedparam.c glibc-2.19-totalpartial/nptl/pthread_setschedparam.c
--- glibc-2.19/nptl/pthread_setschedparam.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_setschedparam.c	2017-03-04 01:35:20.351744068 -0800
@@ -54,7 +54,7 @@
     }
 
   /* Try to set the scheduler information.  */
-  if (__builtin_expect (__sched_setscheduler (pd->tid, policy,
+  if (__builtin_expect (__sched_setscheduler (atomic_load(pd->tid), policy,
 					      param) == -1, 0))
     result = errno;
   else
diff -N -r --unified glibc-2.19/nptl/pthread_setschedprio.c glibc-2.19-totalpartial/nptl/pthread_setschedprio.c
--- glibc-2.19/nptl/pthread_setschedprio.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_setschedprio.c	2017-03-04 01:35:20.351744068 -0800
@@ -48,7 +48,7 @@
     param.sched_priority = pd->tpp->priomax;
 
   /* Try to set the scheduler information.  */
-  if (__builtin_expect (sched_setparam (pd->tid, &param) == -1, 0))
+  if (__builtin_expect (sched_setparam (atomic_load(pd->tid), &param) == -1, 0))
     result = errno;
   else
     {
diff -N -r --unified glibc-2.19/nptl/pthread_spin_lock.c glibc-2.19-totalpartial/nptl/pthread_spin_lock.c
--- glibc-2.19/nptl/pthread_spin_lock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_spin_lock.c	2017-03-04 01:35:20.351744068 -0800
@@ -54,12 +54,12 @@
 	{
 	  int wait = SPIN_LOCK_READS_BETWEEN_CMPXCHG;
 
-	  while (*lock != 0 && wait > 0)
+	  while (atomic_load(*lock) != 0 && wait > 0)
 	    --wait;
 	}
       else
 	{
-	  while (*lock != 0)
+	  while (atomic_load(*lock) != 0)
 	    ;
 	}
     }
diff -N -r --unified glibc-2.19/nptl/pthread_spin_unlock.c glibc-2.19-totalpartial/nptl/pthread_spin_unlock.c
--- glibc-2.19/nptl/pthread_spin_unlock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_spin_unlock.c	2017-03-04 01:35:20.351744068 -0800
@@ -24,6 +24,6 @@
 pthread_spin_unlock (pthread_spinlock_t *lock)
 {
   atomic_full_barrier ();
-  *lock = 0;
+  atomic_store(*lock, 0);
   return 0;
 }
diff -N -r --unified glibc-2.19/nptl/pthread_timedjoin.c glibc-2.19-totalpartial/nptl/pthread_timedjoin.c
--- glibc-2.19/nptl/pthread_timedjoin.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_timedjoin.c	2017-03-04 01:35:20.351744068 -0800
@@ -50,7 +50,7 @@
     return EINVAL;
 
   self = THREAD_SELF;
-  if (pd == self || self->joinid == pd)
+  if (pd == self || atomic_load(self->joinid) == pd)
     /* This is a deadlock situation.  The threads are waiting for each
        other to finish.  Note that this is a "may" error.  To be 100%
        sure we catch this error we would have to lock the data
@@ -100,7 +100,7 @@
       __free_tcb (pd);
     }
   else
-    pd->joinid = NULL;
+    atomic_store(pd->joinid, NULL);
 
   return result;
 }
diff -N -r --unified glibc-2.19/nptl/pthread_tryjoin.c glibc-2.19-totalpartial/nptl/pthread_tryjoin.c
--- glibc-2.19/nptl/pthread_tryjoin.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/pthread_tryjoin.c	2017-03-04 01:35:20.351744068 -0800
@@ -42,7 +42,7 @@
     return EINVAL;
 
   self = THREAD_SELF;
-  if (pd == self || self->joinid == pd)
+  if (pd == self || atomic_load(self->joinid) == pd)
     /* This is a deadlock situation.  The threads are waiting for each
        other to finish.  Note that this is a "may" error.  To be 100%
        sure we catch this error we would have to lock the data
@@ -53,7 +53,7 @@
     return EDEADLK;
 
   /* Return right away if the thread hasn't terminated yet.  */
-  if (pd->tid != 0)
+  if (atomic_load(pd->tid) != 0)
     return EBUSY;
 
   /* Wait for the thread to finish.  If it is already locked something
diff -N -r --unified glibc-2.19/nptl/sysdeps/pthread/createthread.c glibc-2.19-totalpartial/nptl/sysdeps/pthread/createthread.c
--- glibc-2.19/nptl/sysdeps/pthread/createthread.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/pthread/createthread.c	2017-03-04 01:35:20.351744068 -0800
@@ -211,7 +211,7 @@
 
 	      /* Enqueue the descriptor.  */
 	      do
-		pd->nextevent = __nptl_last_event;
+		pd->nextevent = atomic_load(__nptl_last_event);
 	      while (atomic_compare_and_exchange_bool_acq (&__nptl_last_event,
 							   pd, pd->nextevent)
 		     != 0);
diff -N -r --unified glibc-2.19/nptl/sysdeps/pthread/list.h glibc-2.19-totalpartial/nptl/sysdeps/pthread/list.h
--- glibc-2.19/nptl/sysdeps/pthread/list.h	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/pthread/list.h	2017-03-04 01:35:20.352744068 -0800
@@ -57,11 +57,11 @@
 static inline void
 list_add (list_t *newp, list_t *head)
 {
-  newp->next = head->next;
+  newp->next = atomic_load(head->next);
   newp->prev = head;
-  head->next->prev = newp;
+  atomic_store(head->next->prev, newp);
   atomic_write_barrier ();
-  head->next = newp;
+  atomic_store(head->next, newp);
 }
 
 
@@ -69,8 +69,8 @@
 static inline void
 list_del (list_t *elem)
 {
-  elem->next->prev = elem->prev;
-  elem->prev->next = elem->next;
+  atomic_store(elem->next->prev, elem->prev);
+  atomic_store(elem->prev->next, elem->next);
 }
 
 
@@ -79,12 +79,12 @@
 list_splice (list_t *add, list_t *head)
 {
   /* Do nothing if the list which gets added is empty.  */
-  if (add != add->next)
+  if (add != atomic_load(add->next))
     {
-      add->next->prev = head;
-      add->prev->next = head->next;
-      head->next->prev = add->prev;
-      head->next = add->next;
+      atomic_store(add->next->prev, head);
+      atomic_store(add->prev->next, head->next);
+      atomic_store(head->next->prev, add->prev);
+      atomic_store(head->next, add->next);
     }
 }
 
@@ -97,20 +97,20 @@
 
 /* Iterate forward over the elements of the list.  */
 # define list_for_each(pos, head) \
-  for (pos = (head)->next; pos != (head); pos = pos->next)
+  for (pos = atomic_load((head)->next); pos != (head); pos = atomic_load(pos->next))
 
 
 /* Iterate forward over the elements of the list.  */
 # define list_for_each_prev(pos, head) \
-  for (pos = (head)->prev; pos != (head); pos = pos->prev)
+  for (pos = atomic_load((head)->prev); pos != (head); pos = atomic_load(pos->prev))
 
 
 /* Iterate backwards over the elements list.  The list elements can be
    removed from the list while doing this.  */
 # define list_for_each_prev_safe(pos, p, head) \
-  for (pos = (head)->prev, p = pos->prev; \
+  for (pos = atomic_load((head)->prev), p = atomic_load(pos->prev);	\
        pos != (head); \
-       pos = p, p = pos->prev)
+       pos = p, p = atomic_load(pos->prev))
 
 #endif /* _LIST_H */
 
diff -N -r --unified glibc-2.19/nptl/sysdeps/pthread/unwind-forcedunwind.c glibc-2.19-totalpartial/nptl/sysdeps/pthread/unwind-forcedunwind.c
--- glibc-2.19/nptl/sysdeps/pthread/unwind-forcedunwind.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/pthread/unwind-forcedunwind.c	2017-03-04 01:35:20.352744068 -0800
@@ -42,7 +42,7 @@
   void *getcfa;
   void *handle;
 
-  if (__builtin_expect (libgcc_s_handle != NULL, 1))
+  if (__builtin_expect (atomic_load(libgcc_s_handle) != NULL, 1))
     {
       /* Force gcc to reload all values.  */
       asm volatile ("" ::: "memory");
@@ -75,17 +75,17 @@
      pthread_cancel_init might return early even when the pointer the
      caller is interested in is not initialized yet.  */
   atomic_write_barrier ();
-  libgcc_s_handle = handle;
+  atomic_store(libgcc_s_handle, handle);
 }
 
 void
 __libc_freeres_fn_section
 __unwind_freeres (void)
 {
-  void *handle = libgcc_s_handle;
+  void *handle = atomic_load(libgcc_s_handle);
   if (handle != NULL)
     {
-      libgcc_s_handle = NULL;
+      atomic_store(libgcc_s_handle, NULL);
       __libc_dlclose (handle);
     }
 }
@@ -93,7 +93,7 @@
 void
 _Unwind_Resume (struct _Unwind_Exception *exc)
 {
-  if (__builtin_expect (libgcc_s_handle == NULL, 0))
+  if (__builtin_expect (atomic_load(libgcc_s_handle) == NULL, 0))
     pthread_cancel_init ();
   else
     atomic_read_barrier ();
@@ -109,7 +109,7 @@
 		      struct _Unwind_Exception *ue_header,
 		      struct _Unwind_Context *context)
 {
-  if (__builtin_expect (libgcc_s_handle == NULL, 0))
+  if (__builtin_expect (atomic_load(libgcc_s_handle) == NULL, 0))
     pthread_cancel_init ();
   else
     atomic_read_barrier ();
@@ -125,7 +125,7 @@
 _Unwind_ForcedUnwind (struct _Unwind_Exception *exc, _Unwind_Stop_Fn stop,
 		      void *stop_argument)
 {
-  if (__builtin_expect (libgcc_s_handle == NULL, 0))
+  if (__builtin_expect (atomic_load(libgcc_s_handle) == NULL, 0))
     pthread_cancel_init ();
   else
     atomic_read_barrier ();
@@ -140,7 +140,7 @@
 _Unwind_Word
 _Unwind_GetCFA (struct _Unwind_Context *context)
 {
-  if (__builtin_expect (libgcc_s_handle == NULL, 0))
+  if (__builtin_expect (atomic_load(libgcc_s_handle) == NULL, 0))
     pthread_cancel_init ();
   else
     atomic_read_barrier ();
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/fork.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/fork.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/fork.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/fork.c	2017-03-04 01:35:20.352744068 -0800
@@ -62,12 +62,12 @@
   /* Run all the registered preparation handlers.  In reverse order.
      While doing this we build up a list of all the entries.  */
   struct fork_handler *runp;
-  while ((runp = __fork_handlers) != NULL)
+  while ((runp = atomic_load(__fork_handlers)) != NULL)
     {
       /* Make sure we read from the current RUNP pointer.  */
       atomic_full_barrier ();
 
-      unsigned int oldval = runp->refcntr;
+      unsigned int oldval = atomic_load(runp->refcntr);
 
       if (oldval == 0)
 	/* This means some other thread removed the list just after
@@ -102,7 +102,7 @@
 	  allp = newp;
 
 	  /* Advance to the next handler.  */
-	  runp = runp->next;
+	  runp = atomic_load(runp->next);
 	  if (runp == NULL)
 	    break;
 
@@ -138,6 +138,8 @@
     {
       struct pthread *self = THREAD_SELF;
 
+      mvee_invalidate_buffer();
+
       assert (THREAD_GETMEM (self, tid) != ppid);
 
       if (__fork_generation_pointer != NULL)
@@ -223,10 +225,10 @@
 	    allp->handler->parent_handler ();
 
 	  if (atomic_decrement_and_test (&allp->handler->refcntr)
-	      && allp->handler->need_signal)
+	      && atomic_load(allp->handler->need_signal))
 	    lll_futex_wake (allp->handler->refcntr, 1, LLL_PRIVATE);
 
-	  allp = allp->next;
+	  allp = atomic_load(allp->next);
 	}
     }
 
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/lowlevellock.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/lowlevellock.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/lowlevellock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/lowlevellock.c	2017-03-04 01:35:20.352744068 -0800
@@ -26,7 +26,7 @@
 void
 __lll_lock_wait_private (int *futex)
 {
-  if (*futex == 2)
+  if (atomic_load(*futex) == 2)
     lll_futex_wait (futex, 2, LLL_PRIVATE);
 
   while (atomic_exchange_acq (futex, 2) != 0)
@@ -39,7 +39,7 @@
 void
 __lll_lock_wait (int *futex, int private)
 {
-  if (*futex == 2)
+  if (atomic_load(*futex) == 2)
     lll_futex_wait (futex, 2, private);
 
   while (atomic_exchange_acq (futex, 2) != 0)
@@ -92,7 +92,7 @@
     return EINVAL;
 
   /* Repeat until thread terminated.  */
-  while ((tid = *tidp) != 0)
+  while ((tid = atomic_load(*tidp)) != 0)
     {
       struct timeval tv;
       struct timespec rt;
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/lowlevelrobustlock.c	2017-03-04 01:35:20.352744068 -0800
@@ -26,7 +26,7 @@
 int
 __lll_robust_lock_wait (int *futex, int private)
 {
-  int oldval = *futex;
+  int oldval = atomic_load(*futex);
   int tid = THREAD_GETMEM (THREAD_SELF, tid);
 
   /* If the futex changed meanwhile try locking again.  */
@@ -64,7 +64,7 @@
     return EINVAL;
 
   int tid = THREAD_GETMEM (THREAD_SELF, tid);
-  int oldval = *futex;
+  int oldval = atomic_load(*futex);
 
   /* If the futex changed meanwhile try locking again.  */
   if (oldval == 0)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_getaffinity.c	2017-03-04 01:35:20.352744068 -0800
@@ -32,7 +32,7 @@
   const struct pthread *pd = (const struct pthread *) th;
 
   INTERNAL_SYSCALL_DECL (err);
-  int res = INTERNAL_SYSCALL (sched_getaffinity, err, 3, pd->tid,
+  int res = INTERNAL_SYSCALL (sched_getaffinity, err, 3, atomic_load(pd->tid),
 			      MIN (INT_MAX, cpusetsize), cpuset);
   if (INTERNAL_SYSCALL_ERROR_P (res, err))
     return INTERNAL_SYSCALL_ERRNO (res, err);
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_getcpuclockid.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_getcpuclockid.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_getcpuclockid.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_getcpuclockid.c	2017-03-04 01:35:20.352744068 -0800
@@ -38,7 +38,7 @@
 
   /* The clockid_t value is a simple computation from the TID.  */
 
-  const clockid_t tidclock = MAKE_THREAD_CPUCLOCK (pd->tid, CPUCLOCK_SCHED);
+  const clockid_t tidclock = MAKE_THREAD_CPUCLOCK (atomic_load(pd->tid), CPUCLOCK_SCHED);
 
   *clockid = tidclock;
   return 0;
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_getname.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_getname.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_getname.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_getname.c	2017-03-04 01:35:20.353744068 -0800
@@ -46,7 +46,7 @@
 
 #define FMT "/proc/self/task/%u/comm"
   char fname[sizeof (FMT) + 8];
-  sprintf (fname, FMT, (unsigned int) pd->tid);
+  sprintf (fname, FMT, (unsigned int) atomic_load(pd->tid));
 
   int fd = open_not_cancel_2 (fname, O_RDONLY);
   if (fd == -1)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_setaffinity.c	2017-03-04 01:35:20.353744068 -0800
@@ -63,7 +63,7 @@
 
   if (__builtin_expect (__kernel_cpumask_size == 0, 0))
     {
-      res = __determine_cpumask_size (pd->tid);
+      res = __determine_cpumask_size (atomic_load(pd->tid));
       if (res != 0)
 	return res;
     }
@@ -76,7 +76,7 @@
 	 fulfilled.  */
       return EINVAL;
 
-  res = INTERNAL_SYSCALL (sched_setaffinity, err, 3, pd->tid, cpusetsize,
+  res = INTERNAL_SYSCALL (sched_setaffinity, err, 3, atomic_load(pd->tid), cpusetsize,
 			  cpuset);
 
 #ifdef RESET_VGETCPU_CACHE
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_setname.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_setname.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/pthread_setname.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/pthread_setname.c	2017-03-04 01:35:20.353744068 -0800
@@ -46,7 +46,7 @@
 
 #define FMT "/proc/self/task/%u/comm"
   char fname[sizeof (FMT) + 8];
-  sprintf (fname, FMT, (unsigned int) pd->tid);
+  sprintf (fname, FMT, (unsigned int) atomic_load(pd->tid));
 
   int fd = open_not_cancel_2 (fname, O_RDWR);
   if (fd == -1)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/register-atfork.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/register-atfork.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/register-atfork.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/register-atfork.c	2017-03-04 01:35:20.353744068 -0800
@@ -49,18 +49,18 @@
     {
       /* Search for an empty entry.  */
       for (i = 0; i < NHANDLER; ++i)
-	if (runp->mem[i].refcntr == 0)
+	if (atomic_load(runp->mem[i].refcntr) == 0)
 	  goto found;
     }
-  while ((runp = runp->next) != NULL);
+  while ((runp = atomic_load(runp->next)) != NULL);
 
   /* We have to allocate a new entry.  */
   runp = (struct fork_handler_pool *) calloc (1, sizeof (*runp));
   if (runp != NULL)
     {
       /* Enqueue the new memory pool into the list.  */
-      runp->next = fork_handler_pool.next;
-      fork_handler_pool.next = runp;
+      runp->next = atomic_load(fork_handler_pool.next);
+      atomic_store(fork_handler_pool.next, runp);
 
       /* We use the last entry on the page.  This means when we start
 	 searching from the front the next time we will find the first
@@ -69,8 +69,8 @@
 
     found:
       result = &runp->mem[i];
-      result->refcntr = 1;
-      result->need_signal = 0;
+      atomic_store(result->refcntr, 1);
+      atomic_store(result->need_signal, 0);
     }
 
   return result;
@@ -113,7 +113,7 @@
 __linkin_atfork (struct fork_handler *newp)
 {
   do
-    newp->next = __fork_handlers;
+    newp->next = atomic_load(__fork_handlers);
   while (catomic_compare_and_exchange_bool_acq (&__fork_handlers,
 						newp, newp->next) != 0);
 }
@@ -125,7 +125,7 @@
   lll_lock (__fork_lock, LLL_PRIVATE);
 
   /* No more fork handlers.  */
-  __fork_handlers = NULL;
+  atomic_store(__fork_handlers, NULL);
 
   /* Free eventually allocated memory blocks for the object pool.  */
   struct fork_handler_pool *runp = fork_handler_pool.next;
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/sem_post.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/sem_post.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/sem_post.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/sem_post.c	2017-03-04 01:35:20.353744068 -0800
@@ -34,8 +34,8 @@
   __typeof (isem->value) cur;
   do
     {
-      cur = isem->value;
-      if (isem->value == SEM_VALUE_MAX)
+      cur = atomic_load(isem->value);
+      if (cur == SEM_VALUE_MAX)
 	{
 	  __set_errno (EOVERFLOW);
 	  return -1;
@@ -44,7 +44,7 @@
   while (atomic_compare_and_exchange_bool_rel (&isem->value, cur + 1, cur));
 
   atomic_full_barrier ();
-  if (isem->nwaiters > 0)
+  if (atomic_load(isem->nwaiters) > 0)
     {
       int err = lll_futex_wake (&isem->value, 1,
 				isem->private ^ FUTEX_PRIVATE_FLAG);
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/sem_trywait.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/sem_trywait.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/sem_trywait.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/sem_trywait.c	2017-03-04 01:35:20.353744068 -0800
@@ -32,7 +32,7 @@
   int *futex = (int *) sem;
   int val;
 
-  if (*futex > 0)
+  if (atomic_load(*futex) > 0)
     {
       val = atomic_decrement_if_positive (futex);
       if (val > 0)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/timer_routines.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/timer_routines.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/timer_routines.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/timer_routines.c	2017-03-04 01:35:20.353744068 -0800
@@ -182,7 +182,7 @@
   int res = pthread_create (&th, &attr, timer_helper_thread, NULL);
   if (res == 0)
     /* We managed to start the helper thread.  */
-    __helper_tid = ((struct pthread *) th)->tid;
+    __helper_tid = atomic_load(((struct pthread *) th)->tid);
 
   /* Restore the signal mask.  */
   INTERNAL_SYSCALL (rt_sigprocmask, err, 4, SIG_SETMASK, &oss, NULL,
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/unregister-atfork.c	2017-03-04 01:35:20.353744068 -0800
@@ -33,16 +33,16 @@
      We do not worry about other threads adding entries for this DSO
      right this moment.  If this happens this is a race and we can do
      whatever we please.  The program will crash anyway seen.  */
-  struct fork_handler *runp = __fork_handlers;
+  struct fork_handler *runp = atomic_load(__fork_handlers);
   struct fork_handler *lastp = NULL;
 
   while (runp != NULL)
-    if (runp->dso_handle == dso_handle)
+    if (atomic_load(runp->dso_handle) == dso_handle)
       break;
     else
       {
 	lastp = runp;
-	runp = runp->next;
+	runp = atomic_load(runp->next);
       }
 
   if (runp == NULL)
@@ -67,7 +67,7 @@
   do
     {
     again:
-      if (runp->dso_handle == dso_handle)
+      if (atomic_load(runp->dso_handle) == dso_handle)
 	{
 	  if (lastp == NULL)
 	    {
@@ -77,12 +77,12 @@
 							 runp->next, runp)
 		  != 0)
 		{
-		  runp = __fork_handlers;
+		  runp = atomic_load(__fork_handlers);
 		  goto again;
 		}
 	    }
 	  else
-	    lastp->next = runp->next;
+	    atomic_store(lastp->next, runp->next);
 
 	  /* We cannot overwrite the ->next element now.  Put the deleted
 	     entries in a separate list.  */
@@ -94,7 +94,7 @@
       else
 	lastp = runp;
 
-      runp = runp->next;
+      runp = atomic_load(runp->next);
     }
   while (runp != NULL);
 
@@ -105,7 +105,7 @@
   while (deleted != NULL)
     {
       /* We need to be informed by possible current users.  */
-      deleted->handler->need_signal = 1;
+      atomic_store(deleted->handler->need_signal, 1);
       /* Make sure this gets written out first.  */
       atomic_write_barrier ();
 
@@ -113,7 +113,7 @@
 	 wait for the last user.  */
       atomic_decrement (&deleted->handler->refcntr);
       unsigned int val;
-      while ((val = deleted->handler->refcntr) != 0)
+      while ((val = atomic_load(deleted->handler->refcntr)) != 0)
 	lll_futex_wait (&deleted->handler->refcntr, val, LLL_PRIVATE);
 
       deleted = deleted->next;
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/clone.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,9 +0,0 @@
-/* We want an #include_next, but we are the main source file.
-   So, #include ourselves and in that incarnation we can use #include_next.  */
-#ifndef INCLUDED_SELF
-# define INCLUDED_SELF
-# include <clone.S>
-#else
-# define RESET_PID
-# include_next <clone.S>
-#endif
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/libc-lowlevellock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/libc-lowlevellock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/libc-lowlevellock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/libc-lowlevellock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,19 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include "lowlevellock.S"
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h	2017-03-04 01:35:20.354744068 -0800
@@ -1,6 +1,5 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
+/* Copyright (C) 2005-2014 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -9,61 +8,42 @@
 
    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
    Lesser General Public License for more details.
 
    You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
+   License along with the GNU C Library.  If not, see
    <http://www.gnu.org/licenses/>.  */
 
 #ifndef _LOWLEVELLOCK_H
 #define _LOWLEVELLOCK_H	1
 
-#include <stap-probe.h>
-
 #ifndef __ASSEMBLER__
-# include <time.h>
-# include <sys/param.h>
-# include <bits/pthreadtypes.h>
-# include <kernel-features.h>
-# include <tcb-offsets.h>
-
-# ifndef LOCK_INSTR
-#  ifdef UP
-#   define LOCK_INSTR	/* nothing */
-#  else
-#   define LOCK_INSTR "lock;"
-#  endif
-# endif
-#else
-# ifndef LOCK
-#  ifdef UP
-#   define LOCK
-#  else
-#   define LOCK lock
-#  endif
-# endif
-#endif
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <kernel-features.h>
+#endif // </__ASSEMBLER__>
 
-#define SYS_futex		__NR_futex
 #define FUTEX_WAIT		0
 #define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
 #define FUTEX_CMP_REQUEUE	4
 #define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
 #define FUTEX_LOCK_PI		6
 #define FUTEX_UNLOCK_PI		7
 #define FUTEX_TRYLOCK_PI	8
 #define FUTEX_WAIT_BITSET	9
 #define FUTEX_WAKE_BITSET	10
-#define FUTEX_WAIT_REQUEUE_PI	11
-#define FUTEX_CMP_REQUEUE_PI	12
+#define FUTEX_WAIT_REQUEUE_PI   11
+#define FUTEX_CMP_REQUEUE_PI    12
 #define FUTEX_PRIVATE_FLAG	128
 #define FUTEX_CLOCK_REALTIME	256
 
 #define FUTEX_BITSET_MATCH_ANY	0xffffffff
 
-#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
-
 /* Values for 'private' parameter of locking macros.  Yes, the
    definition seems to be backwards.  But it is not.  The bit will be
    reversed before passing to the system call.  */
@@ -71,7 +51,6 @@
 #define LLL_SHARED	FUTEX_PRIVATE_FLAG
 
 #ifndef __ASSEMBLER__
-
 #if !defined NOT_IN_libc || defined IS_IN_rtld
 /* In libc.so or ld.so all futexes are private.  */
 # ifdef __ASSUME_PRIVATE_FUTEX
@@ -91,535 +70,262 @@
    ? ((private) == 0							      \
       ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
       : (fl))								      \
-   : ({ unsigned int __fl = ((private) ^ FUTEX_PRIVATE_FLAG);		      \
-	asm ("andl %%fs:%P1, %0" : "+r" (__fl)				      \
-	     : "i" (offsetof (struct pthread, header.private_futex)));	      \
-	__fl | (fl); }))
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
 # endif
 #endif
+#endif
 
-/* Initializer for lock.  */
-#define LLL_LOCK_INITIALIZER		(0)
-#define LLL_LOCK_INITIALIZER_LOCKED	(1)
-#define LLL_LOCK_INITIALIZER_WAITERS	(2)
 
-/* Delay in spinlock loop.  */
-#define BUSY_WAIT_NOP	  asm ("rep; nop")
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait(futexp, val, NULL, private)
 
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+    __ret;								      \
+  })
 
-#define LLL_STUB_UNWIND_INFO_START \
-	".section	.eh_frame,\"a\",@progbits\n" 		\
-"7:\t"	".long	9f-8f	# Length of Common Information Entry\n" \
-"8:\t"	".long	0x0	# CIE Identifier Tag\n\t" 		\
-	".byte	0x1	# CIE Version\n\t" 			\
-	".ascii \"zR\\0\"	# CIE Augmentation\n\t" 	\
-	".uleb128 0x1	# CIE Code Alignment Factor\n\t" 	\
-	".sleb128 -8	# CIE Data Alignment Factor\n\t" 	\
-	".byte	0x10	# CIE RA Column\n\t" 			\
-	".uleb128 0x1	# Augmentation size\n\t" 		\
-	".byte	0x1b	# FDE Encoding (pcrel sdata4)\n\t" 	\
-	".byte	0x12	# DW_CFA_def_cfa_sf\n\t" 		\
-	".uleb128 0x7\n\t" 					\
-	".sleb128 16\n\t" 					\
-	".align " LP_SIZE "\n" 					\
-"9:\t"	".long	23f-10f	# FDE Length\n" 			\
-"10:\t"	".long	10b-7b	# FDE CIE offset\n\t" 			\
-	".long	1b-.	# FDE initial location\n\t" 		\
-	".long	6b-1b	# FDE address range\n\t" 		\
-	".uleb128 0x0	# Augmentation size\n\t" 		\
-	".byte	0x16	# DW_CFA_val_expression\n\t" 		\
-	".uleb128 0x10\n\t" 					\
-	".uleb128 12f-11f\n" 					\
-"11:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
-	".sleb128 4b-1b\n"
-#define LLL_STUB_UNWIND_INFO_END \
-	".byte	0x16	# DW_CFA_val_expression\n\t" 		\
-	".uleb128 0x10\n\t" 					\
-	".uleb128 14f-13f\n" 					\
-"13:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
-	".sleb128 4b-2b\n" 					\
-"14:\t"	".byte	0x40 + (3b-2b) # DW_CFA_advance_loc\n\t" 	\
-	".byte	0x0e	# DW_CFA_def_cfa_offset\n\t" 		\
-	".uleb128 0\n\t" 					\
-	".byte	0x16	# DW_CFA_val_expression\n\t" 		\
-	".uleb128 0x10\n\t" 					\
-	".uleb128 16f-15f\n" 					\
-"15:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
-	".sleb128 4b-3b\n" 					\
-"16:\t"	".byte	0x40 + (4b-3b-1) # DW_CFA_advance_loc\n\t" 	\
-	".byte	0x0e	# DW_CFA_def_cfa_offset\n\t" 		\
-	".uleb128 128\n\t" 					\
-	".byte	0x16	# DW_CFA_val_expression\n\t" 		\
-	".uleb128 0x10\n\t" 					\
-	".uleb128 20f-17f\n" 					\
-"17:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
-	".sleb128 19f-18f\n\t" 					\
-	".byte	0x0d	# DW_OP_const4s\n" 			\
-"18:\t"	".4byte	4b-.\n\t" 					\
-	".byte	0x1c	# DW_OP_minus\n\t" 			\
-	".byte	0x0d	# DW_OP_const4s\n" 			\
-"19:\t"	".4byte	24f-.\n\t" 					\
-	".byte	0x22	# DW_OP_plus\n" 			\
-"20:\t"	".byte	0x40 + (5b-4b+1) # DW_CFA_advance_loc\n\t" 	\
-	".byte	0x13	# DW_CFA_def_cfa_offset_sf\n\t" 	\
-	".sleb128 16\n\t" 					\
-	".byte	0x16	# DW_CFA_val_expression\n\t" 		\
-	".uleb128 0x10\n\t" 					\
-	".uleb128 22f-21f\n" 					\
-"21:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
-	".sleb128 4b-5b\n" 					\
-"22:\t"	".align " LP_SIZE "\n" 					\
-"23:\t"	".previous\n"
-
-/* Unwind info for
-   1: leaq ..., %rdi
-   2: subq $128, %rsp
-   3: callq ...
-   4: addq $128, %rsp
-   5: jmp 24f
-   6:
-   snippet.  */
-#define LLL_STUB_UNWIND_INFO_5 \
-LLL_STUB_UNWIND_INFO_START					\
-"12:\t"	".byte	0x40 + (2b-1b) # DW_CFA_advance_loc\n\t" 	\
-LLL_STUB_UNWIND_INFO_END
-
-/* Unwind info for
-   1: leaq ..., %rdi
-   0: movq ..., %rdx
-   2: subq $128, %rsp
-   3: callq ...
-   4: addq $128, %rsp
-   5: jmp 24f
-   6:
-   snippet.  */
-#define LLL_STUB_UNWIND_INFO_6 \
-LLL_STUB_UNWIND_INFO_START					\
-"12:\t"	".byte	0x40 + (0b-1b) # DW_CFA_advance_loc\n\t" 	\
-	".byte	0x16	# DW_CFA_val_expression\n\t" 		\
-	".uleb128 0x10\n\t" 					\
-	".uleb128 26f-25f\n" 					\
-"25:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
-	".sleb128 4b-0b\n" 					\
-"26:\t"	".byte	0x40 + (2b-0b) # DW_CFA_advance_loc\n\t" 	\
-LLL_STUB_UNWIND_INFO_END
+#define lll_futex_timed_wait_bitset(futexp, val, timespec, clockbit, private) \
+  ({									\
+    INTERNAL_SYSCALL_DECL (__err);					\
+    long int __ret;							\
+    int __op = FUTEX_WAIT_BITSET | clockbit;				\
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		\
+			      __lll_private_flag (__op, private),	\
+			      (val), (timespec), NULL /* Unused.  */,	\
+			      FUTEX_BITSET_MATCH_ANY);			\
+    __ret;								\
+  })
 
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 4, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);					      \
+    __ret;								      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
 
-#define lll_futex_wait(futex, val, private) \
-  lll_futex_timed_wait(futex, val, NULL, private)
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
 
 
-#define lll_futex_timed_wait(futex, val, timeout, private) \
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
   ({									      \
-    register const struct timespec *__to __asm ("r10") = timeout;	      \
-    int __status;							      \
-    register __typeof (val) _val __asm ("edx") = (val);			      \
-    __asm __volatile ("syscall"						      \
-		      : "=a" (__status)					      \
-		      : "0" (SYS_futex), "D" (futex),			      \
-			"S" (__lll_private_flag (FUTEX_WAIT, private)),	      \
-			"d" (_val), "r" (__to)				      \
-		      : "memory", "cc", "r11", "cx");			      \
-    __status;								      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
   })
 
+/* Priority Inheritance support.  */
+#define lll_futex_wait_requeue_pi(futexp, val, mutex, private) \
+  lll_futex_timed_wait_requeue_pi (futexp, val, NULL, 0, mutex, private)
 
-#define lll_futex_wake(futex, nr, private) \
+#define lll_futex_timed_wait_requeue_pi(futexp, val, timespec, clockbit,      \
+					mutex, private)			      \
   ({									      \
-    int __status;							      \
-    register __typeof (nr) _nr __asm ("edx") = (nr);			      \
-    LIBC_PROBE (lll_futex_wake, 3, futex, nr, private);                       \
-    __asm __volatile ("syscall"						      \
-		      : "=a" (__status)					      \
-		      : "0" (SYS_futex), "D" (futex),			      \
-			"S" (__lll_private_flag (FUTEX_WAKE, private)),	      \
-			"d" (_nr)					      \
-		      : "memory", "cc", "r10", "r11", "cx");		      \
-    __status;								      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    int __op = FUTEX_WAIT_REQUEUE_PI | clockbit;			      \
+									      \
+    INTERNAL_SYSCALL (futex, __err, 5, (futexp),			      \
+		      __lll_private_flag (__op, private),		      \
+		      (val), (timespec), mutex); 			      \
   })
 
+#define lll_futex_cmp_requeue_pi(futexp, nr_wake, nr_move, mutex, val, priv)  \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+									      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE_PI, priv),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
 
-/* NB: in the lll_trylock macro we simply return the value in %eax
-   after the cmpxchg instruction.  In case the operation succeded this
-   value is zero.  In case the operation failed, the cmpxchg instruction
-   has loaded the current value of the memory work which is guaranteed
-   to be nonzero.  */
-#if defined NOT_IN_libc || defined UP
-# define __lll_trylock_asm LOCK_INSTR "cmpxchgl %2, %1"
-#else
-# define __lll_trylock_asm "cmpl $0, __libc_multiple_threads(%%rip)\n\t"      \
-			   "je 0f\n\t"					      \
-			   "lock; cmpxchgl %2, %1\n\t"			      \
-			   "jmp 1f\n\t"					      \
-			   "0:\tcmpxchgl %2, %1\n\t"			      \
-			   "1:"
-#endif
 
-#define lll_trylock(futex) \
-  ({ int ret;								      \
-     __asm __volatile (__lll_trylock_asm				      \
-		       : "=a" (ret), "=m" (futex)			      \
-		       : "r" (LLL_LOCK_INITIALIZER_LOCKED), "m" (futex),      \
-			 "0" (LLL_LOCK_INITIALIZER)			      \
-		       : "memory");					      \
-     ret; })
-
-#define lll_robust_trylock(futex, id) \
-  ({ int ret;								      \
-     __asm __volatile (LOCK_INSTR "cmpxchgl %2, %1"			      \
-		       : "=a" (ret), "=m" (futex)			      \
-		       : "r" (id), "m" (futex),	"0" (LLL_LOCK_INITIALIZER)    \
-		       : "memory");					      \
-     ret; })
-
-#define lll_cond_trylock(futex) \
-  ({ int ret;								      \
-     __asm __volatile (LOCK_INSTR "cmpxchgl %2, %1"			      \
-		       : "=a" (ret), "=m" (futex)			      \
-		       : "r" (LLL_LOCK_INITIALIZER_WAITERS),		      \
-			 "m" (futex), "0" (LLL_LOCK_INITIALIZER)	      \
-		       : "memory");					      \
-     ret; })
-
-#if defined NOT_IN_libc || defined UP
-# define __lll_lock_asm_start LOCK_INSTR "cmpxchgl %4, %2\n\t"		      \
-			      "jnz 1f\n\t"
-#else
-# define __lll_lock_asm_start "cmpl $0, __libc_multiple_threads(%%rip)\n\t"   \
-			      "je 0f\n\t"				      \
-			      "lock; cmpxchgl %4, %2\n\t"		      \
-			      "jnz 1f\n\t"				      \
-			      "jmp 24f\n"				      \
-			      "0:\tcmpxchgl %4, %2\n\t"			      \
-			      "jnz 1f\n\t"
+#define lll_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 1, 0)
+
+#define lll_cond_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 2, 0)
+
+#define __lll_robust_trylock(futex, id) \
+  (atomic_compare_and_exchange_val_acq (futex, id, 0) != 0)
+#define lll_robust_trylock(lock, id) \
+  __lll_robust_trylock (&(lock), id)
+
+#ifndef __ASSEMBLER__
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
 #endif
 
-#define lll_lock(futex, private) \
-  (void)								      \
-    ({ int ignore1, ignore2, ignore3;					      \
-       if (__builtin_constant_p (private) && (private) == LLL_PRIVATE)	      \
-	 __asm __volatile (__lll_lock_asm_start				      \
-			   ".subsection 1\n\t"				      \
-			   ".type _L_lock_%=, @function\n"		      \
-			   "_L_lock_%=:\n"				      \
-			   "1:\tlea %2, %%" RDI_LP "\n"			      \
-			   "2:\tsub $128, %%" RSP_LP "\n"		      \
-			   "3:\tcallq __lll_lock_wait_private\n"	      \
-			   "4:\tadd $128, %%" RSP_LP "\n"		      \
-			   "5:\tjmp 24f\n"				      \
-			   "6:\t.size _L_lock_%=, 6b-1b\n\t"		      \
-			   ".previous\n"				      \
-			   LLL_STUB_UNWIND_INFO_5			      \
-			   "24:"					      \
-			   : "=S" (ignore1), "=&D" (ignore2), "=m" (futex),   \
-			     "=a" (ignore3)				      \
-			   : "0" (1), "m" (futex), "3" (0)		      \
-			   : "cx", "r11", "cc", "memory");		      \
-       else								      \
-	 __asm __volatile (__lll_lock_asm_start				      \
-			   ".subsection 1\n\t"				      \
-			   ".type _L_lock_%=, @function\n"		      \
-			   "_L_lock_%=:\n"				      \
-			   "1:\tlea %2, %%" RDI_LP "\n"			      \
-			   "2:\tsub $128, %%" RSP_LP "\n"		      \
-			   "3:\tcallq __lll_lock_wait\n"		      \
-			   "4:\tadd $128, %%" RSP_LP "\n"		      \
-			   "5:\tjmp 24f\n"				      \
-			   "6:\t.size _L_lock_%=, 6b-1b\n\t"		      \
-			   ".previous\n"				      \
-			   LLL_STUB_UNWIND_INFO_5			      \
-			   "24:"					      \
-			   : "=S" (ignore1), "=D" (ignore2), "=m" (futex),    \
-			     "=a" (ignore3)				      \
-			   : "1" (1), "m" (futex), "3" (0), "0" (private)     \
-			   : "cx", "r11", "cc", "memory");		      \
-    })									      \
+#define __lll_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_compare_and_exchange_val_acq (__futex,       \
+								1, 0), 0))    \
+      {									      \
+	if (__builtin_constant_p (private) && (private) == LLL_PRIVATE)	      \
+	  __lll_lock_wait_private (__futex);				      \
+	else								      \
+	  __lll_lock_wait (__futex, private);				      \
+      }									      \
+  }))
+#define lll_lock(futex, private) __lll_lock (&(futex), private)
+
 
+#define __lll_robust_lock(futex, id, private)				      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_lock_wait (__futex, private);		      \
+    __val;								      \
+  })
 #define lll_robust_lock(futex, id, private) \
-  ({ int result, ignore1, ignore2;					      \
-    __asm __volatile (LOCK_INSTR "cmpxchgl %4, %2\n\t"			      \
-		      "jnz 1f\n\t"					      \
-		      ".subsection 1\n\t"				      \
-		      ".type _L_robust_lock_%=, @function\n"		      \
-		      "_L_robust_lock_%=:\n"				      \
-		      "1:\tlea %2, %%" RDI_LP "\n"			      \
-		      "2:\tsub $128, %%" RSP_LP "\n"			      \
-		      "3:\tcallq __lll_robust_lock_wait\n"		      \
-		      "4:\tadd $128, %%" RSP_LP "\n"			      \
-		      "5:\tjmp 24f\n"					      \
-		      "6:\t.size _L_robust_lock_%=, 6b-1b\n\t"		      \
-		      ".previous\n"					      \
-		      LLL_STUB_UNWIND_INFO_5				      \
-		      "24:"						      \
-		      : "=S" (ignore1), "=D" (ignore2), "=m" (futex),	      \
-			"=a" (result)					      \
-		      : "1" (id), "m" (futex), "3" (0), "0" (private)	      \
-		      : "cx", "r11", "cc", "memory");			      \
-    result; })
-
-#define lll_cond_lock(futex, private) \
-  (void)								      \
-    ({ int ignore1, ignore2, ignore3;					      \
-       __asm __volatile (LOCK_INSTR "cmpxchgl %4, %2\n\t"		      \
-			 "jnz 1f\n\t"					      \
-			 ".subsection 1\n\t"				      \
-			 ".type _L_cond_lock_%=, @function\n"		      \
-			 "_L_cond_lock_%=:\n"				      \
-			 "1:\tlea %2, %%" RDI_LP "\n"			      \
-			 "2:\tsub $128, %%" RSP_LP "\n"			      \
-			 "3:\tcallq __lll_lock_wait\n"			      \
-			 "4:\tadd $128, %%" RSP_LP "\n"			      \
-			 "5:\tjmp 24f\n"				      \
-			 "6:\t.size _L_cond_lock_%=, 6b-1b\n\t"		      \
-			 ".previous\n"					      \
-			 LLL_STUB_UNWIND_INFO_5				      \
-			 "24:"						      \
-			 : "=S" (ignore1), "=D" (ignore2), "=m" (futex),      \
-			   "=a" (ignore3)				      \
-			 : "1" (2), "m" (futex), "3" (0), "0" (private)	      \
-			 : "cx", "r11", "cc", "memory");		      \
-    })
+  __lll_robust_lock (&(futex), id, private)
+
+
+#define __lll_cond_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_exchange_acq (__futex, 2), 0))		      \
+      __lll_lock_wait (__futex, private);				      \
+  }))
+#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
+
 
 #define lll_robust_cond_lock(futex, id, private) \
-  ({ int result, ignore1, ignore2;					      \
-    __asm __volatile (LOCK_INSTR "cmpxchgl %4, %2\n\t"			      \
-		      "jnz 1f\n\t"					      \
-		      ".subsection 1\n\t"				      \
-		      ".type _L_robust_cond_lock_%=, @function\n"	      \
-		      "_L_robust_cond_lock_%=:\n"			      \
-		      "1:\tlea %2, %%" RDI_LP "\n"			      \
-		      "2:\tsub $128, %%" RSP_LP "\n"			      \
-		      "3:\tcallq __lll_robust_lock_wait\n"		      \
-		      "4:\tadd $128, %%" RSP_LP "\n"			      \
-		      "5:\tjmp 24f\n"					      \
-		      "6:\t.size _L_robust_cond_lock_%=, 6b-1b\n\t"	      \
-		      ".previous\n"					      \
-		      LLL_STUB_UNWIND_INFO_5				      \
-		      "24:"						      \
-		      : "=S" (ignore1), "=D" (ignore2), "=m" (futex),	      \
-			"=a" (result)					      \
-		      : "1" (id | FUTEX_WAITERS), "m" (futex), "3" (0),	      \
-			"0" (private)					      \
-		      : "cx", "r11", "cc", "memory");			      \
-    result; })
-
-#define lll_timedlock(futex, timeout, private) \
-  ({ int result, ignore1, ignore2, ignore3;				      \
-     __asm __volatile (LOCK_INSTR "cmpxchgl %1, %4\n\t"			      \
-		       "jnz 1f\n\t"					      \
-		       ".subsection 1\n\t"				      \
-		       ".type _L_timedlock_%=, @function\n"		      \
-		       "_L_timedlock_%=:\n"				      \
-		       "1:\tlea %4, %%" RDI_LP "\n"			      \
-		       "0:\tmov %8, %%" RDX_LP "\n"			      \
-		       "2:\tsub $128, %%" RSP_LP "\n"			      \
-		       "3:\tcallq __lll_timedlock_wait\n"		      \
-		       "4:\tadd $128, %%" RSP_LP "\n"			      \
-		       "5:\tjmp 24f\n"					      \
-		       "6:\t.size _L_timedlock_%=, 6b-1b\n\t"		      \
-		       ".previous\n"					      \
-		       LLL_STUB_UNWIND_INFO_6				      \
-		       "24:"						      \
-		       : "=a" (result), "=D" (ignore1), "=S" (ignore2),	      \
-			 "=&d" (ignore3), "=m" (futex)			      \
-		       : "0" (0), "1" (1), "m" (futex), "m" (timeout),	      \
-			 "2" (private)					      \
-		       : "memory", "cx", "cc", "r10", "r11");		      \
-     result; })
-
-extern int __lll_timedlock_elision (int *futex, short *adapt_count,
-					 const struct timespec *timeout,
-					 int private) attribute_hidden;
-
-#define lll_timedlock_elision(futex, adapt_count, timeout, private)	\
-  __lll_timedlock_elision(&(futex), &(adapt_count), timeout, private)
-
-#define lll_robust_timedlock(futex, timeout, id, private) \
-  ({ int result, ignore1, ignore2, ignore3;				      \
-     __asm __volatile (LOCK_INSTR "cmpxchgl %1, %4\n\t"			      \
-		       "jnz 1f\n\t"					      \
-		       ".subsection 1\n\t"				      \
-		       ".type _L_robust_timedlock_%=, @function\n"	      \
-		       "_L_robust_timedlock_%=:\n"			      \
-		       "1:\tlea %4, %%" RDI_LP "\n"			      \
-		       "0:\tmov %8, %%" RDX_LP "\n"			      \
-		       "2:\tsub $128, %%" RSP_LP "\n"			      \
-		       "3:\tcallq __lll_robust_timedlock_wait\n"	      \
-		       "4:\tadd $128, %%" RSP_LP "\n"			      \
-		       "5:\tjmp 24f\n"					      \
-		       "6:\t.size _L_robust_timedlock_%=, 6b-1b\n\t"	      \
-		       ".previous\n"					      \
-		       LLL_STUB_UNWIND_INFO_6				      \
-		       "24:"						      \
-		       : "=a" (result), "=D" (ignore1), "=S" (ignore2),       \
-			 "=&d" (ignore3), "=m" (futex)			      \
-		       : "0" (0), "1" (id), "m" (futex), "m" (timeout),	      \
-			 "2" (private)					      \
-		       : "memory", "cx", "cc", "r10", "r11");		      \
-     result; })
-
-#if defined NOT_IN_libc || defined UP
-# define __lll_unlock_asm_start LOCK_INSTR "decl %0\n\t"		      \
-				"jne 1f\n\t"
-#else
-# define __lll_unlock_asm_start "cmpl $0, __libc_multiple_threads(%%rip)\n\t" \
-				"je 0f\n\t"				      \
-				"lock; decl %0\n\t"			      \
-				"jne 1f\n\t"				      \
-				"jmp 24f\n\t"				      \
-				"0:\tdecl %0\n\t"			      \
-				"jne 1f\n\t"
+  __lll_robust_lock (&(futex), (id) | FUTEX_WAITERS, private)
+
+
+#ifndef __ASSEMBLER__
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
 #endif
 
-#define lll_unlock(futex, private) \
-  (void)								      \
-    ({ int ignore;							      \
-       if (__builtin_constant_p (private) && (private) == LLL_PRIVATE)	      \
-	 __asm __volatile (__lll_unlock_asm_start			      \
-			   ".subsection 1\n\t"				      \
-			   ".type _L_unlock_%=, @function\n"		      \
-			   "_L_unlock_%=:\n"				      \
-			   "1:\tlea %0, %%" RDI_LP "\n"			      \
-			   "2:\tsub $128, %%" RSP_LP "\n"		      \
-			   "3:\tcallq __lll_unlock_wake_private\n"	      \
-			   "4:\tadd $128, %%" RSP_LP "\n"		      \
-			   "5:\tjmp 24f\n"				      \
-			   "6:\t.size _L_unlock_%=, 6b-1b\n\t"		      \
-			   ".previous\n"				      \
-			   LLL_STUB_UNWIND_INFO_5			      \
-			   "24:"					      \
-			   : "=m" (futex), "=&D" (ignore)		      \
-			   : "m" (futex)				      \
-			   : "ax", "cx", "r11", "cc", "memory");	      \
-       else								      \
-	 __asm __volatile (__lll_unlock_asm_start			      \
-			   ".subsection 1\n\t"				      \
-			   ".type _L_unlock_%=, @function\n"		      \
-			   "_L_unlock_%=:\n"				      \
-			   "1:\tlea %0, %%" RDI_LP "\n"			      \
-			   "2:\tsub $128, %%" RSP_LP "\n"		      \
-			   "3:\tcallq __lll_unlock_wake\n"		      \
-			   "4:\tadd $128, %%" RSP_LP "\n"		      \
-			   "5:\tjmp 24f\n"				      \
-			   "6:\t.size _L_unlock_%=, 6b-1b\n\t"		      \
-			   ".previous\n"				      \
-			   LLL_STUB_UNWIND_INFO_5			      \
-			   "24:"					      \
-			   : "=m" (futex), "=&D" (ignore)		      \
-			   : "m" (futex), "S" (private)			      \
-			   : "ax", "cx", "r11", "cc", "memory");	      \
+#define __lll_timedlock(futex, abstime, private)			      \
+  ({									      \
+     int *__futex = (futex);						      \
+     int __val = 0;							      \
+									      \
+     if (__builtin_expect (atomic_exchange_acq (__futex, 1), 0))	      \
+       __val = __lll_timedlock_wait (__futex, abstime, private);	      \
+     __val;								      \
+  })
+#define lll_timedlock(futex, abstime, private) \
+  __lll_timedlock (&(futex), abstime, private)
+
+
+#define __lll_robust_timedlock(futex, abstime, id, private)		      \
+  ({									      \
+    int *__futex = (futex);						      \
+    int __val = 0;							      \
+									      \
+    if (__builtin_expect (atomic_compare_and_exchange_bool_acq (__futex, id,  \
+								0), 0))	      \
+      __val = __lll_robust_timedlock_wait (__futex, abstime, private);	      \
+    __val;								      \
+  })
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  __lll_robust_timedlock (&(futex), abstime, id, private)
+
+
+#define __lll_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval > 1, 0))			\
+	 lll_futex_wake (__futex, 1, private);			\
     })
+#define lll_unlock(futex, private) __lll_unlock(&(futex), private)
 
-#define lll_robust_unlock(futex, private) \
-  do									      \
-    {									      \
-      int ignore;							      \
-      __asm __volatile (LOCK_INSTR "andl %2, %0\n\t"			      \
-			"jne 1f\n\t"					      \
-			".subsection 1\n\t"				      \
-			".type _L_robust_unlock_%=, @function\n"	      \
-			"_L_robust_unlock_%=:\n"			      \
-			"1:\tlea %0, %%" RDI_LP "\n"			      \
-			"2:\tsub $128, %%" RSP_LP "\n"			      \
-			"3:\tcallq __lll_unlock_wake\n"			      \
-			"4:\tadd $128, %%" RSP_LP "\n"			      \
-			"5:\tjmp 24f\n"					      \
-			"6:\t.size _L_robust_unlock_%=, 6b-1b\n\t"	      \
-			".previous\n"					      \
-			LLL_STUB_UNWIND_INFO_5				      \
-			"24:"						      \
-			: "=m" (futex), "=&D" (ignore)			      \
-			: "i" (FUTEX_WAITERS), "m" (futex),		      \
-			  "S" (private)					      \
-			: "ax", "cx", "r11", "cc", "memory");		      \
-    }									      \
-  while (0)
 
-#define lll_robust_dead(futex, private) \
-  do									      \
-    {									      \
-      int ignore;							      \
-      __asm __volatile (LOCK_INSTR "orl %3, (%2)\n\t"			      \
-			"syscall"					      \
-			: "=m" (futex), "=a" (ignore)			      \
-			: "D" (&(futex)), "i" (FUTEX_OWNER_DIED),	      \
-			  "S" (__lll_private_flag (FUTEX_WAKE, private)),     \
-			  "1" (__NR_futex), "d" (1)			      \
-			: "cx", "r11", "cc", "memory");			      \
-    }									      \
-  while (0)
+#define __lll_robust_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval & FUTEX_WAITERS, 0))	\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_robust_unlock(futex, private) \
+  __lll_robust_unlock(&(futex), private)
 
-/* Returns non-zero if error happened, zero if success.  */
-#define lll_futex_requeue(ftx, nr_wake, nr_move, mutex, val, private) \
-  ({ int __res;								      \
-     register int __nr_move __asm ("r10") = nr_move;			      \
-     register void *__mutex __asm ("r8") = mutex;			      \
-     register int __val __asm ("r9") = val;				      \
-     __asm __volatile ("syscall"					      \
-		       : "=a" (__res)					      \
-		       : "0" (__NR_futex), "D" ((void *) ftx),		      \
-			 "S" (__lll_private_flag (FUTEX_CMP_REQUEUE,	      \
-						  private)), "d" (nr_wake),   \
-			 "r" (__nr_move), "r" (__mutex), "r" (__val)	      \
-		       : "cx", "r11", "cc", "memory");			      \
-     __res < 0; })
 
 #define lll_islocked(futex) \
-  (futex != LLL_LOCK_INITIALIZER)
+  (futex != 0)
 
 
+/* Our internal lock implementation is identical to the binary-compatible
+   mutex implementation. */
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+/* The states of a lock are:
+    0  -  untaken
+    1  -  taken by one user
+   >1  -  taken by more users */
+
 /* The kernel notifies a process which uses CLONE_CHILD_CLEARTID via futex
    wakeup when the clone terminates.  The memory location contains the
    thread ID while the clone is running and is reset to zero
-   afterwards.
-
-   The macro parameter must not have any side effect.  */
-#define lll_wait_tid(tid) \
-  do {									      \
-    int __ignore;							      \
-    register __typeof (tid) _tid asm ("edx") = (tid);			      \
-    if (_tid != 0)							      \
-      __asm __volatile ("xorq %%r10, %%r10\n\t"				      \
-			"1:\tmovq %2, %%rax\n\t"			      \
-			"syscall\n\t"					      \
-			"cmpl $0, (%%rdi)\n\t"				      \
-			"jne 1b"					      \
-			: "=&a" (__ignore)				      \
-			: "S" (FUTEX_WAIT), "i" (SYS_futex), "D" (&tid),      \
-			  "d" (_tid)					      \
-			: "memory", "cc", "r10", "r11", "cx");		      \
+   afterwards.	*/
+#define lll_wait_tid(tid)						\
+  do {									\
+    __typeof (tid) __tid;						\
+    /* we must perform the call because the kernel will introduce */    \
+    /* a datarace by clearing the tids */				\
+    if ((__tid = atomic_load(tid)) != 0 || mvee_should_sync_tid())	\
+      syscall(__NR_futex, &(tid), __lll_private_flag(mvee_should_sync_tid() ? MVEE_FUTEX_WAIT_TID : FUTEX_WAIT, LLL_SHARED), __tid, NULL); \
   } while (0)
 
-extern int __lll_timedwait_tid (int *tid, const struct timespec *abstime)
+#ifndef __ASSEMBLER__
+extern int __lll_timedwait_tid (int *, const struct timespec *)
      attribute_hidden;
-#define lll_timedwait_tid(tid, abstime) \
-  ({									      \
-    int __result = 0;							      \
-    if (tid != 0)							      \
-      {									      \
-	if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)	      \
-	  __result = EINVAL;						      \
-	else								      \
-	  __result = __lll_timedwait_tid (&tid, abstime);		      \
-      }									      \
-    __result; })
-
-extern int __lll_lock_elision (int *futex, short *adapt_count, int private)
-  attribute_hidden;
-
-extern int __lll_unlock_elision (int *lock, int private)
-  attribute_hidden;
-
-extern int __lll_trylock_elision (int *lock, short *adapt_count)
-  attribute_hidden;
-
-#define lll_lock_elision(futex, adapt_count, private) \
-  __lll_lock_elision (&(futex), &(adapt_count), private)
-#define lll_unlock_elision(futex, private) \
-  __lll_unlock_elision (&(futex), private)
-#define lll_trylock_elision(futex, adapt_count) \
-  __lll_trylock_elision (&(futex), &(adapt_count))
+#endif
 
-#endif  /* !__ASSEMBLER__ */
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if (atomic_load(tid) != 0 || mvee_should_sync_tid())	\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
 
 #endif	/* lowlevellock.h */
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,462 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <pthread-errnos.h>
-#include <kernel-features.h>
-#include <lowlevellock.h>
-
-#include <stap-probe.h>
-
-	.text
-
-#ifdef __ASSUME_PRIVATE_FUTEX
-# define LOAD_PRIVATE_FUTEX_WAIT(reg) \
-	movl	$(FUTEX_WAIT | FUTEX_PRIVATE_FLAG), reg
-# define LOAD_PRIVATE_FUTEX_WAKE(reg) \
-	movl	$(FUTEX_WAKE | FUTEX_PRIVATE_FLAG), reg
-# define LOAD_FUTEX_WAIT(reg) \
-	xorl	$(FUTEX_WAIT | FUTEX_PRIVATE_FLAG), reg
-# define LOAD_FUTEX_WAIT_ABS(reg) \
-	xorl	$(FUTEX_WAIT_BITSET | FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME), reg
-# define LOAD_FUTEX_WAKE(reg) \
-	xorl	$(FUTEX_WAKE | FUTEX_PRIVATE_FLAG), reg
-#else
-# if FUTEX_WAIT == 0
-#  define LOAD_PRIVATE_FUTEX_WAIT(reg) \
-	movl    %fs:PRIVATE_FUTEX, reg
-# else
-#  define LOAD_PRIVATE_FUTEX_WAIT(reg) \
-	movl	%fs:PRIVATE_FUTEX, reg ; \
-	orl	$FUTEX_WAIT, reg
-# endif
-# define LOAD_PRIVATE_FUTEX_WAKE(reg) \
-	movl    %fs:PRIVATE_FUTEX, reg ; \
-	orl     $FUTEX_WAKE, reg
-# if FUTEX_WAIT == 0
-#  define LOAD_FUTEX_WAIT(reg) \
-	xorl	$FUTEX_PRIVATE_FLAG, reg ; \
-	andl	%fs:PRIVATE_FUTEX, reg
-# else
-#  define LOAD_FUTEX_WAIT(reg) \
-	xorl	$FUTEX_PRIVATE_FLAG, reg ; \
-	andl	%fs:PRIVATE_FUTEX, reg ; \
-	orl	$FUTEX_WAIT, reg
-# endif
-# define LOAD_FUTEX_WAIT_ABS(reg) \
-	xorl	$FUTEX_PRIVATE_FLAG, reg ; \
-	andl	%fs:PRIVATE_FUTEX, reg ; \
-	orl	$FUTEX_WAIT_BITSET | FUTEX_CLOCK_REALTIME, reg
-# define LOAD_FUTEX_WAKE(reg) \
-	xorl	$FUTEX_PRIVATE_FLAG, reg ; \
-	andl	%fs:PRIVATE_FUTEX, reg ; \
-	orl	$FUTEX_WAKE, reg
-#endif
-
-
-	.globl	__lll_lock_wait_private
-	.type	__lll_lock_wait_private,@function
-	.hidden	__lll_lock_wait_private
-	.align	16
-__lll_lock_wait_private:
-	cfi_startproc
-	pushq	%r10
-	cfi_adjust_cfa_offset(8)
-	pushq	%rdx
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%r10, -16)
-	cfi_offset(%rdx, -24)
-	xorq	%r10, %r10	/* No timeout.  */
-	movl	$2, %edx
-	LOAD_PRIVATE_FUTEX_WAIT (%esi)
-
-	cmpl	%edx, %eax	/* NB:	 %edx == 2 */
-	jne	2f
-
-1:	LIBC_PROBE (lll_lock_wait_private, 1, %rdi)
-	movl	$SYS_futex, %eax
-	syscall
-
-2:	movl	%edx, %eax
-	xchgl	%eax, (%rdi)	/* NB:	 lock is implied */
-
-	testl	%eax, %eax
-	jnz	1b
-
-	popq	%rdx
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%rdx)
-	popq	%r10
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r10)
-	retq
-	cfi_endproc
-	.size	__lll_lock_wait_private,.-__lll_lock_wait_private
-
-#ifdef NOT_IN_libc
-	.globl	__lll_lock_wait
-	.type	__lll_lock_wait,@function
-	.hidden	__lll_lock_wait
-	.align	16
-__lll_lock_wait:
-	cfi_startproc
-	pushq	%r10
-	cfi_adjust_cfa_offset(8)
-	pushq	%rdx
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%r10, -16)
-	cfi_offset(%rdx, -24)
-	xorq	%r10, %r10	/* No timeout.  */
-	movl	$2, %edx
-	LOAD_FUTEX_WAIT (%esi)
-
-	cmpl	%edx, %eax	/* NB:	 %edx == 2 */
-	jne	2f
-
-1:	LIBC_PROBE (lll_lock_wait, 2, %rdi, %rsi)
-	movl	$SYS_futex, %eax
-	syscall
-
-2:	movl	%edx, %eax
-	xchgl	%eax, (%rdi)	/* NB:	 lock is implied */
-
-	testl	%eax, %eax
-	jnz	1b
-
-	popq	%rdx
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%rdx)
-	popq	%r10
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r10)
-	retq
-	cfi_endproc
-	.size	__lll_lock_wait,.-__lll_lock_wait
-
-	/*      %rdi: futex
-		%rsi: flags
-		%rdx: timeout
-		%eax: futex value
-	*/
-	.globl	__lll_timedlock_wait
-	.type	__lll_timedlock_wait,@function
-	.hidden	__lll_timedlock_wait
-	.align	16
-__lll_timedlock_wait:
-	cfi_startproc
-# ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-#  ifdef PIC
-	cmpl	$0, __have_futex_clock_realtime(%rip)
-#  else
-	cmpl	$0, __have_futex_clock_realtime
-#  endif
-	je	.Lreltmo
-# endif
-
-	cmpq	$0, (%rdx)
-	js	5f
-
-	pushq	%r9
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r9, 0)
-
-	movq	%rdx, %r10
-	movl	$0xffffffff, %r9d
-	LOAD_FUTEX_WAIT_ABS (%esi)
-
-	movl	$2, %edx
-	cmpl	%edx, %eax
-	jne	2f
-
-1:	movl	$SYS_futex, %eax
-	movl	$2, %edx
-	syscall
-
-2:	xchgl	%edx, (%rdi)	/* NB:   lock is implied */
-
-	testl	%edx, %edx
-	jz	3f
-
-	cmpl	$-ETIMEDOUT, %eax
-	je	4f
-	cmpl	$-EINVAL, %eax
-	jne	1b
-4:	movl	%eax, %edx
-	negl	%edx
-
-3:	movl	%edx, %eax
-	popq	%r9
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r9)
-	retq
-
-5:	movl	$ETIMEDOUT, %eax
-	retq
-
-# ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-.Lreltmo:
-	/* Check for a valid timeout value.  */
-	cmpq	$1000000000, 8(%rdx)
-	jae	3f
-
-	pushq	%r8
-	cfi_adjust_cfa_offset(8)
-	pushq	%r9
-	cfi_adjust_cfa_offset(8)
-	pushq	%r12
-	cfi_adjust_cfa_offset(8)
-	pushq	%r13
-	cfi_adjust_cfa_offset(8)
-	pushq	%r14
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%r8, -16)
-	cfi_offset(%r9, -24)
-	cfi_offset(%r12, -32)
-	cfi_offset(%r13, -40)
-	cfi_offset(%r14, -48)
-	pushq	%rsi
-	cfi_adjust_cfa_offset(8)
-
-	/* Stack frame for the timespec and timeval structs.  */
-	subq	$24, %rsp
-	cfi_adjust_cfa_offset(24)
-
-	movq	%rdi, %r12
-	movq	%rdx, %r13
-
-	movl	$2, %edx
-	xchgl	%edx, (%r12)
-
-	testl	%edx, %edx
-	je	6f
-
-1:
-	/* Get current time.  */
-	movq	%rsp, %rdi
-	xorl	%esi, %esi
-	/* This call works because we directly jump to a system call entry
-	   which preserves all the registers.  */
-	call	JUMPTARGET(__gettimeofday)
-
-	/* Compute relative timeout.  */
-	movq	8(%rsp), %rax
-	movl	$1000, %edi
-	mul	%rdi		/* Milli seconds to nano seconds.  */
-	movq	(%r13), %rdi
-	movq	8(%r13), %rsi
-	subq	(%rsp), %rdi
-	subq	%rax, %rsi
-	jns	4f
-	addq	$1000000000, %rsi
-	decq	%rdi
-4:	testq	%rdi, %rdi
-	js	2f		/* Time is already up.  */
-
-	/* Store relative timeout.  */
-	movq	%rdi, (%rsp)
-	movq	%rsi, 8(%rsp)
-
-	/* Futex call.  */
-	movl	$2, %edx
-	movl	$1, %eax
-	movq	%rsp, %r10
-	movl	24(%rsp), %esi
-	LOAD_FUTEX_WAIT (%esi)
-	movq	%r12, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-
-	/* NB: %edx == 2 */
-	xchgl	%edx, (%r12)
-
-	testl	%edx, %edx
-	je	6f
-
-	cmpl	$-ETIMEDOUT, %eax
-	jne	1b
-2:	movl	$ETIMEDOUT, %edx
-
-6:	addq	$32, %rsp
-	cfi_adjust_cfa_offset(-32)
-	popq	%r14
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r14)
-	popq	%r13
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r13)
-	popq	%r12
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r12)
-	popq	%r9
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r9)
-	popq	%r8
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r8)
-	movl	%edx, %eax
-	retq
-
-3:	movl	$EINVAL, %eax
-	retq
-# endif
-	cfi_endproc
-	.size	__lll_timedlock_wait,.-__lll_timedlock_wait
-#endif
-
-
-	.globl	__lll_unlock_wake_private
-	.type	__lll_unlock_wake_private,@function
-	.hidden	__lll_unlock_wake_private
-	.align	16
-__lll_unlock_wake_private:
-	cfi_startproc
-	pushq	%rsi
-	cfi_adjust_cfa_offset(8)
-	pushq	%rdx
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%rsi, -16)
-	cfi_offset(%rdx, -24)
-
-	movl	$0, (%rdi)
-	LOAD_PRIVATE_FUTEX_WAKE (%esi)
-	movl	$1, %edx	/* Wake one thread.  */
-	movl	$SYS_futex, %eax
-	syscall
-
-	popq	%rdx
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%rdx)
-	popq	%rsi
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%rsi)
-	retq
-	cfi_endproc
-	.size	__lll_unlock_wake_private,.-__lll_unlock_wake_private
-
-#ifdef NOT_IN_libc
-	.globl	__lll_unlock_wake
-	.type	__lll_unlock_wake,@function
-	.hidden	__lll_unlock_wake
-	.align	16
-__lll_unlock_wake:
-	cfi_startproc
-	pushq	%rsi
-	cfi_adjust_cfa_offset(8)
-	pushq	%rdx
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%rsi, -16)
-	cfi_offset(%rdx, -24)
-
-	movl	$0, (%rdi)
-	LOAD_FUTEX_WAKE (%esi)
-	movl	$1, %edx	/* Wake one thread.  */
-	movl	$SYS_futex, %eax
-	syscall
-
-	popq	%rdx
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%rdx)
-	popq	%rsi
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%rsi)
-	retq
-	cfi_endproc
-	.size	__lll_unlock_wake,.-__lll_unlock_wake
-
-	.globl	__lll_timedwait_tid
-	.type	__lll_timedwait_tid,@function
-	.hidden	__lll_timedwait_tid
-	.align	16
-__lll_timedwait_tid:
-	cfi_startproc
-	pushq	%r12
-	cfi_adjust_cfa_offset(8)
-	pushq	%r13
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%r12, -16)
-	cfi_offset(%r13, -24)
-
-	movq	%rdi, %r12
-	movq	%rsi, %r13
-
-	subq	$16, %rsp
-	cfi_adjust_cfa_offset(16)
-
-	/* Get current time.  */
-2:	movq	%rsp, %rdi
-	xorl	%esi, %esi
-	/* This call works because we directly jump to a system call entry
-	   which preserves all the registers.  */
-	call	JUMPTARGET(__gettimeofday)
-
-	/* Compute relative timeout.  */
-	movq	8(%rsp), %rax
-	movl	$1000, %edi
-	mul	%rdi		/* Milli seconds to nano seconds.  */
-	movq	(%r13), %rdi
-	movq	8(%r13), %rsi
-	subq	(%rsp), %rdi
-	subq	%rax, %rsi
-	jns	5f
-	addq	$1000000000, %rsi
-	decq	%rdi
-5:	testq	%rdi, %rdi
-	js	6f		/* Time is already up.  */
-
-	movq	%rdi, (%rsp)	/* Store relative timeout.  */
-	movq	%rsi, 8(%rsp)
-
-	movl	(%r12), %edx
-	testl	%edx, %edx
-	jz	4f
-
-	movq	%rsp, %r10
-	/* XXX The kernel so far uses global futex for the wakeup at
-	   all times.  */
-#if FUTEX_WAIT == 0
-	xorl	%esi, %esi
-#else
-	movl	$FUTEX_WAIT, %esi
-#endif
-	movq	%r12, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-
-	cmpl	$0, (%rdi)
-	jne	1f
-4:	xorl	%eax, %eax
-
-8:	addq	$16, %rsp
-	cfi_adjust_cfa_offset(-16)
-	popq	%r13
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r13)
-	popq	%r12
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r12)
-	retq
-
-	cfi_adjust_cfa_offset(32)
-1:	cmpq	$-ETIMEDOUT, %rax
-	jne	2b
-
-6:	movl	$ETIMEDOUT, %eax
-	jmp	8b
-	cfi_endproc
-	.size	__lll_timedwait_tid,.-__lll_timedwait_tid
-#endif
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,306 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <pthread-errnos.h>
-#include <lowlevellock.h>
-#include <lowlevelrobustlock.h>
-#include <kernel-features.h>
-
-	.text
-
-#define FUTEX_WAITERS		0x80000000
-#define FUTEX_OWNER_DIED	0x40000000
-
-#ifdef __ASSUME_PRIVATE_FUTEX
-# define LOAD_FUTEX_WAIT(reg) \
-	xorl	$(FUTEX_WAIT | FUTEX_PRIVATE_FLAG), reg
-# define LOAD_FUTEX_WAIT_ABS(reg) \
-	xorl	$(FUTEX_WAIT_BITSET | FUTEX_PRIVATE_FLAG | FUTEX_CLOCK_REALTIME), reg
-#else
-# if FUTEX_WAIT == 0
-#  define LOAD_FUTEX_WAIT(reg) \
-	xorl	$FUTEX_PRIVATE_FLAG, reg ; \
-	andl	%fs:PRIVATE_FUTEX, reg
-# else
-#  define LOAD_FUTEX_WAIT(reg) \
-	xorl	$FUTEX_PRIVATE_FLAG, reg ; \
-	andl	%fs:PRIVATE_FUTEX, reg ; \
-	orl	$FUTEX_WAIT, reg
-# endif
-# define LOAD_FUTEX_WAIT_ABS(reg) \
-	xorl	$FUTEX_PRIVATE_FLAG, reg ; \
-	andl	%fs:PRIVATE_FUTEX, reg ; \
-	orl	$FUTEX_WAIT_BITSET | FUTEX_CLOCK_REALTIME, reg
-#endif
-
-
-	.globl	__lll_robust_lock_wait
-	.type	__lll_robust_lock_wait,@function
-	.hidden	__lll_robust_lock_wait
-	.align	16
-__lll_robust_lock_wait:
-	cfi_startproc
-	pushq	%r10
-	cfi_adjust_cfa_offset(8)
-	pushq	%rdx
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%r10, -16)
-	cfi_offset(%rdx, -24)
-
-	xorq	%r10, %r10	/* No timeout.  */
-	LOAD_FUTEX_WAIT (%esi)
-
-4:	movl	%eax, %edx
-	orl	$FUTEX_WAITERS, %edx
-
-	testl	$FUTEX_OWNER_DIED, %eax
-	jnz	3f
-
-	cmpl	%edx, %eax
-	je	1f
-
-	LOCK
-	cmpxchgl %edx, (%rdi)
-	jnz	2f
-
-1:	movl	$SYS_futex, %eax
-	syscall
-
-	movl	(%rdi), %eax
-
-2:	testl	%eax, %eax
-	jne	4b
-
-	movl	%fs:TID, %edx
-	orl	$FUTEX_WAITERS, %edx
-	LOCK
-	cmpxchgl %edx, (%rdi)
-	jnz	4b
-	/* NB:	 %rax == 0 */
-
-3:	popq	%rdx
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%rdx)
-	popq	%r10
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r10)
-	retq
-	cfi_endproc
-	.size	__lll_robust_lock_wait,.-__lll_robust_lock_wait
-
-
-	.globl	__lll_robust_timedlock_wait
-	.type	__lll_robust_timedlock_wait,@function
-	.hidden	__lll_robust_timedlock_wait
-	.align	16
-__lll_robust_timedlock_wait:
-	cfi_startproc
-# ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-#  ifdef PIC
-	cmpl	$0, __have_futex_clock_realtime(%rip)
-#  else
-	cmpl	$0, __have_futex_clock_realtime
-#  endif
-	je	.Lreltmo
-# endif
-
-	cmpq	$0, (%rdx)
-	js	7f
-
-	pushq	%r9
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r9, 0)
-	movq	%rdx, %r10
-	movl	$0xffffffff, %r9d
-	LOAD_FUTEX_WAIT_ABS (%esi)
-
-1:	testl	$FUTEX_OWNER_DIED, %eax
-	jnz	3f
-
-	movl	%eax, %edx
-	orl	$FUTEX_WAITERS, %edx
-
-	cmpl	%eax, %edx
-	je	5f
-
-	LOCK
-	cmpxchgl %edx, (%rdi)
-	movq	$0, %rcx	/* Must use mov to avoid changing cc.  */
-	jnz	6f
-
-5:	movl	$SYS_futex, %eax
-	syscall
-	movl	%eax, %ecx
-
-	movl	(%rdi), %eax
-
-6:	testl	%eax, %eax
-	jne	2f
-
-	movl	%fs:TID, %edx
-	orl	$FUTEX_WAITERS, %edx
-	LOCK
-	cmpxchgl %edx, (%rdi)
-	jnz	2f
-
-3:	popq	%r9
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r9)
-	retq
-
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r9, 0)
-	/* Check whether the time expired.  */
-2:	cmpl	$-ETIMEDOUT, %ecx
-	je	4f
-	cmpl	$-EINVAL, %ecx
-	jne	1b
-
-4:	movl	%ecx, %eax
-	negl	%eax
-	jmp	3b
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r9)
-
-7:	movl	$ETIMEDOUT, %eax
-	retq
-
-
-# ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-.Lreltmo:
-	/* Check for a valid timeout value.  */
-	cmpq	$1000000000, 8(%rdx)
-	jae	3f
-
-	pushq	%r8
-	cfi_adjust_cfa_offset(8)
-	pushq	%r9
-	cfi_adjust_cfa_offset(8)
-	pushq	%r12
-	cfi_adjust_cfa_offset(8)
-	pushq	%r13
-	cfi_adjust_cfa_offset(8)
-	cfi_offset(%r8, -16)
-	cfi_offset(%r9, -24)
-	cfi_offset(%r12, -32)
-	cfi_offset(%r13, -40)
-	pushq	%rsi
-	cfi_adjust_cfa_offset(8)
-
-	/* Stack frame for the timespec and timeval structs.  */
-	subq	$32, %rsp
-	cfi_adjust_cfa_offset(32)
-
-	movq	%rdi, %r12
-	movq	%rdx, %r13
-
-1:	movq	%rax, 16(%rsp)
-
-	/* Get current time.  */
-	movq	%rsp, %rdi
-	xorl	%esi, %esi
-	/* This call works because we directly jump to a system call entry
-	   which preserves all the registers.  */
-	call	JUMPTARGET(__gettimeofday)
-
-	/* Compute relative timeout.  */
-	movq	8(%rsp), %rax
-	movl	$1000, %edi
-	mul	%rdi		/* Milli seconds to nano seconds.  */
-	movq	(%r13), %rdi
-	movq	8(%r13), %rsi
-	subq	(%rsp), %rdi
-	subq	%rax, %rsi
-	jns	4f
-	addq	$1000000000, %rsi
-	decq	%rdi
-4:	testq	%rdi, %rdi
-	js	8f		/* Time is already up.  */
-
-	/* Futex call.  */
-	movq	%rdi, (%rsp)	/* Store relative timeout.  */
-	movq	%rsi, 8(%rsp)
-
-	movq	16(%rsp), %rdx
-	movl	%edx, %eax
-	orl	$FUTEX_WAITERS, %edx
-
-	testl	$FUTEX_OWNER_DIED, %eax
-	jnz	6f
-
-	cmpl	%eax, %edx
-	je	2f
-
-	LOCK
-	cmpxchgl %edx, (%r12)
-	movq	$0, %rcx	/* Must use mov to avoid changing cc.  */
-	jnz	5f
-
-2:	movq	%rsp, %r10
-	movl	32(%rsp), %esi
-	LOAD_FUTEX_WAIT (%esi)
-	movq	%r12, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-	movq	%rax, %rcx
-
-	movl	(%r12), %eax
-
-5:	testl	%eax, %eax
-	jne	7f
-
-	movl	%fs:TID, %edx
-	orl	$FUTEX_WAITERS, %edx
-	LOCK
-	cmpxchgl %edx, (%r12)
-	jnz	7f
-
-6:	addq	$40, %rsp
-	cfi_adjust_cfa_offset(-40)
-	popq	%r13
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r13)
-	popq	%r12
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r12)
-	popq	%r9
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r9)
-	popq	%r8
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r8)
-	retq
-
-3:	movl	$EINVAL, %eax
-	retq
-
-	cfi_adjust_cfa_offset(72)
-	cfi_offset(%r8, -16)
-	cfi_offset(%r9, -24)
-	cfi_offset(%r12, -32)
-	cfi_offset(%r13, -40)
-	/* Check whether the time expired.  */
-7:	cmpl	$-ETIMEDOUT, %ecx
-	jne	1b
-
-8:	movl	$ETIMEDOUT, %eax
-	jmp	6b
-#endif
-	cfi_endproc
-	.size	__lll_robust_timedlock_wait,.-__lll_robust_timedlock_wait
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_barrier_wait.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,160 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <lowlevelbarrier.h>
-
-
-	.text
-
-	.globl	pthread_barrier_wait
-	.type	pthread_barrier_wait,@function
-	.align	16
-pthread_barrier_wait:
-	/* Get the mutex.  */
-	xorl	%eax, %eax
-	movl	$1, %esi
-	LOCK
-	cmpxchgl %esi, MUTEX(%rdi)
-	jnz	1f
-
-	/* One less waiter.  If this was the last one needed wake
-	   everybody.  */
-2:	decl	LEFT(%rdi)
-	je	3f
-
-	/* There are more threads to come.  */
-#if CURR_EVENT == 0
-	movl	(%rdi), %edx
-#else
-	movl	CURR_EVENT(%rdi), %edx
-#endif
-
-	/* Release the mutex.  */
-	LOCK
-	decl	MUTEX(%rdi)
-	jne	6f
-
-	/* Wait for the remaining threads.  The call will return immediately
-	   if the CURR_EVENT memory has meanwhile been changed.  */
-7:
-#if FUTEX_WAIT == 0
-	movl	PRIVATE(%rdi), %esi
-#else
-	movl	$FUTEX_WAIT, %esi
-	orl	PRIVATE(%rdi), %esi
-#endif
-	xorq	%r10, %r10
-8:	movl	$SYS_futex, %eax
-	syscall
-
-	/* Don't return on spurious wakeups.  The syscall does not change
-	   any register except %eax so there is no need to reload any of
-	   them.  */
-#if CURR_EVENT == 0
-	cmpl	%edx, (%rdi)
-#else
-	cmpl	%edx, CURR_EVENT(%rdi)
-#endif
-	je	8b
-
-	/* Increment LEFT.  If this brings the count back to the
-	   initial count unlock the object.  */
-	movl	$1, %edx
-	movl	INIT_COUNT(%rdi), %eax
-	LOCK
-	xaddl	%edx, LEFT(%rdi)
-	subl	$1, %eax
-	cmpl	%eax, %edx
-	jne,pt	10f
-
-	/* Release the mutex.  We cannot release the lock before
-	   waking the waiting threads since otherwise a new thread might
-	   arrive and gets waken up, too.  */
-	LOCK
-	decl	MUTEX(%rdi)
-	jne	9f
-
-10:	xorl	%eax, %eax		/* != PTHREAD_BARRIER_SERIAL_THREAD */
-
-	retq
-
-	/* The necessary number of threads arrived.  */
-3:
-#if CURR_EVENT == 0
-	incl	(%rdi)
-#else
-	incl	CURR_EVENT(%rdi)
-#endif
-
-	/* Wake up all waiters.  The count is a signed number in the kernel
-	   so 0x7fffffff is the highest value.  */
-	movl	$0x7fffffff, %edx
-	movl	$FUTEX_WAKE, %esi
-	orl	PRIVATE(%rdi), %esi
-	movl	$SYS_futex, %eax
-	syscall
-
-	/* Increment LEFT.  If this brings the count back to the
-	   initial count unlock the object.  */
-	movl	$1, %edx
-	movl	INIT_COUNT(%rdi), %eax
-	LOCK
-	xaddl	%edx, LEFT(%rdi)
-	subl	$1, %eax
-	cmpl	%eax, %edx
-	jne,pt	5f
-
-	/* Release the mutex.  We cannot release the lock before
-	   waking the waiting threads since otherwise a new thread might
-	   arrive and gets waken up, too.  */
-	LOCK
-	decl	MUTEX(%rdi)
-	jne	4f
-
-5:	orl	$-1, %eax		/* == PTHREAD_BARRIER_SERIAL_THREAD */
-
-	retq
-
-1:	movl	PRIVATE(%rdi), %esi
-	addq	$MUTEX, %rdi
-	xorl	$LLL_SHARED, %esi
-	callq	__lll_lock_wait
-	subq	$MUTEX, %rdi
-	jmp	2b
-
-4:	movl	PRIVATE(%rdi), %esi
-	addq	$MUTEX, %rdi
-	xorl	$LLL_SHARED, %esi
-	callq	__lll_unlock_wake
-	jmp	5b
-
-6:	movl	PRIVATE(%rdi), %esi
-	addq	$MUTEX, %rdi
-	xorl	$LLL_SHARED, %esi
-	callq	__lll_unlock_wake
-	subq	$MUTEX, %rdi
-	jmp	7b
-
-9:	movl	PRIVATE(%rdi), %esi
-	addq	$MUTEX, %rdi
-	xorl	$LLL_SHARED, %esi
-	callq	__lll_unlock_wake
-	jmp	10b
-	.size	pthread_barrier_wait,.-pthread_barrier_wait
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,179 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <shlib-compat.h>
-#include <lowlevellock.h>
-#include <lowlevelcond.h>
-#include <kernel-features.h>
-#include <pthread-pi-defines.h>
-#include <pthread-errnos.h>
-#include <stap-probe.h>
-
-	.text
-
-	/* int pthread_cond_broadcast (pthread_cond_t *cond) */
-	.globl	__pthread_cond_broadcast
-	.type	__pthread_cond_broadcast, @function
-	.align	16
-__pthread_cond_broadcast:
-
-	LIBC_PROBE (cond_broadcast, 1, %rdi)
-
-	/* Get internal lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jnz	1f
-
-2:	addq	$cond_futex, %rdi
-	movq	total_seq-cond_futex(%rdi), %r9
-	cmpq	wakeup_seq-cond_futex(%rdi), %r9
-	jna	4f
-
-	/* Cause all currently waiting threads to recognize they are
-	   woken up.  */
-	movq	%r9, wakeup_seq-cond_futex(%rdi)
-	movq	%r9, woken_seq-cond_futex(%rdi)
-	addq	%r9, %r9
-	movl	%r9d, (%rdi)
-	incl	broadcast_seq-cond_futex(%rdi)
-
-	/* Get the address of the mutex used.  */
-	mov	dep_mutex-cond_futex(%rdi), %R8_LP
-
-	/* Unlock.  */
-	LOCK
-	decl	cond_lock-cond_futex(%rdi)
-	jne	7f
-
-8:	cmp	$-1, %R8_LP
-	je	9f
-
-	/* Do not use requeue for pshared condvars.  */
-	testl	$PS_BIT, MUTEX_KIND(%r8)
-	jne	9f
-
-	/* Requeue to a PI mutex if the PI bit is set.  */
-	movl	MUTEX_KIND(%r8), %eax
-	andl	$(ROBUST_BIT|PI_BIT), %eax
-	cmpl	$PI_BIT, %eax
-	je	81f
-
-	/* Wake up all threads.  */
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$(FUTEX_CMP_REQUEUE|FUTEX_PRIVATE_FLAG), %esi
-#else
-	movl	%fs:PRIVATE_FUTEX, %esi
-	orl	$FUTEX_CMP_REQUEUE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	movl	$1, %edx
-	movl	$0x7fffffff, %r10d
-	syscall
-
-	/* For any kind of error, which mainly is EAGAIN, we try again
-	   with WAKE.  The general test also covers running on old
-	   kernels.  */
-	cmpq	$-4095, %rax
-	jae	9f
-
-10:	xorl	%eax, %eax
-	retq
-
-	/* Wake up all threads.  */
-81:	movl	$(FUTEX_CMP_REQUEUE_PI|FUTEX_PRIVATE_FLAG), %esi
-	movl	$SYS_futex, %eax
-	movl	$1, %edx
-	movl	$0x7fffffff, %r10d
-	syscall
-
-	/* For any kind of error, which mainly is EAGAIN, we try again
-	   with WAKE.  The general test also covers running on old
-	   kernels.  */
-	cmpq	$-4095, %rax
-	jb	10b
-	jmp	9f
-
-	.align	16
-	/* Unlock.  */
-4:	LOCK
-	decl	cond_lock-cond_futex(%rdi)
-	jne	5f
-
-6:	xorl	%eax, %eax
-	retq
-
-	/* Initial locking failed.  */
-1:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-#if cond_lock != 0
-	subq	$cond_lock, %rdi
-#endif
-	jmp	2b
-
-	/* Unlock in loop requires wakeup.  */
-5:	addq	$cond_lock-cond_futex, %rdi
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-	jmp	6b
-
-	/* Unlock in loop requires wakeup.  */
-7:	addq	$cond_lock-cond_futex, %rdi
-	cmp	$-1, %R8_LP
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-	subq	$cond_lock-cond_futex, %rdi
-	jmp	8b
-
-9:	/* The futex requeue functionality is not available.  */
-	cmp	$-1, %R8_LP
-	movl	$0x7fffffff, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE, %eax
-	movl	$(FUTEX_WAKE|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-#else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-	orl	$FUTEX_WAKE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-	jmp	10b
-	.size	__pthread_cond_broadcast, .-__pthread_cond_broadcast
-versioned_symbol (libpthread, __pthread_cond_broadcast, pthread_cond_broadcast,
-		  GLIBC_2_3_2)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,164 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <shlib-compat.h>
-#include <lowlevellock.h>
-#include <lowlevelcond.h>
-#include <pthread-pi-defines.h>
-#include <kernel-features.h>
-#include <pthread-errnos.h>
-#include <stap-probe.h>
-
-
-	.text
-
-	/* int pthread_cond_signal (pthread_cond_t *cond) */
-	.globl	__pthread_cond_signal
-	.type	__pthread_cond_signal, @function
-	.align	16
-__pthread_cond_signal:
-
-	LIBC_PROBE (cond_signal, 1, %rdi)
-
-	/* Get internal lock.  */
-	movq	%rdi, %r8
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jnz	1f
-
-2:	addq	$cond_futex, %rdi
-	movq	total_seq(%r8), %rcx
-	cmpq	wakeup_seq(%r8), %rcx
-	jbe	4f
-
-	/* Bump the wakeup number.  */
-	addq	$1, wakeup_seq(%r8)
-	addl	$1, (%rdi)
-
-	/* Wake up one thread.  */
-	LP_OP(cmp) $-1, dep_mutex(%r8)
-	movl	$FUTEX_WAKE_OP, %esi
-	movl	$1, %edx
-	movl	$SYS_futex, %eax
-	je	8f
-
-	/* Get the address of the mutex used.  */
-	mov     dep_mutex(%r8), %RCX_LP
-	movl	MUTEX_KIND(%rcx), %r11d
-	andl	$(ROBUST_BIT|PI_BIT), %r11d
-	cmpl	$PI_BIT, %r11d
-	je	9f
-
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$(FUTEX_WAKE_OP|FUTEX_PRIVATE_FLAG), %esi
-#else
-	orl	%fs:PRIVATE_FUTEX, %esi
-#endif
-
-8:	movl	$1, %r10d
-#if cond_lock != 0
-	addq	$cond_lock, %r8
-#endif
-	movl	$FUTEX_OP_CLEAR_WAKE_IF_GT_ONE, %r9d
-	syscall
-#if cond_lock != 0
-	subq	$cond_lock, %r8
-#endif
-	/* For any kind of error, we try again with WAKE.
-	   The general test also covers running on old kernels.  */
-	cmpq	$-4095, %rax
-	jae	7f
-
-	xorl	%eax, %eax
-	retq
-
-	/* Wake up one thread and requeue none in the PI Mutex case.  */
-9:	movl	$(FUTEX_CMP_REQUEUE_PI|FUTEX_PRIVATE_FLAG), %esi
-	movq	%rcx, %r8
-	xorq	%r10, %r10
-	movl	(%rdi), %r9d	// XXX Can this be right?
-	syscall
-
-	leaq	-cond_futex(%rdi), %r8
-
-	/* For any kind of error, we try again with WAKE.
-	   The general test also covers running on old kernels.  */
-	cmpq	$-4095, %rax
-	jb	4f
-
-7:
-#ifdef __ASSUME_PRIVATE_FUTEX
-	andl	$FUTEX_PRIVATE_FLAG, %esi
-#else
-	andl	%fs:PRIVATE_FUTEX, %esi
-#endif
-	orl	$FUTEX_WAKE, %esi
-	movl	$SYS_futex, %eax
-	/* %rdx should be 1 already from $FUTEX_WAKE_OP syscall.
-	movl	$1, %edx  */
-	syscall
-
-	/* Unlock.  */
-4:	LOCK
-#if cond_lock == 0
-	decl	(%r8)
-#else
-	decl	cond_lock(%r8)
-#endif
-	jne	5f
-
-6:	xorl	%eax, %eax
-	retq
-
-	/* Initial locking failed.  */
-1:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-#if cond_lock != 0
-	subq	$cond_lock, %rdi
-#endif
-	jmp	2b
-
-	/* Unlock in loop requires wakeup.  */
-5:
-	movq	%r8, %rdi
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-	jmp	6b
-	.size	__pthread_cond_signal, .-__pthread_cond_signal
-versioned_symbol (libpthread, __pthread_cond_signal, pthread_cond_signal,
-		  GLIBC_2_3_2)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,840 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <shlib-compat.h>
-#include <lowlevellock.h>
-#include <lowlevelcond.h>
-#include <pthread-pi-defines.h>
-#include <pthread-errnos.h>
-#include <stap-probe.h>
-
-#include <kernel-features.h>
-
-
-	.text
-
-
-/* int pthread_cond_timedwait (pthread_cond_t *cond, pthread_mutex_t *mutex,
-			       const struct timespec *abstime)  */
-	.globl	__pthread_cond_timedwait
-	.type	__pthread_cond_timedwait, @function
-	.align	16
-__pthread_cond_timedwait:
-.LSTARTCODE:
-	cfi_startproc
-#ifdef SHARED
-	cfi_personality(DW_EH_PE_pcrel | DW_EH_PE_sdata4 | DW_EH_PE_indirect,
-			DW.ref.__gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_pcrel | DW_EH_PE_sdata4, .LexceptSTART)
-#else
-	cfi_personality(DW_EH_PE_udata4, __gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_udata4, .LexceptSTART)
-#endif
-
-	pushq	%r12
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r12, 0)
-	pushq	%r13
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r13, 0)
-	pushq	%r14
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r14, 0)
-	pushq	%r15
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r15, 0)
-#ifdef __ASSUME_FUTEX_CLOCK_REALTIME
-# define FRAME_SIZE (32+8)
-#else
-# define FRAME_SIZE (48+8)
-#endif
-	subq	$FRAME_SIZE, %rsp
-	cfi_adjust_cfa_offset(FRAME_SIZE)
-	cfi_remember_state
-
-	LIBC_PROBE (cond_timedwait, 3, %rdi, %rsi, %rdx)
-
-	cmpq	$1000000000, 8(%rdx)
-	movl	$EINVAL, %eax
-	jae	48f
-
-	/* Stack frame:
-
-	   rsp + 48
-		    +--------------------------+
-	   rsp + 32 | timeout value            |
-		    +--------------------------+
-	   rsp + 24 | old wake_seq value       |
-		    +--------------------------+
-	   rsp + 16 | mutex pointer            |
-		    +--------------------------+
-	   rsp +  8 | condvar pointer          |
-		    +--------------------------+
-	   rsp +  4 | old broadcast_seq value  |
-		    +--------------------------+
-	   rsp +  0 | old cancellation mode    |
-		    +--------------------------+
-	*/
-
-	LP_OP(cmp) $-1, dep_mutex(%rdi)
-
-	/* Prepare structure passed to cancellation handler.  */
-	movq	%rdi, 8(%rsp)
-	movq	%rsi, 16(%rsp)
-	movq	%rdx, %r13
-
-	je	22f
-	mov	%RSI_LP, dep_mutex(%rdi)
-
-22:
-	xorb	%r15b, %r15b
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-#  ifdef PIC
-	cmpl	$0, __have_futex_clock_realtime(%rip)
-#  else
-	cmpl	$0, __have_futex_clock_realtime
-#  endif
-	je	.Lreltmo
-#endif
-
-	/* Get internal lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jnz	31f
-
-	/* Unlock the mutex.  */
-32:	movq	16(%rsp), %rdi
-	xorl	%esi, %esi
-	callq	__pthread_mutex_unlock_usercnt
-
-	testl	%eax, %eax
-	jne	46f
-
-	movq	8(%rsp), %rdi
-	incq	total_seq(%rdi)
-	incl	cond_futex(%rdi)
-	addl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
-
-	/* Get and store current wakeup_seq value.  */
-	movq	8(%rsp), %rdi
-	movq	wakeup_seq(%rdi), %r9
-	movl	broadcast_seq(%rdi), %edx
-	movq	%r9, 24(%rsp)
-	movl	%edx, 4(%rsp)
-
-	cmpq	$0, (%r13)
-	movq	$-ETIMEDOUT, %r14
-	js	36f
-
-38:	movl	cond_futex(%rdi), %r12d
-
-	/* Unlock.  */
-	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	jne	33f
-
-.LcleanupSTART1:
-34:	callq	__pthread_enable_asynccancel
-	movl	%eax, (%rsp)
-
-	movq	%r13, %r10
-	movl	$FUTEX_WAIT_BITSET, %esi
-	LP_OP(cmp) $-1, dep_mutex(%rdi)
-	je	60f
-
-	mov	dep_mutex(%rdi), %R8_LP
-	/* Requeue to a non-robust PI mutex if the PI bit is set and
-	the robust bit is not set.  */
-	movl	MUTEX_KIND(%r8), %eax
-	andl	$(ROBUST_BIT|PI_BIT), %eax
-	cmpl	$PI_BIT, %eax
-	jne	61f
-
-	movl	$(FUTEX_WAIT_REQUEUE_PI|FUTEX_PRIVATE_FLAG), %esi
-	xorl	%eax, %eax
-	/* The following only works like this because we only support
-	   two clocks, represented using a single bit.  */
-	testl	$1, cond_nwaiters(%rdi)
-	movl	$FUTEX_CLOCK_REALTIME, %edx
-	cmove	%edx, %eax
-	orl	%eax, %esi
-	movq	%r12, %rdx
-	addq	$cond_futex, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-
-	cmpl	$0, %eax
-	sete	%r15b
-
-#ifdef __ASSUME_REQUEUE_PI
-	jmp	62f
-#else
-	je	62f
-
-	/* When a futex syscall with FUTEX_WAIT_REQUEUE_PI returns
-	   successfully, it has already locked the mutex for us and the
-	   pi_flag (%r15b) is set to denote that fact.  However, if another
-	   thread changed the futex value before we entered the wait, the
-	   syscall may return an EAGAIN and the mutex is not locked.  We go
-	   ahead with a success anyway since later we look at the pi_flag to
-	   decide if we got the mutex or not.  The sequence numbers then make
-	   sure that only one of the threads actually wake up.  We retry using
-	   normal FUTEX_WAIT only if the kernel returned ENOSYS, since normal
-	   and PI futexes don't mix.
-
-	   Note that we don't check for EAGAIN specifically; we assume that the
-	   only other error the futex function could return is EAGAIN (barring
-	   the ETIMEOUT of course, for the timeout case in futex) since
-	   anything else would mean an error in our function.  It is too
-	   expensive to do that check for every call (which is  quite common in
-	   case of a large number of threads), so it has been skipped.  */
-	cmpl    $-ENOSYS, %eax
-	jne     62f
-
-	subq	$cond_futex, %rdi
-#endif
-
-61:	movl	$(FUTEX_WAIT_BITSET|FUTEX_PRIVATE_FLAG), %esi
-60:	xorb	%r15b, %r15b
-	xorl	%eax, %eax
-	/* The following only works like this because we only support
-	   two clocks, represented using a single bit.  */
-	testl	$1, cond_nwaiters(%rdi)
-	movl	$FUTEX_CLOCK_REALTIME, %edx
-	movl	$0xffffffff, %r9d
-	cmove	%edx, %eax
-	orl	%eax, %esi
-	movq	%r12, %rdx
-	addq	$cond_futex, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-62:	movq	%rax, %r14
-
-	movl	(%rsp), %edi
-	callq	__pthread_disable_asynccancel
-.LcleanupEND1:
-
-	/* Lock.  */
-	movq	8(%rsp), %rdi
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jne	35f
-
-36:	movl	broadcast_seq(%rdi), %edx
-
-	movq	woken_seq(%rdi), %rax
-
-	movq	wakeup_seq(%rdi), %r9
-
-	cmpl	4(%rsp), %edx
-	jne	53f
-
-	cmpq	24(%rsp), %r9
-	jbe	45f
-
-	cmpq	%rax, %r9
-	ja	39f
-
-45:	cmpq	$-ETIMEDOUT, %r14
-	je	99f
-
-	/* We need to go back to futex_wait.  If we're using requeue_pi, then
-	   release the mutex we had acquired and go back.  */
-	test	%r15b, %r15b
-	jz	38b
-
-	/* Adjust the mutex values first and then unlock it.  The unlock
-	   should always succeed or else the kernel did not lock the
-	   mutex correctly.  */
-	movq	%r8, %rdi
-	callq	__pthread_mutex_cond_lock_adjust
-	xorl	%esi, %esi
-	callq	__pthread_mutex_unlock_usercnt
-	/* Reload cond_var.  */
-	movq	8(%rsp), %rdi
-	jmp	38b
-
-99:	incq	wakeup_seq(%rdi)
-	incl	cond_futex(%rdi)
-	movl	$ETIMEDOUT, %r14d
-	jmp	44f
-
-53:	xorq	%r14, %r14
-	jmp	54f
-
-39:	xorq	%r14, %r14
-44:	incq	woken_seq(%rdi)
-
-54:	subl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
-
-	/* Wake up a thread which wants to destroy the condvar object.  */
-	cmpq	$0xffffffffffffffff, total_seq(%rdi)
-	jne	55f
-	movl	cond_nwaiters(%rdi), %eax
-	andl	$~((1 << nwaiters_shift) - 1), %eax
-	jne	55f
-
-	addq	$cond_nwaiters, %rdi
-	LP_OP(cmp) $-1, dep_mutex-cond_nwaiters(%rdi)
-	movl	$1, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE, %eax
-	movl	$(FUTEX_WAKE|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-#else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-	orl	$FUTEX_WAKE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-	subq	$cond_nwaiters, %rdi
-
-55:	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	jne	40f
-
-	/* If requeue_pi is used the kernel performs the locking of the
-	   mutex. */
-41:	movq	16(%rsp), %rdi
-	testb	%r15b, %r15b
-	jnz	64f
-
-	callq	__pthread_mutex_cond_lock
-
-63:	testq	%rax, %rax
-	cmoveq	%r14, %rax
-
-48:	addq	$FRAME_SIZE, %rsp
-	cfi_adjust_cfa_offset(-FRAME_SIZE)
-	popq	%r15
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r15)
-	popq	%r14
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r14)
-	popq	%r13
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r13)
-	popq	%r12
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r12)
-
-	retq
-
-	cfi_restore_state
-
-64:	callq	__pthread_mutex_cond_lock_adjust
-	movq	%r14, %rax
-	jmp	48b
-
-	/* Initial locking failed.  */
-31:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-	jmp	32b
-
-	/* Unlock in loop requires wakeup.  */
-33:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-	jmp	34b
-
-	/* Locking in loop failed.  */
-35:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-#if cond_lock != 0
-	subq	$cond_lock, %rdi
-#endif
-	jmp	36b
-
-	/* Unlock after loop requires wakeup.  */
-40:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-	jmp	41b
-
-	/* The initial unlocking of the mutex failed.  */
-46:	movq	8(%rsp), %rdi
-	movq	%rax, (%rsp)
-	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	jne	47f
-
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-
-47:	movq	(%rsp), %rax
-	jmp	48b
-
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-.Lreltmo:
-	/* Get internal lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-# if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-# else
-	cmpxchgl %esi, cond_lock(%rdi)
-# endif
-	jnz	1f
-
-	/* Unlock the mutex.  */
-2:	movq	16(%rsp), %rdi
-	xorl	%esi, %esi
-	callq	__pthread_mutex_unlock_usercnt
-
-	testl	%eax, %eax
-	jne	46b
-
-	movq	8(%rsp), %rdi
-	incq	total_seq(%rdi)
-	incl	cond_futex(%rdi)
-	addl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
-
-	/* Get and store current wakeup_seq value.  */
-	movq	8(%rsp), %rdi
-	movq	wakeup_seq(%rdi), %r9
-	movl	broadcast_seq(%rdi), %edx
-	movq	%r9, 24(%rsp)
-	movl	%edx, 4(%rsp)
-
-	/* Get the current time.  */
-8:
-# ifdef __NR_clock_gettime
-	/* Get the clock number.  Note that the field in the condvar
-	   structure stores the number minus 1.  */
-	movq	8(%rsp), %rdi
-	movl	cond_nwaiters(%rdi), %edi
-	andl	$((1 << nwaiters_shift) - 1), %edi
-	/* Only clocks 0 and 1 are allowed so far.  Both are handled in the
-	   kernel.  */
-	leaq	32(%rsp), %rsi
-#  ifdef SHARED
-	mov	__vdso_clock_gettime@GOTPCREL(%rip), %RAX_LP
-	mov	(%rax), %RAX_LP
-	PTR_DEMANGLE (%RAX_LP)
-	call	*%rax
-#  else
-	movl	$__NR_clock_gettime, %eax
-	syscall
-#  endif
-
-	/* Compute relative timeout.  */
-	movq	(%r13), %rcx
-	movq	8(%r13), %rdx
-	subq	32(%rsp), %rcx
-	subq	40(%rsp), %rdx
-# else
-	leaq	24(%rsp), %rdi
-	xorl	%esi, %esi
-	/* This call works because we directly jump to a system call entry
-	   which preserves all the registers.  */
-	call	JUMPTARGET(__gettimeofday)
-
-	/* Compute relative timeout.  */
-	movq	40(%rsp), %rax
-	movl	$1000, %edx
-	mul	%rdx		/* Milli seconds to nano seconds.  */
-	movq	(%r13), %rcx
-	movq	8(%r13), %rdx
-	subq	32(%rsp), %rcx
-	subq	%rax, %rdx
-# endif
-	jns	12f
-	addq	$1000000000, %rdx
-	decq	%rcx
-12:	testq	%rcx, %rcx
-	movq	8(%rsp), %rdi
-	movq	$-ETIMEDOUT, %r14
-	js	6f
-
-	/* Store relative timeout.  */
-21:	movq	%rcx, 32(%rsp)
-	movq	%rdx, 40(%rsp)
-
-	movl	cond_futex(%rdi), %r12d
-
-	/* Unlock.  */
-	LOCK
-# if cond_lock == 0
-	decl	(%rdi)
-# else
-	decl	cond_lock(%rdi)
-# endif
-	jne	3f
-
-.LcleanupSTART2:
-4:	callq	__pthread_enable_asynccancel
-	movl	%eax, (%rsp)
-
-	leaq	32(%rsp), %r10
-	LP_OP(cmp) $-1, dep_mutex(%rdi)
-	movq	%r12, %rdx
-# ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAIT, %eax
-	movl	$(FUTEX_WAIT|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-# else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-#  if FUTEX_WAIT != 0
-	orl	$FUTEX_WAIT, %esi
-#  endif
-# endif
-	addq	$cond_futex, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-	movq	%rax, %r14
-
-	movl	(%rsp), %edi
-	callq	__pthread_disable_asynccancel
-.LcleanupEND2:
-
-	/* Lock.  */
-	movq	8(%rsp), %rdi
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-# if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-# else
-	cmpxchgl %esi, cond_lock(%rdi)
-# endif
-	jne	5f
-
-6:	movl	broadcast_seq(%rdi), %edx
-
-	movq	woken_seq(%rdi), %rax
-
-	movq	wakeup_seq(%rdi), %r9
-
-	cmpl	4(%rsp), %edx
-	jne	53b
-
-	cmpq	24(%rsp), %r9
-	jbe	15f
-
-	cmpq	%rax, %r9
-	ja	39b
-
-15:	cmpq	$-ETIMEDOUT, %r14
-	jne	8b
-
-	jmp	99b
-
-	/* Initial locking failed.  */
-1:
-# if cond_lock != 0
-	addq	$cond_lock, %rdi
-# endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-	jmp	2b
-
-	/* Unlock in loop requires wakeup.  */
-3:
-# if cond_lock != 0
-	addq	$cond_lock, %rdi
-# endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-	jmp	4b
-
-	/* Locking in loop failed.  */
-5:
-# if cond_lock != 0
-	addq	$cond_lock, %rdi
-# endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-# if cond_lock != 0
-	subq	$cond_lock, %rdi
-# endif
-	jmp	6b
-#endif
-	.size	__pthread_cond_timedwait, .-__pthread_cond_timedwait
-versioned_symbol (libpthread, __pthread_cond_timedwait, pthread_cond_timedwait,
-		  GLIBC_2_3_2)
-
-
-	.align	16
-	.type	__condvar_cleanup2, @function
-__condvar_cleanup2:
-	/* Stack frame:
-
-	   rsp + 72
-		    +--------------------------+
-	   rsp + 64 | %r12                     |
-		    +--------------------------+
-	   rsp + 56 | %r13                     |
-		    +--------------------------+
-	   rsp + 48 | %r14                     |
-		    +--------------------------+
-	   rsp + 24 | unused                   |
-		    +--------------------------+
-	   rsp + 16 | mutex pointer            |
-		    +--------------------------+
-	   rsp +  8 | condvar pointer          |
-		    +--------------------------+
-	   rsp +  4 | old broadcast_seq value  |
-		    +--------------------------+
-	   rsp +  0 | old cancellation mode    |
-		    +--------------------------+
-	*/
-
-	movq	%rax, 24(%rsp)
-
-	/* Get internal lock.  */
-	movq	8(%rsp), %rdi
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jz	1f
-
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-#if cond_lock != 0
-	subq	$cond_lock, %rdi
-#endif
-
-1:	movl	broadcast_seq(%rdi), %edx
-	cmpl	4(%rsp), %edx
-	jne	3f
-
-	/* We increment the wakeup_seq counter only if it is lower than
-	   total_seq.  If this is not the case the thread was woken and
-	   then canceled.  In this case we ignore the signal.  */
-	movq	total_seq(%rdi), %rax
-	cmpq	wakeup_seq(%rdi), %rax
-	jbe	6f
-	incq	wakeup_seq(%rdi)
-	incl	cond_futex(%rdi)
-6:	incq	woken_seq(%rdi)
-
-3:	subl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
-
-	/* Wake up a thread which wants to destroy the condvar object.  */
-	xorq	%r12, %r12
-	cmpq	$0xffffffffffffffff, total_seq(%rdi)
-	jne	4f
-	movl	cond_nwaiters(%rdi), %eax
-	andl	$~((1 << nwaiters_shift) - 1), %eax
-	jne	4f
-
-	LP_OP(cmp) $-1, dep_mutex(%rdi)
-	leaq	cond_nwaiters(%rdi), %rdi
-	movl	$1, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE, %eax
-	movl	$(FUTEX_WAKE|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-#else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-	orl	$FUTEX_WAKE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-	subq	$cond_nwaiters, %rdi
-	movl	$1, %r12d
-
-4:	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	je	2f
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-
-	/* Wake up all waiters to make sure no signal gets lost.  */
-2:	testq	%r12, %r12
-	jnz	5f
-	addq	$cond_futex, %rdi
-	LP_OP(cmp) $-1, dep_mutex-cond_futex(%rdi)
-	movl	$0x7fffffff, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE, %eax
-	movl	$(FUTEX_WAKE|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-#else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-	orl	$FUTEX_WAKE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-
-	/* Lock the mutex only if we don't own it already.  This only happens
-	   in case of PI mutexes, if we got cancelled after a successful
-	   return of the futex syscall and before disabling async
-	   cancellation.  */
-5:	movq	16(%rsp), %rdi
-	movl	MUTEX_KIND(%rdi), %eax
-	andl	$(ROBUST_BIT|PI_BIT), %eax
-	cmpl	$PI_BIT, %eax
-	jne	7f
-
-	movl	(%rdi), %eax
-	andl	$TID_MASK, %eax
-	cmpl	%eax, %fs:TID
-	jne	7f
-	/* We managed to get the lock.  Fix it up before returning.  */
-	callq	__pthread_mutex_cond_lock_adjust
-	jmp	8f
-
-7:	callq	__pthread_mutex_cond_lock
-
-8:	movq	24(%rsp), %rdi
-	movq	FRAME_SIZE(%rsp), %r15
-	movq	FRAME_SIZE+8(%rsp), %r14
-	movq	FRAME_SIZE+16(%rsp), %r13
-	movq	FRAME_SIZE+24(%rsp), %r12
-.LcallUR:
-	call	_Unwind_Resume@PLT
-	hlt
-.LENDCODE:
-	cfi_endproc
-	.size	__condvar_cleanup2, .-__condvar_cleanup2
-
-
-	.section .gcc_except_table,"a",@progbits
-.LexceptSTART:
-	.byte	DW_EH_PE_omit			# @LPStart format
-	.byte	DW_EH_PE_omit			# @TType format
-	.byte	DW_EH_PE_uleb128		# call-site format
-	.uleb128 .Lcstend-.Lcstbegin
-.Lcstbegin:
-	.uleb128 .LcleanupSTART1-.LSTARTCODE
-	.uleb128 .LcleanupEND1-.LcleanupSTART1
-	.uleb128 __condvar_cleanup2-.LSTARTCODE
-	.uleb128  0
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	.uleb128 .LcleanupSTART2-.LSTARTCODE
-	.uleb128 .LcleanupEND2-.LcleanupSTART2
-	.uleb128 __condvar_cleanup2-.LSTARTCODE
-	.uleb128  0
-#endif
-	.uleb128 .LcallUR-.LSTARTCODE
-	.uleb128 .LENDCODE-.LcallUR
-	.uleb128 0
-	.uleb128  0
-.Lcstend:
-
-
-#ifdef SHARED
-	.hidden	DW.ref.__gcc_personality_v0
-	.weak	DW.ref.__gcc_personality_v0
-	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	LP_SIZE
-	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, LP_SIZE
-DW.ref.__gcc_personality_v0:
-	ASM_ADDR __gcc_personality_v0
-#endif
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,555 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <shlib-compat.h>
-#include <lowlevellock.h>
-#include <lowlevelcond.h>
-#include <tcb-offsets.h>
-#include <pthread-pi-defines.h>
-#include <pthread-errnos.h>
-#include <stap-probe.h>
-
-#include <kernel-features.h>
-
-
-	.text
-
-/* int pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex)  */
-	.globl	__pthread_cond_wait
-	.type	__pthread_cond_wait, @function
-	.align	16
-__pthread_cond_wait:
-.LSTARTCODE:
-	cfi_startproc
-#ifdef SHARED
-	cfi_personality(DW_EH_PE_pcrel | DW_EH_PE_sdata4 | DW_EH_PE_indirect,
-			DW.ref.__gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_pcrel | DW_EH_PE_sdata4, .LexceptSTART)
-#else
-	cfi_personality(DW_EH_PE_udata4, __gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_udata4, .LexceptSTART)
-#endif
-
-#define FRAME_SIZE (32+8)
-	leaq	-FRAME_SIZE(%rsp), %rsp
-	cfi_adjust_cfa_offset(FRAME_SIZE)
-
-	/* Stack frame:
-
-	   rsp + 32
-		    +--------------------------+
-	   rsp + 24 | old wake_seq value       |
-		    +--------------------------+
-	   rsp + 16 | mutex pointer            |
-		    +--------------------------+
-	   rsp +  8 | condvar pointer          |
-		    +--------------------------+
-	   rsp +  4 | old broadcast_seq value  |
-		    +--------------------------+
-	   rsp +  0 | old cancellation mode    |
-		    +--------------------------+
-	*/
-
-	LIBC_PROBE (cond_wait, 2, %rdi, %rsi)
-
-	LP_OP(cmp) $-1, dep_mutex(%rdi)
-
-	/* Prepare structure passed to cancellation handler.  */
-	movq	%rdi, 8(%rsp)
-	movq	%rsi, 16(%rsp)
-
-	je	15f
-	mov	%RSI_LP, dep_mutex(%rdi)
-
-	/* Get internal lock.  */
-15:	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jne	1f
-
-	/* Unlock the mutex.  */
-2:	movq	16(%rsp), %rdi
-	xorl	%esi, %esi
-	callq	__pthread_mutex_unlock_usercnt
-
-	testl	%eax, %eax
-	jne	12f
-
-	movq	8(%rsp), %rdi
-	incq	total_seq(%rdi)
-	incl	cond_futex(%rdi)
-	addl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
-
-	/* Get and store current wakeup_seq value.  */
-	movq	8(%rsp), %rdi
-	movq	wakeup_seq(%rdi), %r9
-	movl	broadcast_seq(%rdi), %edx
-	movq	%r9, 24(%rsp)
-	movl	%edx, 4(%rsp)
-
-	/* Unlock.  */
-8:	movl	cond_futex(%rdi), %edx
-	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	jne	3f
-
-.LcleanupSTART:
-4:	callq	__pthread_enable_asynccancel
-	movl	%eax, (%rsp)
-
-	xorq	%r10, %r10
-	LP_OP(cmp) $-1, dep_mutex(%rdi)
-	leaq	cond_futex(%rdi), %rdi
-	movl	$FUTEX_WAIT, %esi
-	je	60f
-
-	mov	dep_mutex-cond_futex(%rdi), %R8_LP
-	/* Requeue to a non-robust PI mutex if the PI bit is set and
-	the robust bit is not set.  */
-	movl	MUTEX_KIND(%r8), %eax
-	andl	$(ROBUST_BIT|PI_BIT), %eax
-	cmpl	$PI_BIT, %eax
-	jne	61f
-
-	movl	$(FUTEX_WAIT_REQUEUE_PI|FUTEX_PRIVATE_FLAG), %esi
-	movl	$SYS_futex, %eax
-	syscall
-
-	cmpl	$0, %eax
-	sete	%r8b
-
-#ifdef __ASSUME_REQUEUE_PI
-	jmp	62f
-#else
-	je	62f
-
-	/* When a futex syscall with FUTEX_WAIT_REQUEUE_PI returns
-	   successfully, it has already locked the mutex for us and the
-	   pi_flag (%r8b) is set to denote that fact.  However, if another
-	   thread changed the futex value before we entered the wait, the
-	   syscall may return an EAGAIN and the mutex is not locked.  We go
-	   ahead with a success anyway since later we look at the pi_flag to
-	   decide if we got the mutex or not.  The sequence numbers then make
-	   sure that only one of the threads actually wake up.  We retry using
-	   normal FUTEX_WAIT only if the kernel returned ENOSYS, since normal
-	   and PI futexes don't mix.
-
-	   Note that we don't check for EAGAIN specifically; we assume that the
-	   only other error the futex function could return is EAGAIN since
-	   anything else would mean an error in our function.  It is too
-	   expensive to do that check for every call (which is 	quite common in
-	   case of a large number of threads), so it has been skipped.  */
-	cmpl	$-ENOSYS, %eax
-	jne	62f
-
-# ifndef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAIT, %esi
-# endif
-#endif
-
-61:
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$(FUTEX_WAIT|FUTEX_PRIVATE_FLAG), %esi
-#else
-	orl	%fs:PRIVATE_FUTEX, %esi
-#endif
-60:	xorb	%r8b, %r8b
-	movl	$SYS_futex, %eax
-	syscall
-
-62:	movl	(%rsp), %edi
-	callq	__pthread_disable_asynccancel
-.LcleanupEND:
-
-	/* Lock.  */
-	movq	8(%rsp), %rdi
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jnz	5f
-
-6:	movl	broadcast_seq(%rdi), %edx
-
-	movq	woken_seq(%rdi), %rax
-
-	movq	wakeup_seq(%rdi), %r9
-
-	cmpl	4(%rsp), %edx
-	jne	16f
-
-	cmpq	24(%rsp), %r9
-	jbe	19f
-
-	cmpq	%rax, %r9
-	jna	19f
-
-	incq	woken_seq(%rdi)
-
-	/* Unlock */
-16:	subl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
-
-	/* Wake up a thread which wants to destroy the condvar object.  */
-	cmpq	$0xffffffffffffffff, total_seq(%rdi)
-	jne	17f
-	movl	cond_nwaiters(%rdi), %eax
-	andl	$~((1 << nwaiters_shift) - 1), %eax
-	jne	17f
-
-	addq	$cond_nwaiters, %rdi
-	LP_OP(cmp) $-1, dep_mutex-cond_nwaiters(%rdi)
-	movl	$1, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE, %eax
-	movl	$(FUTEX_WAKE|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-#else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-	orl	$FUTEX_WAKE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-	subq	$cond_nwaiters, %rdi
-
-17:	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	jne	10f
-
-	/* If requeue_pi is used the kernel performs the locking of the
-	   mutex. */
-11:	movq	16(%rsp), %rdi
-	testb	%r8b, %r8b
-	jnz	18f
-
-	callq	__pthread_mutex_cond_lock
-
-14:	leaq	FRAME_SIZE(%rsp), %rsp
-	cfi_adjust_cfa_offset(-FRAME_SIZE)
-
-	/* We return the result of the mutex_lock operation.  */
-	retq
-
-	cfi_adjust_cfa_offset(FRAME_SIZE)
-
-18:	callq	__pthread_mutex_cond_lock_adjust
-	xorl	%eax, %eax
-	jmp	14b
-
-	/* We need to go back to futex_wait.  If we're using requeue_pi, then
-	   release the mutex we had acquired and go back.  */
-19:	testb	%r8b, %r8b
-	jz	8b
-
-	/* Adjust the mutex values first and then unlock it.  The unlock
-	   should always succeed or else the kernel did not lock the mutex
-	   correctly.  */
-	movq	16(%rsp), %rdi
-	callq	__pthread_mutex_cond_lock_adjust
-	movq	%rdi, %r8
-	xorl	%esi, %esi
-	callq	__pthread_mutex_unlock_usercnt
-	/* Reload cond_var.  */
-	movq	8(%rsp), %rdi
-	jmp	8b
-
-	/* Initial locking failed.  */
-1:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-	jmp	2b
-
-	/* Unlock in loop requires wakeup.  */
-3:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	/* The call preserves %rdx.  */
-	callq	__lll_unlock_wake
-#if cond_lock != 0
-	subq	$cond_lock, %rdi
-#endif
-	jmp	4b
-
-	/* Locking in loop failed.  */
-5:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-#if cond_lock != 0
-	subq	$cond_lock, %rdi
-#endif
-	jmp	6b
-
-	/* Unlock after loop requires wakeup.  */
-10:
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-	jmp	11b
-
-	/* The initial unlocking of the mutex failed.  */
-12:	movq	%rax, %r10
-	movq	8(%rsp), %rdi
-	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	je	13f
-
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_unlock_wake
-
-13:	movq	%r10, %rax
-	jmp	14b
-
-	.size	__pthread_cond_wait, .-__pthread_cond_wait
-versioned_symbol (libpthread, __pthread_cond_wait, pthread_cond_wait,
-		  GLIBC_2_3_2)
-
-
-	.align	16
-	.type	__condvar_cleanup1, @function
-	.globl	__condvar_cleanup1
-	.hidden	__condvar_cleanup1
-__condvar_cleanup1:
-	/* Stack frame:
-
-	   rsp + 32
-		    +--------------------------+
-	   rsp + 24 | unused                   |
-		    +--------------------------+
-	   rsp + 16 | mutex pointer            |
-		    +--------------------------+
-	   rsp +  8 | condvar pointer          |
-		    +--------------------------+
-	   rsp +  4 | old broadcast_seq value  |
-		    +--------------------------+
-	   rsp +  0 | old cancellation mode    |
-		    +--------------------------+
-	*/
-
-	movq	%rax, 24(%rsp)
-
-	/* Get internal lock.  */
-	movq	8(%rsp), %rdi
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if cond_lock == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, cond_lock(%rdi)
-#endif
-	jz	1f
-
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	callq	__lll_lock_wait
-#if cond_lock != 0
-	subq	$cond_lock, %rdi
-#endif
-
-1:	movl	broadcast_seq(%rdi), %edx
-	cmpl	4(%rsp), %edx
-	jne	3f
-
-	/* We increment the wakeup_seq counter only if it is lower than
-	   total_seq.  If this is not the case the thread was woken and
-	   then canceled.  In this case we ignore the signal.  */
-	movq	total_seq(%rdi), %rax
-	cmpq	wakeup_seq(%rdi), %rax
-	jbe	6f
-	incq	wakeup_seq(%rdi)
-	incl	cond_futex(%rdi)
-6:	incq	woken_seq(%rdi)
-
-3:	subl	$(1 << nwaiters_shift), cond_nwaiters(%rdi)
-
-	/* Wake up a thread which wants to destroy the condvar object.  */
-	xorl	%ecx, %ecx
-	cmpq	$0xffffffffffffffff, total_seq(%rdi)
-	jne	4f
-	movl	cond_nwaiters(%rdi), %eax
-	andl	$~((1 << nwaiters_shift) - 1), %eax
-	jne	4f
-
-	LP_OP(cmp) $-1, dep_mutex(%rdi)
-	leaq	cond_nwaiters(%rdi), %rdi
-	movl	$1, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE, %eax
-	movl	$(FUTEX_WAKE|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-#else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-	orl	$FUTEX_WAKE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-	subq	$cond_nwaiters, %rdi
-	movl	$1, %ecx
-
-4:	LOCK
-#if cond_lock == 0
-	decl	(%rdi)
-#else
-	decl	cond_lock(%rdi)
-#endif
-	je	2f
-#if cond_lock != 0
-	addq	$cond_lock, %rdi
-#endif
-	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
-	movl	$LLL_PRIVATE, %eax
-	movl	$LLL_SHARED, %esi
-	cmovne	%eax, %esi
-	/* The call preserves %rcx.  */
-	callq	__lll_unlock_wake
-
-	/* Wake up all waiters to make sure no signal gets lost.  */
-2:	testl	%ecx, %ecx
-	jnz	5f
-	addq	$cond_futex, %rdi
-	LP_OP(cmp) $-1, dep_mutex-cond_futex(%rdi)
-	movl	$0x7fffffff, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE, %eax
-	movl	$(FUTEX_WAKE|FUTEX_PRIVATE_FLAG), %esi
-	cmove	%eax, %esi
-#else
-	movl	$0, %eax
-	movl	%fs:PRIVATE_FUTEX, %esi
-	cmove	%eax, %esi
-	orl	$FUTEX_WAKE, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-
-	/* Lock the mutex only if we don't own it already.  This only happens
-	   in case of PI mutexes, if we got cancelled after a successful
-	   return of the futex syscall and before disabling async
-	   cancellation.  */
-5:	movq	16(%rsp), %rdi
-	movl	MUTEX_KIND(%rdi), %eax
-	andl	$(ROBUST_BIT|PI_BIT), %eax
-	cmpl	$PI_BIT, %eax
-	jne	7f
-
-	movl	(%rdi), %eax
-	andl	$TID_MASK, %eax
-	cmpl	%eax, %fs:TID
-	jne	7f
-	/* We managed to get the lock.  Fix it up before returning.  */
-	callq	__pthread_mutex_cond_lock_adjust
-	jmp	8f
-
-
-7:	callq	__pthread_mutex_cond_lock
-
-8:	movq	24(%rsp), %rdi
-.LcallUR:
-	call	_Unwind_Resume@PLT
-	hlt
-.LENDCODE:
-	cfi_endproc
-	.size	__condvar_cleanup1, .-__condvar_cleanup1
-
-
-	.section .gcc_except_table,"a",@progbits
-.LexceptSTART:
-	.byte	DW_EH_PE_omit			# @LPStart format
-	.byte	DW_EH_PE_omit			# @TType format
-	.byte	DW_EH_PE_uleb128		# call-site format
-	.uleb128 .Lcstend-.Lcstbegin
-.Lcstbegin:
-	.uleb128 .LcleanupSTART-.LSTARTCODE
-	.uleb128 .LcleanupEND-.LcleanupSTART
-	.uleb128 __condvar_cleanup1-.LSTARTCODE
-	.uleb128 0
-	.uleb128 .LcallUR-.LSTARTCODE
-	.uleb128 .LENDCODE-.LcallUR
-	.uleb128 0
-	.uleb128 0
-.Lcstend:
-
-
-#ifdef SHARED
-	.hidden	DW.ref.__gcc_personality_v0
-	.weak	DW.ref.__gcc_personality_v0
-	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	LP_SIZE
-	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, LP_SIZE
-DW.ref.__gcc_personality_v0:
-	ASM_ADDR __gcc_personality_v0
-#endif
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,193 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <kernel-features.h>
-#include <tcb-offsets.h>
-#include <lowlevellock.h>
-
-
-	.comm	__fork_generation, 4, 4
-
-	.text
-
-
-	.globl	__pthread_once
-	.type	__pthread_once,@function
-	.align	16
-__pthread_once:
-.LSTARTCODE:
-	cfi_startproc
-#ifdef SHARED
-	cfi_personality(DW_EH_PE_pcrel | DW_EH_PE_sdata4 | DW_EH_PE_indirect,
-			DW.ref.__gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_pcrel | DW_EH_PE_sdata4, .LexceptSTART)
-#else
-	cfi_personality(DW_EH_PE_udata4, __gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_udata4, .LexceptSTART)
-#endif
-	testl	$2, (%rdi)
-	jz	1f
-	xorl	%eax, %eax
-	retq
-
-	/* Preserve the function pointer.  */
-1:	pushq	%rsi
-	cfi_adjust_cfa_offset(8)
-	xorq	%r10, %r10
-
-	/* Not yet initialized or initialization in progress.
-	   Get the fork generation counter now.  */
-6:	movl	(%rdi), %eax
-
-5:	movl	%eax, %edx
-
-	testl	$2, %eax
-	jnz	4f
-
-	andl	$3, %edx
-	orl	__fork_generation(%rip), %edx
-	orl	$1, %edx
-
-	LOCK
-	cmpxchgl %edx, (%rdi)
-	jnz	5b
-
-	/* Check whether another thread already runs the initializer.  */
-	testl	$1, %eax
-	jz	3f	/* No -> do it.  */
-
-	/* Check whether the initializer execution was interrupted
-	   by a fork.  */
-	xorl	%edx, %eax
-	testl	$0xfffffffc, %eax
-	jnz	3f	/* Different for generation -> run initializer.  */
-
-	/* Somebody else got here first.  Wait.  */
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAIT|FUTEX_PRIVATE_FLAG, %esi
-#else
-# if FUTEX_WAIT == 0
-	movl	%fs:PRIVATE_FUTEX, %esi
-# else
-	movl	$FUTEX_WAIT, %esi
-	orl	%fs:PRIVATE_FUTEX, %esi
-# endif
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-	jmp	6b
-
-	/* Preserve the pointer to the control variable.  */
-3:	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
-	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
-
-.LcleanupSTART:
-	callq	*16(%rsp)
-.LcleanupEND:
-
-	/* Get the control variable address back.  */
-	popq	%rdi
-	cfi_adjust_cfa_offset(-8)
-
-	/* Sucessful run of the initializer.  Signal that we are done.  */
-	LOCK
-	incl	(%rdi)
-
-	addq	$8, %rsp
-	cfi_adjust_cfa_offset(-8)
-
-	/* Wake up all other threads.  */
-	movl	$0x7fffffff, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE|FUTEX_PRIVATE_FLAG, %esi
-#else
-	movl	$FUTEX_WAKE, %esi
-	orl	%fs:PRIVATE_FUTEX, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-
-4:	addq	$8, %rsp
-	cfi_adjust_cfa_offset(-8)
-	xorl	%eax, %eax
-	retq
-	.size	__pthread_once,.-__pthread_once
-
-
-hidden_def (__pthread_once)
-strong_alias (__pthread_once, pthread_once)
-
-
-	.type	clear_once_control,@function
-	.align	16
-clear_once_control:
-	cfi_adjust_cfa_offset(3 * 8)
-	movq	(%rsp), %rdi
-	movq	%rax, %r8
-	movl	$0, (%rdi)
-
-	movl	$0x7fffffff, %edx
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_WAKE|FUTEX_PRIVATE_FLAG, %esi
-#else
-	movl	$FUTEX_WAKE, %esi
-	orl	%fs:PRIVATE_FUTEX, %esi
-#endif
-	movl	$SYS_futex, %eax
-	syscall
-
-	movq	%r8, %rdi
-.LcallUR:
-	call	_Unwind_Resume@PLT
-	hlt
-.LENDCODE:
-	cfi_endproc
-	.size	clear_once_control,.-clear_once_control
-
-
-	.section .gcc_except_table,"a",@progbits
-.LexceptSTART:
-	.byte	DW_EH_PE_omit			# @LPStart format
-	.byte	DW_EH_PE_omit			# @TType format
-	.byte	DW_EH_PE_uleb128		# call-site format
-	.uleb128 .Lcstend-.Lcstbegin
-.Lcstbegin:
-	.uleb128 .LcleanupSTART-.LSTARTCODE
-	.uleb128 .LcleanupEND-.LcleanupSTART
-	.uleb128 clear_once_control-.LSTARTCODE
-	.uleb128  0
-	.uleb128 .LcallUR-.LSTARTCODE
-	.uleb128 .LENDCODE-.LcallUR
-	.uleb128 0
-	.uleb128  0
-.Lcstend:
-
-
-#ifdef SHARED
-	.hidden	DW.ref.__gcc_personality_v0
-	.weak	DW.ref.__gcc_personality_v0
-	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	LP_SIZE
-	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, LP_SIZE
-DW.ref.__gcc_personality_v0:
-	ASM_ADDR __gcc_personality_v0
-#endif
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_rdlock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,177 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <lowlevelrwlock.h>
-#include <pthread-errnos.h>
-#include <kernel-features.h>
-#include <stap-probe.h>
-
-	.text
-
-	.globl	__pthread_rwlock_rdlock
-	.type	__pthread_rwlock_rdlock,@function
-	.align	16
-__pthread_rwlock_rdlock:
-	cfi_startproc
-
-	LIBC_PROBE (rdlock_entry, 1, %rdi)
-
-	xorq	%r10, %r10
-
-	/* Get the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, MUTEX(%rdi)
-#endif
-	jnz	1f
-
-2:	movl	WRITER(%rdi), %eax
-	testl	%eax, %eax
-	jne	14f
-	cmpl	$0, WRITERS_QUEUED(%rdi)
-	je	5f
-	cmpl	$0, FLAGS(%rdi)
-	je	5f
-
-3:	incl	READERS_QUEUED(%rdi)
-	je	4f
-
-	movl	READERS_WAKEUP(%rdi), %edx
-
-	LOCK
-#if MUTEX == 0
-	decl	(%rdi)
-#else
-	decl	MUTEX(%rdi)
-#endif
-	jne	10f
-
-11:
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_PRIVATE_FLAG|FUTEX_WAIT, %esi
-	xorl	PSHARED(%rdi), %esi
-#else
-# if FUTEX_WAIT == 0
-	movl	PSHARED(%rdi), %esi
-# else
-	movl	$FUTEX_WAIT, %esi
-	orl	PSHARED(%rdi), %esi
-# endif
-	xorl	%fs:PRIVATE_FUTEX, %esi
-#endif
-	addq	$READERS_WAKEUP, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-
-	subq	$READERS_WAKEUP, %rdi
-
-	/* Reget the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, MUTEX(%rdi)
-#endif
-	jnz	12f
-
-13:	decl	READERS_QUEUED(%rdi)
-	jmp	2b
-
-5:	xorl	%edx, %edx
-	incl	NR_READERS(%rdi)
-	je	8f
-9:	LOCK
-#if MUTEX == 0
-	decl	(%rdi)
-#else
-	decl	MUTEX(%rdi)
-#endif
-	jne	6f
-7:
-
-	movq	%rdx, %rax
-	retq
-
-1:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_lock_wait
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	2b
-
-14:	cmpl	%fs:TID, %eax
-	jne	3b
-	/* Deadlock detected.  */
-	movl	$EDEADLK, %edx
-	jmp	9b
-
-6:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_unlock_wake
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	7b
-
-	/* Overflow.  */
-8:	decl	NR_READERS(%rdi)
-	movl	$EAGAIN, %edx
-	jmp	9b
-
-	/* Overflow.  */
-4:	decl	READERS_QUEUED(%rdi)
-	movl	$EAGAIN, %edx
-	jmp	9b
-
-10:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_unlock_wake
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	11b
-
-12:	movl	PSHARED(%rdi), %esi
-#if MUTEX == 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_lock_wait
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	13b
-	cfi_endproc
-	.size	__pthread_rwlock_rdlock,.-__pthread_rwlock_rdlock
-
-strong_alias (__pthread_rwlock_rdlock, pthread_rwlock_rdlock)
-hidden_def (__pthread_rwlock_rdlock)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,274 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <lowlevelrwlock.h>
-#include <pthread-errnos.h>
-#include <kernel-features.h>
-
-	.text
-
-	.globl	pthread_rwlock_timedrdlock
-	.type	pthread_rwlock_timedrdlock,@function
-	.align	16
-pthread_rwlock_timedrdlock:
-	cfi_startproc
-	pushq	%r12
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r12, 0)
-	pushq	%r13
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r13, 0)
-#ifdef __ASSUME_FUTEX_CLOCK_REALTIME
-# define VALREG	%edx
-#else
-	pushq	%r14
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r14, 0)
-
-	subq	$16, %rsp
-	cfi_adjust_cfa_offset(16)
-# define VALREG %r14d
-#endif
-
-	movq	%rdi, %r12
-	movq	%rsi, %r13
-
-	/* Get the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, MUTEX(%rdi)
-#endif
-	jnz	1f
-
-2:	movl	WRITER(%r12), %eax
-	testl	%eax, %eax
-	jne	14f
-	cmpl	$0, WRITERS_QUEUED(%r12)
-	je	5f
-	cmpl	$0, FLAGS(%r12)
-	je	5f
-
-	/* Check the value of the timeout parameter.  */
-3:	cmpq	$1000000000, 8(%r13)
-	jae	19f
-
-	incl	READERS_QUEUED(%r12)
-	je	4f
-
-	movl	READERS_WAKEUP(%r12), VALREG
-
-	/* Unlock.  */
-	LOCK
-#if MUTEX == 0
-	decl	(%r12)
-#else
-	decl	MUTEX(%r12)
-#endif
-	jne	10f
-
-11:
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-#  ifdef PIC
-	cmpl	$0, __have_futex_clock_realtime(%rip)
-#  else
-	cmpl	$0, __have_futex_clock_realtime
-#  endif
-	je	.Lreltmo
-#endif
-
-	cmpq	$0, (%r13)
-	js	16f		/* Time is already up.  */
-
-	movl	$FUTEX_PRIVATE_FLAG|FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, %esi
-	xorl	PSHARED(%r12), %esi
-	movq	%r13, %r10
-	movl	$0xffffffff, %r9d
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	movl	%r14d, %edx
-#endif
-21:	leaq	READERS_WAKEUP(%r12), %rdi
-	movl	$SYS_futex, %eax
-	syscall
-	movq	%rax, %rdx
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	.subsection 2
-.Lreltmo:
-	/* Get current time.  */
-	movq	%rsp, %rdi
-	xorl	%esi, %esi
-	/* This call works because we directly jump to a system call entry
-	   which preserves all the registers.  */
-	call	JUMPTARGET(__gettimeofday)
-
-	/* Compute relative timeout.  */
-	movq	8(%rsp), %rax
-	movl	$1000, %edi
-	mul	%rdi		/* Milli seconds to nano seconds.  */
-	movq	(%r13), %rcx
-	movq	8(%r13), %rdi
-	subq	(%rsp), %rcx
-	subq	%rax, %rdi
-	jns	15f
-	addq	$1000000000, %rdi
-	decq	%rcx
-15:	testq	%rcx, %rcx
-	js	16f		/* Time is already up.  */
-
-	/* Futex call.  */
-	movq	%rcx, (%rsp)	/* Store relative timeout.  */
-	movq	%rdi, 8(%rsp)
-
-# ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_PRIVATE_FLAG|FUTEX_WAIT, %esi
-	xorl	PSHARED(%r12), %esi
-# else
-#  if FUTEX_WAIT == 0
-	movl	PSHARED(%r12), %esi
-#  else
-	movl	$FUTEX_WAIT, %esi
-	orl	PSHARED(%r12), %esi
-#  endif
-	xorl	%fs:PRIVATE_FUTEX, %esi
-# endif
-	movq	%rsp, %r10
-	movl	%r14d, %edx
-
-	jmp	21b
-	.previous
-#endif
-
-17:	/* Reget the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%r12)
-#else
-	cmpxchgl %esi, MUTEX(%r12)
-#endif
-	jnz	12f
-
-13:	decl	READERS_QUEUED(%r12)
-	cmpq	$-ETIMEDOUT, %rdx
-	jne	2b
-
-18:	movl	$ETIMEDOUT, %edx
-	jmp	9f
-
-
-5:	xorl	%edx, %edx
-	incl	NR_READERS(%r12)
-	je	8f
-9:	LOCK
-#if MUTEX == 0
-	decl	(%r12)
-#else
-	decl	MUTEX(%r12)
-#endif
-	jne	6f
-
-7:	movq	%rdx, %rax
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	addq	$16, %rsp
-	cfi_adjust_cfa_offset(-16)
-	popq	%r14
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r14)
-#endif
-	popq	%r13
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r13)
-	popq	%r12
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r12)
-	retq
-
-#ifdef __ASSUME_PRIVATE_FUTEX
-	cfi_adjust_cfa_offset(16)
-	cfi_rel_offset(%r12, 8)
-	cfi_rel_offset(%r13, 0)
-#else
-	cfi_adjust_cfa_offset(40)
-	cfi_offset(%r12, -16)
-	cfi_offset(%r13, -24)
-	cfi_offset(%r14, -32)
-#endif
-1:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_lock_wait
-	jmp	2b
-
-14:	cmpl	%fs:TID, %eax
-	jne	3b
-	movl	$EDEADLK, %edx
-	jmp	9b
-
-6:	movl	PSHARED(%r12), %esi
-#if MUTEX == 0
-	movq	%r12, %rdi
-#else
-	leal	MUTEX(%r12), %rdi
-#endif
-	callq	__lll_unlock_wake
-	jmp	7b
-
-	/* Overflow.  */
-8:	decl	NR_READERS(%r12)
-	movl	$EAGAIN, %edx
-	jmp	9b
-
-	/* Overflow.  */
-4:	decl	READERS_QUEUED(%r12)
-	movl	$EAGAIN, %edx
-	jmp	9b
-
-10:	movl	PSHARED(%r12), %esi
-#if MUTEX == 0
-	movq	%r12, %rdi
-#else
-	leaq	MUTEX(%r12), %rdi
-#endif
-	callq	__lll_unlock_wake
-	jmp	11b
-
-12:	movl	PSHARED(%r12), %esi
-#if MUTEX == 0
-	movq	%r12, %rdi
-#else
-	leaq	MUTEX(%r12), %rdi
-#endif
-	callq	__lll_lock_wait
-	jmp	13b
-
-16:	movq	$-ETIMEDOUT, %rdx
-	jmp	17b
-
-19:	movl	$EINVAL, %edx
-	jmp	9b
-	cfi_endproc
-	.size	pthread_rwlock_timedrdlock,.-pthread_rwlock_timedrdlock
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,266 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <lowlevelrwlock.h>
-#include <pthread-errnos.h>
-#include <kernel-features.h>
-
-	.text
-
-	.globl	pthread_rwlock_timedwrlock
-	.type	pthread_rwlock_timedwrlock,@function
-	.align	16
-pthread_rwlock_timedwrlock:
-	cfi_startproc
-	pushq	%r12
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r12, 0)
-	pushq	%r13
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r13, 0)
-#ifdef __ASSUME_FUTEX_CLOCK_REALTIME
-# define VALREG	%edx
-#else
-	pushq	%r14
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r14, 0)
-
-	subq	$16, %rsp
-	cfi_adjust_cfa_offset(16)
-# define VALREG %r14d
-#endif
-
-	movq	%rdi, %r12
-	movq	%rsi, %r13
-
-	/* Get the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, MUTEX(%rdi)
-#endif
-	jnz	1f
-
-2:	movl	WRITER(%r12), %eax
-	testl	%eax, %eax
-	jne	14f
-	cmpl	$0, NR_READERS(%r12)
-	je	5f
-
-	/* Check the value of the timeout parameter.  */
-3:	cmpq	$1000000000, 8(%r13)
-	jae	19f
-
-	incl	WRITERS_QUEUED(%r12)
-	je	4f
-
-	movl	WRITERS_WAKEUP(%r12), VALREG
-
-	LOCK
-#if MUTEX == 0
-	decl	(%r12)
-#else
-	decl	MUTEX(%r12)
-#endif
-	jne	10f
-
-11:
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-#  ifdef PIC
-	cmpl	$0, __have_futex_clock_realtime(%rip)
-#  else
-	cmpl	$0, __have_futex_clock_realtime
-#  endif
-	je	.Lreltmo
-#endif
-
-	cmpq	$0, (%r13)
-	js	16f		/* Time is already up. */
-
-	movl	$FUTEX_PRIVATE_FLAG|FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, %esi
-	xorl	PSHARED(%r12), %esi
-	movq	%r13, %r10
-	movl	$0xffffffff, %r9d
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	movl	%r14d, %edx
-#endif
-21:	leaq	WRITERS_WAKEUP(%r12), %rdi
-	movl	$SYS_futex, %eax
-	syscall
-	movq	%rax, %rdx
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	.subsection 2
-.Lreltmo:
-	/* Get current time.  */
-	movq	%rsp, %rdi
-	xorl	%esi, %esi
-	/* This call works because we directly jump to a system call entry
-	   which preserves all the registers.  */
-	call	JUMPTARGET(__gettimeofday)
-
-	/* Compute relative timeout.  */
-	movq	8(%rsp), %rax
-	movl	$1000, %edi
-	mul	%rdi		/* Milli seconds to nano seconds.  */
-	movq	(%r13), %rcx
-	movq	8(%r13), %rdi
-	subq	(%rsp), %rcx
-	subq	%rax, %rdi
-	jns	15f
-	addq	$1000000000, %rdi
-	decq	%rcx
-15:	testq	%rcx, %rcx
-	js	16f		/* Time is already up.  */
-
-	/* Futex call.  */
-	movq	%rcx, (%rsp)	/* Store relative timeout.  */
-	movq	%rdi, 8(%rsp)
-
-# ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_PRIVATE_FLAG|FUTEX_WAIT, %esi
-	xorl	PSHARED(%r12), %esi
-# else
-#  if FUTEX_WAIT == 0
-	movl	PSHARED(%r12), %esi
-#  else
-	movl	$FUTEX_WAIT, %esi
-	orl	PSHARED(%r12), %esi
-#  endif
-	xorl	%fs:PRIVATE_FUTEX, %esi
-# endif
-	movq	%rsp, %r10
-	movl	%r14d, %edx
-
-	jmp	21b
-	.previous
-#endif
-
-17:	/* Reget the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%r12)
-#else
-	cmpxchgl %esi, MUTEX(%r12)
-#endif
-	jnz	12f
-
-13:	decl	WRITERS_QUEUED(%r12)
-	cmpq	$-ETIMEDOUT, %rdx
-	jne	2b
-
-18:	movl	$ETIMEDOUT, %edx
-	jmp	9f
-
-
-5:	xorl	%edx, %edx
-	movl	%fs:TID, %eax
-	movl	%eax, WRITER(%r12)
-9:	LOCK
-#if MUTEX == 0
-	decl	(%r12)
-#else
-	decl	MUTEX(%r12)
-#endif
-	jne	6f
-
-7:	movq	%rdx, %rax
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	addq	$16, %rsp
-	cfi_adjust_cfa_offset(-16)
-	popq	%r14
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r14)
-#endif
-	popq	%r13
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r13)
-	popq	%r12
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r12)
-	retq
-
-#ifdef __ASSUME_PRIVATE_FUTEX
-	cfi_adjust_cfa_offset(16)
-	cfi_rel_offset(%r12, 8)
-	cfi_rel_offset(%r13, 0)
-#else
-	cfi_adjust_cfa_offset(40)
-	cfi_offset(%r12, -16)
-	cfi_offset(%r13, -24)
-	cfi_offset(%r14, -32)
-#endif
-1:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_lock_wait
-	jmp	2b
-
-14:	cmpl	%fs:TID, %eax
-	jne	3b
-20:	movl	$EDEADLK, %edx
-	jmp	9b
-
-6:	movl	PSHARED(%r12), %esi
-#if MUTEX == 0
-	movq	%r12, %rdi
-#else
-	leal	MUTEX(%r12), %rdi
-#endif
-	callq	__lll_unlock_wake
-	jmp	7b
-
-	/* Overflow.  */
-4:	decl	WRITERS_QUEUED(%r12)
-	movl	$EAGAIN, %edx
-	jmp	9b
-
-10:	movl	PSHARED(%r12), %esi
-#if MUTEX == 0
-	movq	%r12, %rdi
-#else
-	leaq	MUTEX(%r12), %rdi
-#endif
-	callq	__lll_unlock_wake
-	jmp	11b
-
-12:	movl	PSHARED(%r12), %esi
-#if MUTEX == 0
-	movq	%r12, %rdi
-#else
-	leaq	MUTEX(%r12), %rdi
-#endif
-	callq	__lll_lock_wait
-	jmp	13b
-
-16:	movq	$-ETIMEDOUT, %rdx
-	jmp	17b
-
-19:	movl	$EINVAL, %edx
-	jmp	9b
-	cfi_endproc
-	.size	pthread_rwlock_timedwrlock,.-pthread_rwlock_timedwrlock
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_unlock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,126 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <lowlevelrwlock.h>
-#include <kernel-features.h>
-
-
-	.text
-
-	.globl	__pthread_rwlock_unlock
-	.type	__pthread_rwlock_unlock,@function
-	.align	16
-__pthread_rwlock_unlock:
-	cfi_startproc
-	/* Get the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, MUTEX(%rdi)
-#endif
-	jnz	1f
-
-2:	cmpl	$0, WRITER(%rdi)
-	jne	5f
-	decl	NR_READERS(%rdi)
-	jnz	6f
-
-5:	movl	$0, WRITER(%rdi)
-
-	movl	$1, %edx
-	leaq	WRITERS_WAKEUP(%rdi), %r10
-	cmpl	$0, WRITERS_QUEUED(%rdi)
-	jne	0f
-
-	/* If also no readers waiting nothing to do.  */
-	cmpl	$0, READERS_QUEUED(%rdi)
-	je	6f
-
-	movl	$0x7fffffff, %edx
-	leaq	READERS_WAKEUP(%rdi), %r10
-
-0:	incl	(%r10)
-	LOCK
-#if MUTEX == 0
-	decl	(%rdi)
-#else
-	decl	MUTEX(%rdi)
-#endif
-	jne	7f
-
-8:
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_PRIVATE_FLAG|FUTEX_WAKE, %esi
-	xorl	PSHARED(%rdi), %esi
-#else
-	movl	$FUTEX_WAKE, %esi
-	orl	PSHARED(%rdi), %esi
-	xorl	%fs:PRIVATE_FUTEX, %esi
-#endif
-	movl	$SYS_futex, %eax
-	movq	%r10, %rdi
-	syscall
-
-	xorl	%eax, %eax
-	retq
-
-	.align	16
-6:	LOCK
-#if MUTEX == 0
-	decl	(%rdi)
-#else
-	decl	MUTEX(%rdi)
-#endif
-	jne	3f
-
-4:	xorl	%eax, %eax
-	retq
-
-1:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_lock_wait
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	2b
-
-3:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_unlock_wake
-	jmp	4b
-
-7:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_unlock_wake
-	jmp	8b
-	cfi_endproc
-	.size	__pthread_rwlock_unlock,.-__pthread_rwlock_unlock
-
-strong_alias (__pthread_rwlock_unlock, pthread_rwlock_unlock)
-hidden_def (__pthread_rwlock_unlock)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_wrlock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,165 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <lowlevelrwlock.h>
-#include <pthread-errnos.h>
-#include <kernel-features.h>
-#include <stap-probe.h>
-
-	.text
-
-	.globl	__pthread_rwlock_wrlock
-	.type	__pthread_rwlock_wrlock,@function
-	.align	16
-__pthread_rwlock_wrlock:
-	cfi_startproc
-
-	LIBC_PROBE (wrlock_entry, 1, %rdi)
-
-	xorq	%r10, %r10
-
-	/* Get the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, MUTEX(%rdi)
-#endif
-	jnz	1f
-
-2:	movl	WRITER(%rdi), %eax
-	testl	%eax, %eax
-	jne	14f
-	cmpl	$0, NR_READERS(%rdi)
-	je	5f
-
-3:	incl	WRITERS_QUEUED(%rdi)
-	je	4f
-
-	movl	WRITERS_WAKEUP(%rdi), %edx
-
-	LOCK
-#if MUTEX == 0
-	decl	(%rdi)
-#else
-	decl	MUTEX(%rdi)
-#endif
-	jne	10f
-
-11:
-#ifdef __ASSUME_PRIVATE_FUTEX
-	movl	$FUTEX_PRIVATE_FLAG|FUTEX_WAIT, %esi
-	xorl	PSHARED(%rdi), %esi
-#else
-# if FUTEX_WAIT == 0
-	movl	PSHARED(%rdi), %esi
-# else
-	movl	$FUTEX_WAIT, %esi
-	orl	PSHARED(%rdi), %esi
-# endif
-	xorl	%fs:PRIVATE_FUTEX, %esi
-#endif
-	addq	$WRITERS_WAKEUP, %rdi
-	movl	$SYS_futex, %eax
-	syscall
-
-	subq	$WRITERS_WAKEUP, %rdi
-
-	/* Reget the lock.  */
-	movl	$1, %esi
-	xorl	%eax, %eax
-	LOCK
-#if MUTEX == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, MUTEX(%rdi)
-#endif
-	jnz	12f
-
-13:	decl	WRITERS_QUEUED(%rdi)
-	jmp	2b
-
-5:	xorl	%edx, %edx
-	movl	%fs:TID, %eax
-	movl	%eax, WRITER(%rdi)
-9:	LOCK
-#if MUTEX == 0
-	decl	(%rdi)
-#else
-	decl	MUTEX(%rdi)
-#endif
-	jne	6f
-7:
-
-	movq	%rdx, %rax
-	retq
-
-1:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_lock_wait
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	2b
-
-14:	cmpl	%fs:TID, %eax
-	jne	3b
-	movl	$EDEADLK, %edx
-	jmp	9b
-
-6:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_unlock_wake
-	jmp	7b
-
-4:	decl	WRITERS_QUEUED(%rdi)
-	movl	$EAGAIN, %edx
-	jmp	9b
-
-10:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_unlock_wake
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	11b
-
-12:	movl	PSHARED(%rdi), %esi
-#if MUTEX != 0
-	addq	$MUTEX, %rdi
-#endif
-	callq	__lll_lock_wait
-#if MUTEX != 0
-	subq	$MUTEX, %rdi
-#endif
-	jmp	13b
-	cfi_endproc
-	.size	__pthread_rwlock_wrlock,.-__pthread_rwlock_wrlock
-
-strong_alias (__pthread_rwlock_wrlock, pthread_rwlock_wrlock)
-hidden_def (__pthread_rwlock_wrlock)
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_spin_unlock.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_spin_unlock.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_spin_unlock.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_spin_unlock.S	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-#include <nptl/sysdeps/x86_64/pthread_spin_unlock.S>
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,75 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <shlib-compat.h>
-#include <pthread-errnos.h>
-#include <structsem.h>
-
-
-	.text
-
-	.globl	sem_post
-	.type	sem_post,@function
-	.align	16
-sem_post:
-#if VALUE == 0
-	movl	(%rdi), %eax
-#else
-	movl	VALUE(%rdi), %eax
-#endif
-0:	cmpl	$SEM_VALUE_MAX, %eax
-	je	3f
-	leal	1(%rax), %esi
-	LOCK
-#if VALUE == 0
-	cmpxchgl %esi, (%rdi)
-#else
-	cmpxchgl %esi, VALUE(%rdi)
-#endif
-	jnz	0b
-
-	LP_OP(cmp) $0, NWAITERS(%rdi)
-	je	2f
-
-	movl	$SYS_futex, %eax
-	movl	$FUTEX_WAKE, %esi
-	orl	PRIVATE(%rdi), %esi
-	movl	$1, %edx
-	syscall
-
-	testq	%rax, %rax
-	js	1f
-
-2:	xorl	%eax, %eax
-	retq
-
-1:
-	movl	$EINVAL, %eax
-	jmp	4f
-
-3:
-	movl	$EOVERFLOW, %eax
-
-4:
-	movq	errno@gottpoff(%rip), %rdx
-	movl	%eax, %fs:(%rdx)
-	orl	$-1, %eax
-	retq
-	.size	sem_post,.-sem_post
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,380 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <kernel-features.h>
-#include <lowlevellock.h>
-#include <shlib-compat.h>
-#include <pthread-errnos.h>
-#include <structsem.h>
-
-	.text
-
-	.globl	sem_timedwait
-	.type	sem_timedwait,@function
-	.align	16
-sem_timedwait:
-.LSTARTCODE:
-	cfi_startproc
-#ifdef SHARED
-	cfi_personality(DW_EH_PE_pcrel | DW_EH_PE_sdata4 | DW_EH_PE_indirect,
-			DW.ref.__gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_pcrel | DW_EH_PE_sdata4, .LexceptSTART)
-#else
-	cfi_personality(DW_EH_PE_udata4, __gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_udata4, .LexceptSTART)
-#endif
-#if VALUE == 0
-	movl	(%rdi), %eax
-#else
-	movl	VALUE(%rdi), %eax
-#endif
-2:	testl	%eax, %eax
-	je	1f
-
-	leaq	-1(%rax), %rdx
-	LOCK
-#if VALUE == 0
-	cmpxchgl %edx, (%rdi)
-#else
-	cmpxchgl %edx, VALUE(%rdi)
-#endif
-	jne	2b
-
-	xorl	%eax, %eax
-	retq
-
-	/* Check whether the timeout value is valid.  */
-1:	cmpq	$1000000000, 8(%rsi)
-	jae	6f
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-#  ifdef PIC
-	cmpl	$0, __have_futex_clock_realtime(%rip)
-#  else
-	cmpl	$0, __have_futex_clock_realtime
-#  endif
-	je	.Lreltmo
-#endif
-
-	cmpq	$0, (%rsi)
-	js	16f
-
-	/* This push is only needed to store the sem_t pointer for the
-	   exception handler.  */
-	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
-
-	movq	%rsi, %r10
-
-	LOCK
-	LP_OP(add) $1, NWAITERS(%rdi)
-
-.LcleanupSTART:
-13:	call	__pthread_enable_asynccancel
-	movl	%eax, %r8d
-
-#if VALUE != 0
-	leaq	VALUE(%rdi), %rdi
-#endif
-	movl	$0xffffffff, %r9d
-	movl	$FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, %esi
-	orl	PRIVATE(%rdi), %esi
-	movl	$SYS_futex, %eax
-	xorl	%edx, %edx
-	syscall
-	movq	%rax, %r9
-#if VALUE != 0
-	leaq	-VALUE(%rdi), %rdi
-#endif
-
-	xchgq	%r8, %rdi
-	call	__pthread_disable_asynccancel
-.LcleanupEND:
-	movq	%r8, %rdi
-
-	testq	%r9, %r9
-	je	11f
-	cmpq	$-EWOULDBLOCK, %r9
-	jne	3f
-
-11:
-#if VALUE == 0
-	movl	(%rdi), %eax
-#else
-	movl	VALUE(%rdi), %eax
-#endif
-14:	testl	%eax, %eax
-	je	13b
-
-	leaq	-1(%rax), %rcx
-	LOCK
-#if VALUE == 0
-	cmpxchgl %ecx, (%rdi)
-#else
-	cmpxchgl %ecx, VALUE(%rdi)
-#endif
-	jne	14b
-
-	xorl	%eax, %eax
-
-15:	LOCK
-	LP_OP(sub) $1, NWAITERS(%rdi)
-
-	leaq	8(%rsp), %rsp
-	cfi_adjust_cfa_offset(-8)
-	retq
-
-	cfi_adjust_cfa_offset(8)
-3:	negq	%r9
-	movq	errno@gottpoff(%rip), %rdx
-	movl	%r9d, %fs:(%rdx)
-
-	orl	$-1, %eax
-	jmp	15b
-
-	cfi_adjust_cfa_offset(-8)
-6:
-	movq	errno@gottpoff(%rip), %rdx
-	movl	$EINVAL, %fs:(%rdx)
-
-	orl	$-1, %eax
-
-	retq
-
-16:
-	movq	errno@gottpoff(%rip), %rdx
-	movl	$ETIMEDOUT, %fs:(%rdx)
-
-	orl	$-1, %eax
-
-	retq
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-.Lreltmo:
-	pushq	%r12
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r12, 0)
-	pushq	%r13
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r13, 0)
-	pushq	%r14
-	cfi_adjust_cfa_offset(8)
-	cfi_rel_offset(%r14, 0)
-
-#ifdef __ASSUME_FUTEX_CLOCK_REALTIME
-# define STACKFRAME 8
-#else
-# define STACKFRAME 24
-#endif
-	subq	$STACKFRAME, %rsp
-	cfi_adjust_cfa_offset(STACKFRAME)
-
-	movq	%rdi, %r12
-	movq	%rsi, %r13
-
-	LOCK
-	LP_OP(add) $1, NWAITERS(%r12)
-
-7:	xorl	%esi, %esi
-	movq	%rsp,%rdi
-	/* This call works because we directly jump to a system call entry
-	   which preserves all the registers.  */
-	call	JUMPTARGET(__gettimeofday)
-
-	/* Compute relative timeout.  */
-	movq	8(%rsp), %rax
-	movl	$1000, %edi
-	mul	%rdi		/* Milli seconds to nano seconds.  */
-	movq	(%r13), %rdi
-	movq	8(%r13), %rsi
-	subq	(%rsp), %rdi
-	subq	%rax, %rsi
-	jns	5f
-	addq	$1000000000, %rsi
-	decq	%rdi
-5:	testq	%rdi, %rdi
-	movl	$ETIMEDOUT, %r14d
-	js	36f		/* Time is already up.  */
-
-	movq	%rdi, (%rsp)	/* Store relative timeout.  */
-	movq	%rsi, 8(%rsp)
-
-.LcleanupSTART2:
-	call	__pthread_enable_asynccancel
-	movl	%eax, 16(%rsp)
-
-	movq	%rsp, %r10
-# if VALUE == 0
-	movq	%r12, %rdi
-# else
-	leaq	VALUE(%r12), %rdi
-# endif
-# if FUTEX_WAIT == 0
-	movl	PRIVATE(%rdi), %esi
-# else
-	movl	$FUTEX_WAIT, %esi
-	orl	PRIVATE(%rdi), %esi
-# endif
-	movl	$SYS_futex, %eax
-	xorl	%edx, %edx
-	syscall
-	movq	%rax, %r14
-
-	movl	16(%rsp), %edi
-	call	__pthread_disable_asynccancel
-.LcleanupEND2:
-
-	testq	%r14, %r14
-	je	9f
-	cmpq	$-EWOULDBLOCK, %r14
-	jne	33f
-
-9:
-# if VALUE == 0
-	movl	(%r12), %eax
-# else
-	movl	VALUE(%r12), %eax
-# endif
-8:	testl	%eax, %eax
-	je	7b
-
-	leaq	-1(%rax), %rcx
-	LOCK
-# if VALUE == 0
-	cmpxchgl %ecx, (%r12)
-# else
-	cmpxchgl %ecx, VALUE(%r12)
-# endif
-	jne	8b
-
-	xorl	%eax, %eax
-
-45:	LOCK
-	LP_OP(sub) $1, NWAITERS(%r12)
-
-	addq	$STACKFRAME, %rsp
-	cfi_adjust_cfa_offset(-STACKFRAME)
-	popq	%r14
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r14)
-	popq	%r13
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r13)
-	popq	%r12
-	cfi_adjust_cfa_offset(-8)
-	cfi_restore(%r12)
-	retq
-
-	cfi_adjust_cfa_offset(STACKFRAME + 3 * 8)
-	cfi_rel_offset(%r12, STACKFRAME + 2 * 8)
-	cfi_rel_offset(%r13, STACKFRAME + 1 * 8)
-	cfi_rel_offset(%r14, STACKFRAME)
-33:	negq	%r14
-36:
-	movq	errno@gottpoff(%rip), %rdx
-	movl	%r14d, %fs:(%rdx)
-
-	orl	$-1, %eax
-	jmp	45b
-#endif
-	cfi_endproc
-	.size	sem_timedwait,.-sem_timedwait
-
-
-	.type	sem_timedwait_cleanup,@function
-sem_timedwait_cleanup:
-	cfi_startproc
-	cfi_adjust_cfa_offset(8)
-
-	movq	(%rsp), %rdi
-	LOCK
-	LP_OP(sub) $1, NWAITERS(%rdi)
-	movq	%rax, %rdi
-.LcallUR:
-	call	_Unwind_Resume@PLT
-	hlt
-.LENDCODE:
-	cfi_endproc
-	.size	sem_timedwait_cleanup,.-sem_timedwait_cleanup
-
-
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	.type	sem_timedwait_cleanup2,@function
-sem_timedwait_cleanup2:
-	cfi_startproc
-	cfi_adjust_cfa_offset(STACKFRAME + 3 * 8)
-	cfi_rel_offset(%r12, STACKFRAME + 2 * 8)
-	cfi_rel_offset(%r13, STACKFRAME + 1 * 8)
-	cfi_rel_offset(%r14, STACKFRAME)
-
-	LOCK
-	LP_OP(sub) $1, NWAITERS(%r12)
-	movq	%rax, %rdi
-	movq	STACKFRAME(%rsp), %r14
-	movq	STACKFRAME+8(%rsp), %r13
-	movq	STACKFRAME+16(%rsp), %r12
-.LcallUR2:
-	call	_Unwind_Resume@PLT
-	hlt
-.LENDCODE2:
-	cfi_endproc
-	.size	sem_timedwait_cleanup2,.-sem_timedwait_cleanup2
-#endif
-
-
-	.section .gcc_except_table,"a",@progbits
-.LexceptSTART:
-	.byte	DW_EH_PE_omit			# @LPStart format
-	.byte	DW_EH_PE_omit			# @TType format
-	.byte	DW_EH_PE_uleb128		# call-site format
-	.uleb128 .Lcstend-.Lcstbegin
-.Lcstbegin:
-	.uleb128 .LcleanupSTART-.LSTARTCODE
-	.uleb128 .LcleanupEND-.LcleanupSTART
-	.uleb128 sem_timedwait_cleanup-.LSTARTCODE
-	.uleb128  0
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	.uleb128 .LcleanupSTART2-.LSTARTCODE
-	.uleb128 .LcleanupEND2-.LcleanupSTART2
-	.uleb128 sem_timedwait_cleanup2-.LSTARTCODE
-	.uleb128  0
-#endif
-	.uleb128 .LcallUR-.LSTARTCODE
-	.uleb128 .LENDCODE-.LcallUR
-	.uleb128 0
-	.uleb128  0
-#ifndef __ASSUME_FUTEX_CLOCK_REALTIME
-	.uleb128 .LcallUR2-.LSTARTCODE
-	.uleb128 .LENDCODE2-.LcallUR2
-	.uleb128 0
-	.uleb128  0
-#endif
-.Lcstend:
-
-
-#ifdef SHARED
-	.hidden	DW.ref.__gcc_personality_v0
-	.weak	DW.ref.__gcc_personality_v0
-	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	LP_SIZE
-	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, LP_SIZE
-DW.ref.__gcc_personality_v0:
-	ASM_ADDR __gcc_personality_v0
-#endif
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_trywait.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_trywait.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_trywait.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_trywait.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,47 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <shlib-compat.h>
-#include <pthread-errnos.h>
-
-	.text
-
-	.globl	sem_trywait
-	.type	sem_trywait,@function
-	.align	16
-sem_trywait:
-	movl	(%rdi), %eax
-2:	testl	%eax, %eax
-	jz	1f
-
-	leal	-1(%rax), %edx
-	LOCK
-	cmpxchgl %edx, (%rdi)
-	jne	2b
-
-	xorl	%eax, %eax
-	retq
-
-1:
-	movq	errno@gottpoff(%rip), %rdx
-	movl	$EAGAIN, %fs:(%rdx)
-	orl	$-1, %eax
-	retq
-	.size	sem_trywait,.-sem_trywait
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S	1969-12-31 16:00:00.000000000 -0800
@@ -1,176 +0,0 @@
-/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, see
-   <http://www.gnu.org/licenses/>.  */
-
-#include <sysdep.h>
-#include <lowlevellock.h>
-#include <shlib-compat.h>
-#include <pthread-errnos.h>
-#include <structsem.h>
-
-
-	.text
-
-	.globl	sem_wait
-	.type	sem_wait,@function
-	.align	16
-sem_wait:
-.LSTARTCODE:
-	cfi_startproc
-#ifdef SHARED
-	cfi_personality(DW_EH_PE_pcrel | DW_EH_PE_sdata4 | DW_EH_PE_indirect,
-			DW.ref.__gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_pcrel | DW_EH_PE_sdata4, .LexceptSTART)
-#else
-	cfi_personality(DW_EH_PE_udata4, __gcc_personality_v0)
-	cfi_lsda(DW_EH_PE_udata4, .LexceptSTART)
-#endif
-
-#if VALUE == 0
-	movl	(%rdi), %eax
-#else
-	movl	VALUE(%rdi), %eax
-#endif
-2:	testl	%eax, %eax
-	je	1f
-
-	leal	-1(%rax), %edx
-	LOCK
-#if VALUE == 0
-	cmpxchgl %edx, (%rdi)
-#else
-	cmpxchgl %edx, VALUE(%rdi)
-#endif
-	jne	2b
-
-	xorl	%eax, %eax
-	retq
-
-	/* This push is only needed to store the sem_t pointer for the
-	   exception handler.  */
-1:	pushq	%rdi
-	cfi_adjust_cfa_offset(8)
-
-	LOCK
-	LP_OP(add) $1, NWAITERS(%rdi)
-
-.LcleanupSTART:
-6:	call	__pthread_enable_asynccancel
-	movl	%eax, %r8d
-
-	xorq	%r10, %r10
-	movl	$SYS_futex, %eax
-#if FUTEX_WAIT == 0
-	movl	PRIVATE(%rdi), %esi
-#else
-	movl	$FUTEX_WAIT, %esi
-	orl	PRIVATE(%rdi), %esi
-#endif
-	xorl	%edx, %edx
-	syscall
-	movq	%rax, %rcx
-
-	xchgq	%r8, %rdi
-	call	__pthread_disable_asynccancel
-.LcleanupEND:
-	movq	%r8, %rdi
-
-	testq	%rcx, %rcx
-	je	3f
-	cmpq	$-EWOULDBLOCK, %rcx
-	jne	4f
-
-3:
-#if VALUE == 0
-	movl	(%rdi), %eax
-#else
-	movl	VALUE(%rdi), %eax
-#endif
-5:	testl	%eax, %eax
-	je	6b
-
-	leal	-1(%rax), %edx
-	LOCK
-#if VALUE == 0
-	cmpxchgl %edx, (%rdi)
-#else
-	cmpxchgl %edx, VALUE(%rdi)
-#endif
-	jne	5b
-
-	xorl	%eax, %eax
-
-9:	LOCK
-	LP_OP(sub) $1, NWAITERS(%rdi)
-
-	leaq	8(%rsp), %rsp
-	cfi_adjust_cfa_offset(-8)
-
-	retq
-
-	cfi_adjust_cfa_offset(8)
-4:	negq	%rcx
-	movq	errno@gottpoff(%rip), %rdx
-	movl	%ecx, %fs:(%rdx)
-	orl	$-1, %eax
-
-	jmp 9b
-	.size	sem_wait,.-sem_wait
-
-
-	.type	sem_wait_cleanup,@function
-sem_wait_cleanup:
-	movq	(%rsp), %rdi
-	LOCK
-	LP_OP(sub) $1, NWAITERS(%rdi)
-	movq	%rax, %rdi
-.LcallUR:
-	call	_Unwind_Resume@PLT
-	hlt
-.LENDCODE:
-	cfi_endproc
-	.size	sem_wait_cleanup,.-sem_wait_cleanup
-
-
-	.section .gcc_except_table,"a",@progbits
-.LexceptSTART:
-	.byte	DW_EH_PE_omit			# @LPStart format
-	.byte	DW_EH_PE_omit			# @TType format
-	.byte	DW_EH_PE_uleb128		# call-site format
-	.uleb128 .Lcstend-.Lcstbegin
-.Lcstbegin:
-	.uleb128 .LcleanupSTART-.LSTARTCODE
-	.uleb128 .LcleanupEND-.LcleanupSTART
-	.uleb128 sem_wait_cleanup-.LSTARTCODE
-	.uleb128  0
-	.uleb128 .LcallUR-.LSTARTCODE
-	.uleb128 .LENDCODE-.LcallUR
-	.uleb128 0
-	.uleb128  0
-.Lcstend:
-
-
-#ifdef SHARED
-	.hidden	DW.ref.__gcc_personality_v0
-	.weak	DW.ref.__gcc_personality_v0
-	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	LP_SIZE
-	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, LP_SIZE
-DW.ref.__gcc_personality_v0:
-	ASM_ADDR __gcc_personality_v0
-#endif
diff -N -r --unified glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/timer_create.c glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/timer_create.c
--- glibc-2.19/nptl/sysdeps/unix/sysv/linux/x86_64/timer_create.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/sysdeps/unix/sysv/linux/x86_64/timer_create.c	2017-03-04 01:35:20.356744068 -0800
@@ -42,7 +42,7 @@
     {
       int i;
       for (i = 0; i < OLD_TIMER_MAX; ++i)
-	if (__compat_timer_list[i] == NULL
+	if (atomic_load(__compat_timer_list[i]) == NULL
 	    && ! atomic_compare_and_exchange_bool_acq (&__compat_timer_list[i],
 						       newp, NULL))
 	  {
diff -N -r --unified glibc-2.19/nptl/tpp.c glibc-2.19-totalpartial/nptl/tpp.c
--- glibc-2.19/nptl/tpp.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nptl/tpp.c	2017-03-04 01:35:20.356744068 -0800
@@ -33,7 +33,7 @@
 {
   __sched_fifo_max_prio = sched_get_priority_max (SCHED_FIFO);
   atomic_write_barrier ();
-  __sched_fifo_min_prio = sched_get_priority_min (SCHED_FIFO);
+  atomic_store(__sched_fifo_min_prio, sched_get_priority_min (SCHED_FIFO));
 }
 
 int
@@ -44,7 +44,7 @@
 
   if (tpp == NULL)
     {
-      if (__sched_fifo_min_prio == -1)
+      if (atomic_load(__sched_fifo_min_prio) == -1)
 	__init_sched_fifo_prio ();
 
       size_t size = sizeof *tpp;
@@ -100,7 +100,7 @@
 
   if ((self->flags & ATTR_FLAG_SCHED_SET) == 0)
     {
-      if (__sched_getparam (self->tid, &self->schedparam) != 0)
+      if (__sched_getparam (atomic_load(self->tid), &self->schedparam) != 0)
 	result = errno;
       else
 	self->flags |= ATTR_FLAG_SCHED_SET;
@@ -108,7 +108,7 @@
 
   if ((self->flags & ATTR_FLAG_POLICY_SET) == 0)
     {
-      self->schedpolicy = __sched_getscheduler (self->tid);
+      self->schedpolicy = __sched_getscheduler (atomic_load(self->tid));
       if (self->schedpolicy == -1)
 	result = errno;
       else
@@ -123,7 +123,7 @@
 	  if (sp.sched_priority < newpriomax)
 	    sp.sched_priority = newpriomax;
 
-	  if (__sched_setscheduler (self->tid, self->schedpolicy, &sp) < 0)
+	  if (__sched_setscheduler (atomic_load(self->tid), self->schedpolicy, &sp) < 0)
 	    result = errno;
 	}
     }
@@ -147,7 +147,7 @@
 
   if ((self->flags & ATTR_FLAG_SCHED_SET) == 0)
     {
-      if (__sched_getparam (self->tid, &self->schedparam) != 0)
+      if (__sched_getparam (atomic_load(self->tid), &self->schedparam) != 0)
 	result = -1;
       else
 	self->flags |= ATTR_FLAG_SCHED_SET;
@@ -155,7 +155,7 @@
 
   if ((self->flags & ATTR_FLAG_POLICY_SET) == 0)
     {
-      self->schedpolicy = __sched_getscheduler (self->tid);
+      self->schedpolicy = __sched_getscheduler (atomic_load(self->tid));
       if (self->schedpolicy == -1)
 	result = -1;
       else
diff -N -r --unified glibc-2.19/nss/getXXbyYY_r.c glibc-2.19-totalpartial/nss/getXXbyYY_r.c
--- glibc-2.19/nss/getXXbyYY_r.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/nss/getXXbyYY_r.c	2017-03-04 01:35:20.356744068 -0800
@@ -200,7 +200,7 @@
     }
 #endif
 
-  if (! startp_initialized)
+  if (! atomic_load(startp_initialized))
     {
       no_more = DB_LOOKUP_FCT (&nip, REENTRANT_NAME_STRING,
 			       REENTRANT2_NAME_STRING, &fct.ptr);
@@ -244,7 +244,7 @@
       /* Make sure start_fct and startp are written before
 	 startp_initialized.  */
       atomic_write_barrier ();
-      startp_initialized = true;
+      atomic_store(startp_initialized, true);
     }
   else
     {
diff -N -r --unified glibc-2.19/stdlib/cxa_atexit.c glibc-2.19-totalpartial/stdlib/cxa_atexit.c
--- glibc-2.19/stdlib/cxa_atexit.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/stdlib/cxa_atexit.c	2017-03-04 01:35:20.356744068 -0800
@@ -44,7 +44,7 @@
   new->func.cxa.arg = arg;
   new->func.cxa.dso_handle = d;
   atomic_write_barrier ();
-  new->flavor = ef_cxa;
+  atomic_store(new->flavor, ef_cxa);
   return 0;
 }
 
diff -N -r --unified glibc-2.19/stdlib/cxa_finalize.c glibc-2.19-totalpartial/stdlib/cxa_finalize.c
--- glibc-2.19/stdlib/cxa_finalize.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/stdlib/cxa_finalize.c	2017-03-04 01:35:20.357744068 -0800
@@ -32,7 +32,7 @@
   struct exit_function_list *funcs;
 
  restart:
-  for (funcs = __exit_funcs; funcs; funcs = funcs->next)
+  for (funcs = atomic_load(__exit_funcs); funcs; funcs = atomic_load(funcs->next))
     {
       struct exit_function *f;
 
@@ -41,10 +41,10 @@
 	  void (*cxafn) (void *arg, int status);
 	  void *cxaarg;
 
-	  if ((d == NULL || d == f->func.cxa.dso_handle)
+	  if ((d == NULL || d == atomic_load(f->func.cxa.dso_handle))
 	      /* We don't want to run this cleanup more than once.  */
-	      && (cxafn = f->func.cxa.fn,
-		  cxaarg = f->func.cxa.arg,
+	      && (cxafn = atomic_load(f->func.cxa.fn),
+		  cxaarg = atomic_load(f->func.cxa.arg),
 		  ! catomic_compare_and_exchange_bool_acq (&f->flavor, ef_free,
 							   ef_cxa)))
 	    {
@@ -64,13 +64,13 @@
     }
 
   /* Also remove the quick_exit handlers, but do not call them.  */
-  for (funcs = __quick_exit_funcs; funcs; funcs = funcs->next)
+  for (funcs = atomic_load(__quick_exit_funcs); funcs; funcs = atomic_load(funcs->next))
     {
       struct exit_function *f;
 
       for (f = &funcs->fns[funcs->idx - 1]; f >= &funcs->fns[0]; --f)
-	if (d == NULL || d == f->func.cxa.dso_handle)
-	  f->flavor = ef_free;
+	if (d == NULL || d == atomic_load(f->func.cxa.dso_handle))
+	  atomic_store(f->flavor, ef_free);
     }
 
   /* Remove the registered fork handlers.  We do not have to
diff -N -r --unified glibc-2.19/stdlib/msort.c glibc-2.19-totalpartial/stdlib/msort.c
--- glibc-2.19/stdlib/msort.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/stdlib/msort.c	2017-03-04 01:35:20.357744068 -0800
@@ -182,7 +182,7 @@
       static long int phys_pages;
       static int pagesize;
 
-      if (pagesize == 0)
+      if (atomic_load(pagesize) == 0)
 	{
 	  phys_pages = __sysconf (_SC_PHYS_PAGES);
 
@@ -200,7 +200,7 @@
 	  /* Make sure phys_pages is written to memory.  */
 	  atomic_write_barrier ();
 
-	  pagesize = __sysconf (_SC_PAGESIZE);
+	  atomic_store(pagesize, __sysconf (_SC_PAGESIZE));
 	}
 
       /* Just a comment here.  We cannot compute
diff -N -r --unified glibc-2.19/stdlib/on_exit.c glibc-2.19-totalpartial/stdlib/on_exit.c
--- glibc-2.19/stdlib/on_exit.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/stdlib/on_exit.c	2017-03-04 01:35:20.357744068 -0800
@@ -35,7 +35,7 @@
   new->func.on.fn = func;
   new->func.on.arg = arg;
   atomic_write_barrier ();
-  new->flavor = ef_on;
+  atomic_store(new->flavor, ef_on);
   return 0;
 }
 weak_alias (__on_exit, on_exit)
diff -N -r --unified glibc-2.19/sysdeps/unix/sysv/linux/check_pf.c glibc-2.19-totalpartial/sysdeps/unix/sysv/linux/check_pf.c
--- glibc-2.19/sysdeps/unix/sysv/linux/check_pf.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/sysdeps/unix/sysv/linux/check_pf.c	2017-03-04 01:35:20.357744068 -0800
@@ -75,7 +75,7 @@
   if (atomic_increment_val (&nl_timestamp) == 0)
     atomic_increment (&nl_timestamp);
 
-  return nl_timestamp;
+  return atomic_load(nl_timestamp);
 }
 #endif
 
@@ -364,7 +364,7 @@
       *in6ailen = data->in6ailen;
       *in6ai = data->in6ai;
 
-      if (olddata != NULL && olddata->usecnt > 0
+      if (atomic_load(olddata) != NULL && atomic_load(olddata->usecnt) > 0
 	  && atomic_add_zero (&olddata->usecnt, -1))
 	free (olddata);
 
diff -N -r --unified glibc-2.19/sysdeps/unix/sysv/linux/getsysstats.c glibc-2.19-totalpartial/sysdeps/unix/sysv/linux/getsysstats.c
--- glibc-2.19/sysdeps/unix/sysv/linux/getsysstats.c	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/sysdeps/unix/sysv/linux/getsysstats.c	2017-03-04 01:35:20.357744068 -0800
@@ -130,7 +130,7 @@
   static time_t timestamp;
 
   time_t now = time (NULL);
-  time_t prev = timestamp;
+  time_t prev = atomic_load(timestamp);
   atomic_read_barrier ();
   if (now == prev)
     return cached_result;
@@ -224,7 +224,7 @@
  out:
   cached_result = result;
   atomic_write_barrier ();
-  timestamp = now;
+  atomic_store(timestamp, now);
 
   return result;
 }
diff -N -r --unified glibc-2.19/sysdeps/unix/sysv/linux/malloc-sysdep.h glibc-2.19-totalpartial/sysdeps/unix/sysv/linux/malloc-sysdep.h
--- glibc-2.19/sysdeps/unix/sysv/linux/malloc-sysdep.h	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/sysdeps/unix/sysv/linux/malloc-sysdep.h	2017-03-04 01:35:20.357744068 -0800
@@ -34,13 +34,14 @@
 check_may_shrink_heap (void)
 {
   static int may_shrink_heap = -1;
+  int tmp_shrink_heap = atomic_load(may_shrink_heap);
 
-  if (__builtin_expect (may_shrink_heap >= 0, 1))
-    return may_shrink_heap;
+  if (__builtin_expect (tmp_shrink_heap >= 0, 1))
+    return tmp_shrink_heap;
 
-  may_shrink_heap = __libc_enable_secure;
+  atomic_store(may_shrink_heap, __libc_enable_secure);
 
-  if (__builtin_expect (may_shrink_heap == 0, 1))
+  if (__builtin_expect (atomic_load(may_shrink_heap) == 0, 1))
     {
       int fd = open_not_cancel_2 ("/proc/sys/vm/overcommit_memory",
 				  O_RDONLY | O_CLOEXEC);
@@ -48,12 +49,12 @@
 	{
 	  char val;
 	  ssize_t n = read_not_cancel (fd, &val, 1);
-	  may_shrink_heap = n > 0 && val == '2';
+	  atomic_store(may_shrink_heap, n > 0 && val == '2');
 	  close_not_cancel_no_status (fd);
 	}
     }
 
-  return may_shrink_heap;
+  return atomic_load(may_shrink_heap);
 }
 
 #define HAVE_MREMAP 1
diff -N -r --unified glibc-2.19/sysdeps/x86_64/bits/atomic.h glibc-2.19-totalpartial/sysdeps/x86_64/bits/atomic.h
--- glibc-2.19/sysdeps/x86_64/bits/atomic.h	2014-02-07 01:04:38.000000000 -0800
+++ glibc-2.19-totalpartial/sysdeps/x86_64/bits/atomic.h	2017-03-15 16:59:41.835389540 -0700
@@ -55,10 +55,71 @@
 # endif
 #endif
 
+#define orig_catomic_max(mem, value)					\
+  do {									\
+    __typeof (*(mem)) __atg9_oldv;					\
+    __typeof (mem) __atg9_memp = (mem);					\
+    __typeof (*(mem)) __atg9_value = (value);				\
+    do {								\
+      __atg9_oldv = *(volatile __typeof (mem))__atg9_memp;		\
+      if (__atg9_oldv >= __atg9_value)					\
+	break;								\
+    } while (__builtin_expect						\
+	     (orig_catomic_compare_and_exchange_bool_acq (__atg9_memp,	\
+							  __atg9_value,	\
+							  __atg9_oldv), 0)); \
+  } while (0)
+
+// overrides from include/atomic.h
+#define orig_catomic_compare_and_exchange_val_acq(mem, newval, oldval)	\
+  __atomic_val_bysize (__arch_c_compare_and_exchange_val,acq,		\
+		       mem, newval, oldval)
+
+#define orig_catomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+  ({ __typeof (oldval) __atg3_old = (oldval);				\
+    orig_catomic_compare_and_exchange_val_acq (mem, newval, __atg3_old) \
+      != __atg3_old;							\
+  })
+
+#define orig_atomic_forced_read(x) \
+  ({ __typeof (x) __x; __asm ("" : "=r" (__x) : "0" (x)); __x; })
+
+// MVEE additions
+#define orig_atomic_max(mem, value)					\
+  do {									\
+    __typeof (*(mem)) __atg8_oldval;					\
+    __typeof (mem) __atg8_memp = (mem);					\
+    __typeof (*(mem)) __atg8_value = (value);				\
+    do {								\
+      __atg8_oldval = *(volatile __typeof (mem))__atg8_memp;		\
+      if (__atg8_oldval >= __atg8_value)				\
+	break;								\
+    } while (__builtin_expect						\
+	     (orig_atomic_compare_and_exchange_bool_acq (__atg8_memp, __atg8_value, \
+							 __atg8_oldval), 0)); \
+  } while (0)
+
+#define orig_atomic_decrement_if_positive(mem)				\
+  ({ __typeof (*(mem)) __atg11_oldval;					\
+    __typeof (mem) __atg11_memp = (mem);				\
+									\
+    do									\
+      {									\
+	__atg11_oldval = *(volatile __typeof (mem))__atg11_memp;	\
+	if (__builtin_expect (__atg11_oldval <= 0, 0))			\
+	  break;							\
+      }									\
+    while (__builtin_expect						\
+	   (orig_atomic_compare_and_exchange_bool_acq (__atg11_memp,	\
+						       __atg11_oldval - 1, \
+						       __atg11_oldval), 0)); \
+    __atg11_oldval; })
+
 
-#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+// original sysdeps atomics
+#define orig_atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
   __sync_val_compare_and_swap (mem, oldval, newval)
-#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
+#define orig_atomic_compare_and_exchange_bool_acq(mem, newval, oldval) \
   (! __sync_bool_compare_and_swap (mem, oldval, newval))
 
 
@@ -110,7 +171,7 @@
 
 
 /* Note that we need no lock prefix.  */
-#define atomic_exchange_acq(mem, newvalue) \
+#define orig_atomic_exchange_acq(mem, newvalue) \
   ({ __typeof (*mem) result;						      \
      if (sizeof (*mem) == 1)						      \
        __asm __volatile ("xchgb %b0, %1"				      \
@@ -132,7 +193,7 @@
      result; })
 
 
-#define __arch_exchange_and_add_body(lock, mem, value)			      \
+#define __arch_exchange_and_add_body(lock, mem, value)			\
   ({ __typeof (*mem) result;						      \
      if (sizeof (*mem) == 1)						      \
        __asm __volatile (lock "xaddb %b0, %1"				      \
@@ -157,13 +218,13 @@
 			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
      result; })
 
-#define atomic_exchange_and_add(mem, value) \
+#define orig_atomic_exchange_and_add(mem, value) \
   __sync_fetch_and_add (mem, value)
 
 #define __arch_exchange_and_add_cprefix \
   "cmpl $0, %%fs:%P4\n\tje 0f\n\tlock\n0:\t"
 
-#define catomic_exchange_and_add(mem, value) \
+#define orig_catomic_exchange_and_add(mem, value) \
   __arch_exchange_and_add_body (__arch_exchange_and_add_cprefix, mem, value)
 
 
@@ -196,17 +257,17 @@
 			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
   } while (0)
 
-#define atomic_add(mem, value) \
-  __arch_add_body (LOCK_PREFIX, atomic, mem, value)
+#define orig_atomic_add(mem, value) \
+  ({__arch_add_body (LOCK_PREFIX, atomic, mem, value);})
 
 #define __arch_add_cprefix \
   "cmpl $0, %%fs:%P3\n\tje 0f\n\tlock\n0:\t"
 
-#define catomic_add(mem, value) \
-  __arch_add_body (__arch_add_cprefix, catomic, mem, value)
+#define orig_catomic_add(mem, value) \
+  ({__arch_add_body (__arch_add_cprefix, catomic, mem, value);})
 
 
-#define atomic_add_negative(mem, value) \
+#define orig_atomic_add_negative(mem, value) \
   ({ unsigned char __result;						      \
      if (sizeof (*mem) == 1)						      \
        __asm __volatile (LOCK_PREFIX "addb %b2, %0; sets %1"		      \
@@ -228,7 +289,7 @@
      __result; })
 
 
-#define atomic_add_zero(mem, value) \
+#define orig_atomic_add_zero(mem, value) \
   ({ unsigned char __result;						      \
      if (sizeof (*mem) == 1)						      \
        __asm __volatile (LOCK_PREFIX "addb %b2, %0; setz %1"		      \
@@ -274,16 +335,17 @@
 			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
   } while (0)
 
-#define atomic_increment(mem) __arch_increment_body (LOCK_PREFIX, mem)
+#define orig_atomic_increment(mem) ({__arch_increment_body (LOCK_PREFIX, mem);})
+#define orig_nonatomic_increment(mem) ({__arch_increment_body ("", mem);})
 
 #define __arch_increment_cprefix \
   "cmpl $0, %%fs:%P2\n\tje 0f\n\tlock\n0:\t"
 
-#define catomic_increment(mem) \
-  __arch_increment_body (__arch_increment_cprefix, mem)
+#define orig_catomic_increment(mem) \
+  ({__arch_increment_body (__arch_increment_cprefix, mem);})
 
 
-#define atomic_increment_and_test(mem) \
+#define orig_atomic_increment_and_test(mem) \
   ({ unsigned char __result;						      \
      if (sizeof (*mem) == 1)						      \
        __asm __volatile (LOCK_PREFIX "incb %b0; sete %1"		      \
@@ -328,16 +390,16 @@
 			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
   } while (0)
 
-#define atomic_decrement(mem) __arch_decrement_body (LOCK_PREFIX, mem)
+#define orig_atomic_decrement(mem) ({__arch_decrement_body (LOCK_PREFIX, mem);})
 
 #define __arch_decrement_cprefix \
   "cmpl $0, %%fs:%P2\n\tje 0f\n\tlock\n0:\t"
 
-#define catomic_decrement(mem) \
-  __arch_decrement_body (__arch_decrement_cprefix, mem)
+#define orig_catomic_decrement(mem) \
+    ({__arch_decrement_body (__arch_decrement_cprefix, mem);})
 
 
-#define atomic_decrement_and_test(mem) \
+#define orig_atomic_decrement_and_test(mem) \
   ({ unsigned char __result;						      \
      if (sizeof (*mem) == 1)						      \
        __asm __volatile (LOCK_PREFIX "decb %b0; sete %1"		      \
@@ -358,7 +420,7 @@
      __result; })
 
 
-#define atomic_bit_set(mem, bit) \
+#define orig_atomic_bit_set(mem, bit) \
   do {									      \
     if (sizeof (*mem) == 1)						      \
       __asm __volatile (LOCK_PREFIX "orb %b2, %0"			      \
@@ -383,7 +445,7 @@
   } while (0)
 
 
-#define atomic_bit_test_set(mem, bit) \
+#define orig_atomic_bit_test_set(mem, bit) \
   ({ unsigned char __result;						      \
      if (sizeof (*mem) == 1)						      \
        __asm __volatile (LOCK_PREFIX "btsb %3, %1; setc %0"		      \
@@ -434,9 +496,9 @@
 #define __arch_cprefix \
   "cmpl $0, %%fs:%P3\n\tje 0f\n\tlock\n0:\t"
 
-#define atomic_and(mem, mask) __arch_and_body (LOCK_PREFIX, mem, mask)
+#define orig_atomic_and(mem, mask) ({__arch_and_body (LOCK_PREFIX, mem, mask);})
 
-#define catomic_and(mem, mask) __arch_and_body (__arch_cprefix, mem, mask)
+#define orig_catomic_and(mem, mask) ({__arch_and_body (__arch_cprefix, mem, mask);})
 
 
 #define __arch_or_body(lock, mem, mask)					      \
@@ -463,6 +525,581 @@
 			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
   } while (0)
 
-#define atomic_or(mem, mask) __arch_or_body (LOCK_PREFIX, mem, mask)
+#define orig_atomic_or(mem, mask) ({__arch_or_body (LOCK_PREFIX, mem, mask);})
+
+#define orig_catomic_or(mem, mask) ({__arch_or_body (__arch_cprefix, mem, mask);})
+
+/*--------------------------------------------------------------------------------
+                                  MVEE PATCHES
+--------------------------------------------------------------------------------*/
+#define USE_MVEE_LIBC
+//
+// MVEE_PARTIAL_ORDER_REPLICATION: when defined, slaves will use
+// queue projection to replay synchronization operations in
+// partial order rather than total order. In other words,
+// the slaves will only respect the order in which the master
+// has performed its synchronization operations on a per-word
+// basis
+//
+#define MVEE_PARTIAL_ORDER_REPLICATION
+//
+// MVEE_EXTENDED_QUEUE: when defined, the locking operation and
+// mutex pointer are also logged in the queue.
+//
+// #define MVEE_EXTENDED_QUEUE
+//
+// MVEE_LOG_EIPS: when defined, libc logs return addresses for
+// all locking operations into a seperate queue
+//
+// WARNING: enabling EIP logging _CAN_ trigger crashes! We're
+// using __builtin_return_address(2) to fetch the eip of the 
+// caller of the locking function. Unfortunately, libc uses inline
+// __libc_lock_* operations every now and then. When it does, 
+// the __builtin_... call will return the wrong caller and in some
+// cases (e.g. in do_system) it might try to fetch the eip beyond
+// the end of the stack!
+//
+// #define MVEE_LOG_EIPS
+#define MVEE_STACK_DEPTH 5
+//
+// MVEE_CHECK_LOCK_TYPE: if this is defined, the slave will check
+// whether or not it's replaying a lock of the same type
+// (only works with the extended queue)
+//
+// #define MVEE_CHECK_LOCK_TYPE
+//
+// MVEE_DEBUG_MALLOC: if this is defined, the slaves will check whether
+// their malloc behavior is synced with the master
+//
+// #define MVEE_DEBUG_MALLOC
+//
+// MVEE_MALLOC_IGNORE_ASLR: if this is defined, the malloc debugger will
+// only compare allocation types, messages and chunk sizes
+// arena and chunk pointers are ignored.
+// #define MVEE_MALLOC_IGNORE_ASLR
+
+#ifdef USE_MVEE_LIBC
+#define MVEE_FAKE_SYSCALL_BASE          0x6FFFFFFF
+#define MVEE_GET_MASTERTHREAD_ID        MVEE_FAKE_SYSCALL_BASE + 3
+#define MVEE_GET_SHARED_BUFFER          MVEE_FAKE_SYSCALL_BASE + 4
+#define MVEE_FLUSH_SHARED_BUFFER        MVEE_FAKE_SYSCALL_BASE + 5
+#define MVEE_SET_INFINITE_LOOP_PTR      MVEE_FAKE_SYSCALL_BASE + 6
+#define MVEE_TOGGLESYNC                 MVEE_FAKE_SYSCALL_BASE + 7
+#define MVEE_SET_SHARED_BUFFER_POS_PTR  MVEE_FAKE_SYSCALL_BASE + 8
+#define MVEE_RUNS_UNDER_MVEE_CONTROL    MVEE_FAKE_SYSCALL_BASE + 9
+#define MVEE_GET_THREAD_NUM             MVEE_FAKE_SYSCALL_BASE + 10
+#define MVEE_SET_SYNC_PRIMITIVES_PTR    MVEE_FAKE_SYSCALL_BASE + 12
+#define MVEE_ALL_HEAPS_ALIGNED          MVEE_FAKE_SYSCALL_BASE + 13
+#define MVEE_LIBC_LOCK_BUFFER           3
+#define MVEE_LIBC_MALLOC_DEBUG_BUFFER   11
+#define MVEE_LIBC_LOCK_BUFFER_PARTIAL   16
+#define MVEE_FUTEX_WAIT_TID             30
+
+enum mvee_alloc_types
+  {
+  LIBC_MALLOC,
+  LIBC_FREE,
+  LIBC_REALLOC,
+  LIBC_MEMALIGN,
+  LIBC_CALLOC,
+  MALLOC_TRIM,
+  HEAP_TRIM,
+  MALLOC_CONSOLIDATE,
+  ARENA_GET2,
+  _INT_MALLOC,
+  _INT_FREE,
+  _INT_REALLOC
+  };
+
+enum mvee_base_atomics
+  {
+    // LOAD OPERATIONS FIRST!!! DO NOT CHANGE THIS CONVENTION
+    ATOMIC_FORCED_READ,
+    ATOMIC_LOAD,
+    // THE FOLLOWING IS NOT AN ACTUAL ATOMIC OPERATION, IT JUST DENOTES THE END OF THE LOAD-ONLY ATOMICS!!!
+    ATOMIC_LOAD_MAX,
+    // STORES AFTER LOADS
+    CATOMIC_COMPARE_AND_EXCHANGE_VAL_ACQ,
+    CATOMIC_COMPARE_AND_EXCHANGE_BOOL_ACQ,
+    CATOMIC_AND,
+    CATOMIC_OR,
+    CATOMIC_EXCHANGE_AND_ADD,
+    CATOMIC_ADD,
+    CATOMIC_INCREMENT,
+    CATOMIC_DECREMENT,
+    CATOMIC_MAX,
+    ATOMIC_COMPARE_AND_EXCHANGE_VAL_ACQ,
+    ATOMIC_COMPARE_AND_EXCHANGE_BOOL_ACQ,
+    ATOMIC_EXCHANGE_ACQ,
+    ATOMIC_EXCHANGE_AND_ADD,
+    ATOMIC_INCREMENT_AND_TEST,
+    ATOMIC_DECREMENT_AND_TEST,
+    ATOMIC_ADD_ZERO,
+    ATOMIC_ADD,
+    ATOMIC_INCREMENT,
+    ATOMIC_DECREMENT,
+    ATOMIC_BIT_TEST_SET,
+    ATOMIC_BIT_SET,
+    ATOMIC_AND,
+    ATOMIC_STORE,
+    ATOMIC_MAX,
+    ATOMIC_DECREMENT_IF_POSITIVE,
+    __THREAD_ATOMIC_CMPXCHG_VAL,
+    __THREAD_ATOMIC_AND,
+    __THREAD_ATOMIC_BIT_SET,
+    ___UNKNOWN_LOCK_TYPE___,
+    __MVEE_BASE_ATOMICS_MAX__
+  };
+
+enum mvee_extended_atomics {
+  mvee_atomic_load_n,
+  mvee_atomic_load,
+  mvee_atomic_store_n,
+  mvee_atomic_store,
+  mvee_atomic_exchange_n,
+  mvee_atomic_exchange,
+  mvee_atomic_compare_exchange_n,
+  mvee_atomic_compare_exchange,
+  mvee_atomic_add_fetch,
+  mvee_atomic_sub_fetch,
+  mvee_atomic_and_fetch,
+  mvee_atomic_xor_fetch,
+  mvee_atomic_or_fetch,
+  mvee_atomic_nand_fetch,
+  mvee_atomic_fetch_add,
+  mvee_atomic_fetch_sub,
+  mvee_atomic_fetch_and,
+  mvee_atomic_fetch_xor,
+  mvee_atomic_fetch_or,
+  mvee_atomic_fetch_nand,
+  mvee_atomic_test_and_set,
+  mvee_atomic_clear,
+  mvee_atomic_always_lock_free,
+  mvee_atomic_is_lock_free,
+  mvee_sync_fetch_and_add,
+  mvee_sync_fetch_and_sub,
+  mvee_sync_fetch_and_or,
+  mvee_sync_fetch_and_and,
+  mvee_sync_fetch_and_xor,
+  mvee_sync_fetch_and_nand,
+  mvee_sync_add_and_fetch,
+  mvee_sync_sub_and_fetch,
+  mvee_sync_or_and_fetch,
+  mvee_sync_and_and_fetch,
+  mvee_sync_xor_and_fetch,
+  mvee_sync_nand_and_fetch,
+  mvee_sync_bool_compare_and_swap,
+  mvee_sync_val_compare_and_swap,
+  mvee_sync_lock_test_and_set,
+  mvee_sync_lock_release,
+  mvee_atomic_ops_max
+};
+
+#define DEFINE_MVEE_QUEUE(name, has_eip_queue)				\
+  static unsigned long             mvee_##name##_buffer_data_start  = 0; \
+  static volatile unsigned int*    mvee_##name##_buffer_pos         = 0; \
+  static volatile unsigned int*    mvee_##name##_buffer_lock        = 0; \
+  static volatile unsigned int*    mvee_##name##_buffer_flush_cnt   = 0; \
+  static volatile unsigned char*   mvee_##name##_buffer_flushing    = 0; \
+  static unsigned long             mvee_##name##_buffer_slots       = 0; \
+  static void*                     mvee_##name##_eip_buffer         = NULL; \
+  static unsigned char             mvee_##name##_buffer_log_eips    = has_eip_queue;
+
+#define MVEE_ROUND_UP(x, multiple)		\
+  ((x + (multiple - 1)) & ~(multiple -1))
+
+#define MVEE_MIN(a, b) ((a > b) ? (b) : (a))
+
+// this is extremely wasteful but required to prevent false sharing in the producer...
+#ifdef MVEE_PARTIAL_ORDER_REPLICATION
+# ifdef MVEE_EXTENDED_QUEUE
+      #define MVEE_LOCK_QUEUE_SLOT_SIZE (sizeof(long) + sizeof(short) * (mvee_num_childs + 1))
+# else
+      #define MVEE_LOCK_QUEUE_SLOT_SIZE (sizeof(long) + sizeof(short) + (mvee_num_childs - 1))
+# endif
+#else
+# ifdef MVEE_EXTENDED_QUEUE
+      #define MVEE_LOCK_QUEUE_SLOT_SIZE (3*sizeof(long))
+# else
+      #define MVEE_LOCK_QUEUE_SLOT_SIZE sizeof(short)
+# endif
+#endif
+#define mvee_lock_buffer_slot_size 64
+#define mvee_malloc_buffer_slot_size 64
+
+// In the new queue layout, we want each replica's lock, position, 
+// flush_cnt and flushing word on one and the same cache line
+// Therefore, we round up the buffer ptr to a multiple of 64 for the master replica.
+// Each subsequent replica has its variables aligned on the next cache line boundary
+
+#define INIT_MVEE_QUEUE(name, slot_size, queue_ident)			\
+  if (!mvee_##name##_buffer_data_start)					\
+    {									\
+      long tmp_id = syscall(MVEE_GET_SHARED_BUFFER, 0, queue_ident, &mvee_##name##_buffer_slots, MVEE_LOCK_QUEUE_SLOT_SIZE); \
+      mvee_##name##_buffer_slots      = (mvee_##name##_buffer_slots - mvee_num_childs * 64) / mvee_##name##_buffer_slot_size - 2; \
+      void* tmp_buffer                = (void*)syscall(__NR_shmat, tmp_id, NULL, 0); \
+      mvee_##name##_buffer_lock       = (volatile unsigned int*)  (MVEE_ROUND_UP((unsigned long)tmp_buffer, 64) + mvee_child_num * 64); \
+      mvee_##name##_buffer_pos        = (volatile unsigned int*)  (MVEE_ROUND_UP((unsigned long)tmp_buffer, 64) + mvee_child_num * 64 + sizeof(int)); \
+      mvee_##name##_buffer_flush_cnt  = (volatile unsigned int*)  (MVEE_ROUND_UP((unsigned long)tmp_buffer, 64) + mvee_child_num * 64 + sizeof(int) * 2); \
+      mvee_##name##_buffer_flushing   = (volatile unsigned char*) (MVEE_ROUND_UP((unsigned long)tmp_buffer, 64) + mvee_child_num * 64 + sizeof(int) * 3); \
+     *mvee_##name##_buffer_lock       = 1; \
+      mvee_##name##_buffer_data_start = MVEE_ROUND_UP((unsigned long)tmp_buffer, 64) + mvee_num_childs * 64; \
+      if (mvee_##name##_buffer_log_eips)				\
+	{								\
+	  long eip_buffer_id = syscall(MVEE_GET_SHARED_BUFFER, 1,	\
+				      queue_ident, NULL, mvee_num_childs * sizeof(long) * MVEE_STACK_DEPTH, MVEE_STACK_DEPTH); \
+	  mvee_##name##_eip_buffer = (void*)syscall(__NR_shmat, eip_buffer_id, NULL, 0); \
+	}								\
+    }									
+
+#define MVEE_LOG_QUEUE_DATA(name, pos, offset, data)			\
+  *(typeof(data)*)(mvee_##name##_buffer_data_start + mvee_##name##_buffer_slot_size * (pos) + offset) = data;
+
+#define MVEE_READ_QUEUE_DATA(name, pos, offset, result)			\
+  result = *(typeof(result)*)(mvee_##name##_buffer_data_start + mvee_##name##_buffer_slot_size * pos + offset);
+
+#define MVEE_LOG_STACK(name, start_depth, pos)				\
+  mvee_log_stack(mvee_##name##_eip_buffer, sizeof(long) * mvee_num_childs * MVEE_STACK_DEPTH, pos, start_depth);
+
+#ifdef MVEE_DEBUG_MALLOC
+extern void mvee_malloc_hook(int alloc_type, int msg, long chunksize, void* ar_ptr, void* chunk_ptr);
+#define MVEE_MALLOC_HOOK(type, msg, sz, ar_ptr, chunk_ptr)		\
+  mvee_malloc_hook(type, msg, sz, ar_ptr, chunk_ptr)
+#else
+#define MVEE_MALLOC_HOOK(type, msg, sz, ar_ptr, chunk_ptr)
+#endif // !MVEE_DEBUG_MALLOC
+
+extern void mvee_invalidate_buffer      (void);
+extern void mvee_atomic_postop_internal (unsigned char preop_result);
+extern int  mvee_should_sync_tid        (void);
+extern int  mvee_all_heaps_aligned      (char* heap, unsigned long alloc_size); 
+extern void mvee_malloc_hook(int alloc_type, int msg, long chunksize, void* ar_ptr, void* chunk_ptr);
+extern void mvee_write_malloc_info(int alloc_type, int msg, long chunksize, void* ar_ptr, void* chunk_ptr);
+extern void mvee_verify_malloc_info(int alloc_type, int msg, long chunksize, void* ar_ptr, void* chunk_ptr);
+
+#define MVEE_POSTOP() \
+  mvee_atomic_postop_internal(__tmp_mvee_preop);
+
+#ifdef MVEE_EXTENDED_QUEUE
+ extern unsigned char     mvee_atomic_preop_internal             (unsigned char is_store, void* word_ptr, unsigned short op_type);
+# define MVEE_PREOP(op_type, mem, is_store)					\
+   register unsigned char __tmp_mvee_preop = mvee_atomic_preop_internal(is_store, mem, op_type);
+#else
+ extern unsigned char     mvee_atomic_preop_internal            (unsigned char is_store, void* word_ptr);
+# define MVEE_PREOP(op_type, mem, is_store) \
+   register unsigned char __tmp_mvee_preop = mvee_atomic_preop_internal(is_store, mem);
+#endif // !MVEE_EXTENDED_QUEUE
+
+#endif
+
+#ifdef IS_IN_rtld
+
+// sysdeps/atomic.h patches
+#define catomic_and(mem, mask) orig_catomic_and(mem, mask)
+#define catomic_or(mem, mask) orig_catomic_or(mem, mask)
+#define catomic_exchange_and_add(mem, value) orig_catomic_exchange_and_add(mem, value)
+#define catomic_add(mem, value) orig_catomic_add(mem, value)
+#define catomic_increment(mem) orig_catomic_increment(mem)
+#define catomic_decrement(mem) orig_catomic_decrement(mem)
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) orig_atomic_compare_and_exchange_val_acq(mem, newval, oldval)
+#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval) orig_atomic_compare_and_exchange_bool_acq(mem, newval, oldval)
+#define atomic_exchange_acq(mem, newvalue) orig_atomic_exchange_acq(mem, newvalue)
+#define atomic_exchange_and_add(mem, value) orig_atomic_exchange_and_add(mem, value)
+#define atomic_increment_and_test(mem) orig_atomic_increment_and_test(mem)
+#define atomic_decrement_and_test(mem) orig_atomic_decrement_and_test(mem)
+#define atomic_add_zero(mem, value) orig_atomic_add_zero(mem, value)
+#define atomic_add(mem, value) orig_atomic_add(mem, value)
+#define atomic_increment(mem) orig_atomic_increment(mem)
+#define atomic_decrement(mem) orig_atomic_decrement(mem)
+#define atomic_bit_test_set(mem, bit) orig_atomic_bit_test_set(mem, bit)
+#define atomic_bit_set(mem, bit) orig_atomic_bit_set(mem, bit)
+#define atomic_and(mem, mask) orig_atomic_and(mem, mask)
+
+// include/atomic.h patches
+// #define catomic_compare_and_exchange_val_acq(mem, newval, oldval) orig_catomic_compare_and_exchange_val_acq(mem, newval, oldval)
+// #define catomic_compare_and_exchange_bool_acq(mem, newval, oldval) orig_catomic_compare_and_exchange_bool_acq(mem, newval, oldval)
+// #define atomic_forced_read(x) orig_atomic_forced_read(x)
+
+// nptl/sysdeps/tls.h patches
+// #define THREAD_ATOMIC_CMPXCHG_VAL(descr, member, newval, oldval) orig_THREAD_ATOMIC_CMPXCHG_VAL(descr, member, newval, oldval)
+// #define THREAD_ATOMIC_AND(descr, member, val) orig_THREAD_ATOMIC_AND(descr, member, val)
+// #define THREAD_ATOMIC_BIT_SET(descr, member, bit) orig_THREAD_ATOMIC_BIT_SET(descr, member, bit)
+
+// MVEE additions
+#define atomic_load(var) ({ var; })
+#define atomic_store(var, val) ({ var = val; })
+
+#else // !IS_IN_rtld
+
+// sysdeps/atomic.h patches
+#define catomic_and(mem, mask)			\
+  ({						\
+    MVEE_PREOP(CATOMIC_AND, mem, 1);		\
+    orig_catomic_and(mem, mask);		\
+    MVEE_POSTOP();				\
+  })
+
+#define catomic_or(mem, mask)			\
+  ({						\
+    MVEE_PREOP(CATOMIC_OR, mem, 1);		\
+    orig_catomic_or(mem, mask);			\
+    MVEE_POSTOP();				\
+  })
+
+
+#define catomic_exchange_and_add(mem, value)			\
+  ({								\
+    typeof(*mem) ____result;					\
+    MVEE_PREOP(CATOMIC_EXCHANGE_AND_ADD, mem, 1);		\
+    ____result = orig_catomic_exchange_and_add(mem, value);	\
+    MVEE_POSTOP();						\
+    ____result;							\
+  })
+
+
+#define catomic_add(mem, value)			\
+  ({						\
+    MVEE_PREOP(CATOMIC_ADD, mem, 1);		\
+    orig_catomic_add(mem, value);		\
+    MVEE_POSTOP();				\
+  })
+
+
+#define catomic_increment(mem)			\
+  ({						\
+    MVEE_PREOP(CATOMIC_INCREMENT, mem, 1);	\
+    orig_catomic_increment(mem);		\
+    MVEE_POSTOP();				\
+  })
+
+
+#define catomic_decrement(mem)			\
+  ({						\
+    MVEE_PREOP(CATOMIC_DECREMENT, mem, 1);	\
+    orig_catomic_decrement(mem);		\
+    MVEE_POSTOP();				\
+  })
+
+#define catomic_max(mem, value)			\
+  ({						\
+    MVEE_PREOP(CATOMIC_MAX, mem, 1);		\
+    orig_catomic_max(mem, value);		\
+    MVEE_POSTOP();				\
+  })
+
+
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval)	\
+  ({									\
+    typeof(*mem) ____result;						\
+    MVEE_PREOP(ATOMIC_COMPARE_AND_EXCHANGE_VAL_ACQ, mem, 1);		\
+    ____result = orig_atomic_compare_and_exchange_val_acq(mem, newval, oldval); \
+    MVEE_POSTOP();							\
+    ____result;								\
+  })
+
+
+#define atomic_compare_and_exchange_bool_acq(mem, newval, oldval)	\
+  ({									\
+    bool ____result;							\
+    MVEE_PREOP(ATOMIC_COMPARE_AND_EXCHANGE_BOOL_ACQ, mem, 1);		\
+    ____result = orig_atomic_compare_and_exchange_bool_acq(mem, newval, oldval); \
+    MVEE_POSTOP();							\
+    ____result;								\
+  })
+
+
+#define atomic_exchange_acq(mem, newvalue)			\
+  ({								\
+    typeof(*mem) ____result;					\
+    MVEE_PREOP(ATOMIC_EXCHANGE_ACQ, mem, 1);			\
+    ____result = orig_atomic_exchange_acq(mem, newvalue);	\
+    MVEE_POSTOP();						\
+    ____result;							\
+  })
+
+
+#define atomic_exchange_and_add(mem, value)			\
+  ({								\
+    typeof(*mem) ____result;					\
+    MVEE_PREOP(ATOMIC_EXCHANGE_AND_ADD, mem, 1);		\
+    ____result = orig_atomic_exchange_and_add(mem, value);	\
+    MVEE_POSTOP();						\
+    ____result;							\
+  })
+
+
+#define atomic_increment_and_test(mem)			\
+  ({							\
+    unsigned char ____result;				\
+    MVEE_PREOP(ATOMIC_INCREMENT_AND_TEST, mem, 1);	\
+    ____result = orig_atomic_increment_and_test(mem);	\
+    MVEE_POSTOP();					\
+    ____result;						\
+  })
+
+
+#define atomic_decrement_and_test(mem)			\
+  ({							\
+    unsigned char ____result;				\
+    MVEE_PREOP(ATOMIC_DECREMENT_AND_TEST, mem, 1);	\
+    ____result = orig_atomic_decrement_and_test(mem);	\
+    MVEE_POSTOP();					\
+    ____result;						\
+  })
+
+
+#define atomic_add_zero(mem, value)			\
+  ({							\
+    unsigned char ____result;				\
+    MVEE_PREOP(ATOMIC_ADD_ZERO, mem, 1);		\
+    ____result = orig_atomic_add_zero(mem, value);	\
+    MVEE_POSTOP();					\
+    ____result;						\
+  })
+
+
+#define atomic_add(mem, value)			\
+  ({						\
+    MVEE_PREOP(ATOMIC_ADD, mem, 1);		\
+    orig_atomic_add(mem, value);		\
+    MVEE_POSTOP();				\
+  })
+
+
+#define atomic_increment(mem)			\
+  ({						\
+    MVEE_PREOP(ATOMIC_INCREMENT, mem, 1);	\
+    orig_atomic_increment(mem);			\
+    MVEE_POSTOP();				\
+  })
+
+
+#define atomic_decrement(mem)			\
+  ({						\
+    MVEE_PREOP(ATOMIC_DECREMENT, mem, 1);	\
+    orig_atomic_decrement(mem);			\
+    MVEE_POSTOP();				\
+  })
+
+
+#define atomic_bit_test_set(mem, bit)			\
+  ({							\
+    unsigned char ____result;				\
+    MVEE_PREOP(ATOMIC_BIT_TEST_SET, mem, 1);		\
+    ____result = orig_atomic_bit_test_set(mem, bit);	\
+    MVEE_POSTOP();					\
+    ____result;						\
+  })
+
+
+#define atomic_bit_set(mem, bit)		\
+  ({						\
+    MVEE_PREOP(ATOMIC_BIT_SET, mem, 1);		\
+    orig_atomic_bit_set(mem, bit);		\
+    MVEE_POSTOP();				\
+  })
+
+
+#define atomic_and(mem, mask)			\
+  ({						\
+    MVEE_PREOP(ATOMIC_AND, mem, 1);		\
+    orig_atomic_and(mem, mask);			\
+    MVEE_POSTOP();				\
+  })
+
+
+
+// include/atomic.h patches
+#define catomic_compare_and_exchange_val_acq(mem, newval, oldval)	\
+  ({									\
+    typeof(*mem) ____result;						\
+    MVEE_PREOP(CATOMIC_COMPARE_AND_EXCHANGE_VAL_ACQ, mem, 1);		\
+    ____result = orig_catomic_compare_and_exchange_val_acq(mem, newval, oldval); \
+    MVEE_POSTOP();							\
+    ____result;								\
+  })
+
+#define catomic_compare_and_exchange_bool_acq(mem, newval, oldval)	\
+  ({									\
+    bool ____result;							\
+    MVEE_PREOP(CATOMIC_COMPARE_AND_EXCHANGE_BOOL_ACQ, mem, 1);		\
+    ____result = orig_catomic_compare_and_exchange_bool_acq(mem, newval, oldval); \
+    MVEE_POSTOP();							\
+    ____result;								\
+  })
+
+#define atomic_forced_read(x)			\
+  ({						\
+    typeof(x) ____result;			\
+    MVEE_PREOP(ATOMIC_FORCED_READ, &x, 0);	\
+    ____result = orig_atomic_forced_read(x);	\
+    MVEE_POSTOP();				\
+    ____result;					\
+  })
+
+
+
+// nptl/sysdeps/tls.h patches
+#if 0
+#define THREAD_ATOMIC_CMPXCHG_VAL(descr, member, newval, oldval)	\
+  ({									\
+    __typeof(descr->member) ____result;					\
+    MVEE_PREOP(__THREAD_ATOMIC_CMPXCHG_VAL, &descr->member, 1);		\
+    ____result = orig_THREAD_ATOMIC_CMPXCHG_VAL(descr, member, newval, oldval); \
+    MVEE_POSTOP();							\
+    ____result;								\
+  })
+
+
+#define THREAD_ATOMIC_AND(descr, member, val)			\
+  (void)({							\
+      MVEE_PREOP(__THREAD_ATOMIC_AND, &descr->member, 1);	\
+      orig_THREAD_ATOMIC_AND(descr, member, val);		\
+      MVEE_POSTOP();						\
+    })
+
+
+#define THREAD_ATOMIC_BIT_SET(descr, member, bit)		\
+  (void)({							\
+      MVEE_PREOP(__THREAD_ATOMIC_BIT_SET, &descr->member, 1);	\
+      orig_THREAD_ATOMIC_BIT_SET(descr, member, bit);		\
+      MVEE_POSTOP();						\
+    })
+#endif
+
+
+// MVEE additions
+#define atomic_load(var)			\
+  ({						\
+    __typeof(var+0) ____result;			\
+    MVEE_PREOP(ATOMIC_LOAD, &var, 0);		\
+    ____result = var;				\
+    MVEE_POSTOP();				\
+    ____result;					\
+  })
+
+#define atomic_store(var, val)			\
+  ({						\
+    MVEE_PREOP(ATOMIC_STORE, &var, 1);		\
+    var = val;					\
+    MVEE_POSTOP();				\
+  })
+
+#define atomic_max(mem, value)			\
+  ({						\
+    MVEE_PREOP(ATOMIC_MAX, mem, 1);		\
+    orig_atomic_max(mem, value);		\
+    MVEE_POSTOP();				\
+  })
+
+#define atomic_decrement_if_positive(mem)		\
+  ({							\
+    __typeof(*mem) __result;				\
+    MVEE_PREOP(ATOMIC_DECREMENT_IF_POSITIVE, mem, 1);	\
+    __result = orig_atomic_decrement_if_positive(mem);	\
+    MVEE_POSTOP();					\
+    __result;						\
+  })
 
-#define catomic_or(mem, mask) __arch_or_body (__arch_cprefix, mem, mask)
+
+#endif
