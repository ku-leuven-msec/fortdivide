#include <inttypes.h>
#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>

/* loop iterations to sent a '1' bit */
#define LOOP_COUNT      100000000
/* minimal rdtsc delta to detect a '1' */
#define THRESHOLD_FOR_1 10000000

uint64_t rdtsc() {  
	unsigned int upper, lower;
	__asm__ __volatile__ ("xorq %%rax, %%rax; cpuid; rdtsc\n" : "=a" (lower), "=d" (upper));
	return (uint64_t)lower + (((uint64_t)upper) << 32);
}
volatile long dummy;

/* This (nondeterministically) returns if a variant
   is the master variant. In general this could be
   a hash(addr); in our tests this mask sufficed */
int ismaster_guess() {
	if (((long)ismaster_guess) & 0x2000)
		return 1;
	else
		return 0;
}

int receive_bit() {
	uint64_t start = rdtsc();
	/* The other variant executes the loop here */
	uint64_t end = rdtsc();
	return ((end - start) > THRESHOLD_FOR_1);
}
/* The rdtsc calls here sync with the receiver */
void send_bit(int b) {
	rdtsc();
	for (int i = 0; i < b * LOOP_COUNT; i++)
		dummy = 0;
	rdtsc();
}

void send_pointer(void* ptr_) {
	uint64_t ptr = (uint64_t) ptr_;
	for (int i = 0; i < 64; i++) {
		if (ptr & 0x8000000000000000)
			send_bit(1);
		else
			send_bit(0);
		ptr <<= 1;
	}
}
void* receive_pointer() {
	uint64_t ptr = 0;
	for (int i = 0; i < 64; i++) {
		ptr <<= 1;
		ptr |= receive_bit();
	}
	return (void*) ptr;
}

typedef enum sndrcv { SEND, RECV } sndrcv_t;

void* communicate(void* input, sndrcv_t send) {
	if (send == SEND) {
		send_pointer(input);
		return input;
	}
	return receive_pointer();
}

int main() {
	void* pointers[2] = { 0 , 0 };
	if (ismaster_guess()) {
		pointers[0] = communicate((void*)main, SEND);
		pointers[1] = communicate((void*)main, RECV);
	} else {
		pointers[0] = communicate((void*)main, RECV);
		pointers[1] = communicate((void*)main, SEND);
	}
	printf("\t&main in variant A: %p\n", pointers[0]);
	printf("\t&main in variant B: %p\n", pointers[1]);
}
